<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Going Async With ES6 Generators | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#用Generator进行异步编程（译）
原文地址：http://davidwalsh.name/async-generators
ES6 Generators：全系列

The Basics Of ES6 Generators
Diving Deeper With ES6 Generators
Going Async With ES6 Generators
Getting Concurrent">
<meta property="og:type" content="article">
<meta property="og:title" content="Going Async With ES6 Generators">
<meta property="og:url" content="http://nnabuuu.github.io/blog-hexo/2014/12/26/Going-Async-With-ES6-Generators/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#用Generator进行异步编程（译）
原文地址：http://davidwalsh.name/async-generators
ES6 Generators：全系列

The Basics Of ES6 Generators
Diving Deeper With ES6 Generators
Going Async With ES6 Generators
Getting Concurrent">
<meta property="og:updated_time" content="2016-04-29T18:43:51.163Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Going Async With ES6 Generators">
<meta name="twitter:description" content="#用Generator进行异步编程（译）
原文地址：http://davidwalsh.name/async-generators
ES6 Generators：全系列

The Basics Of ES6 Generators
Diving Deeper With ES6 Generators
Going Async With ES6 Generators
Getting Concurrent">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog-hexo/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog-hexo/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog-hexo/">Home</a>
        
          <a class="main-nav-link" href="/blog-hexo/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://nnabuuu.github.io/blog-hexo"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Going-Async-With-ES6-Generators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2014/12/26/Going-Async-With-ES6-Generators/" class="article-date">
  <time datetime="2014-12-27T05:01:21.000Z" itemprop="datePublished">2014-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Going Async With ES6 Generators
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#用Generator进行异步编程（译）</p>
<p>原文地址：<a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">http://davidwalsh.name/async-generators</a></p>
<p>ES6 Generators：全系列</p>
<ol>
<li><a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">The Basics Of ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">Diving Deeper With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">Getting Concurrent With ES6 Generators</a></li>
</ol>
<p>现在你已经<a href="http://davidwalsh.name/es6-generators/" target="_blank" rel="external">见识过了ES6 generator</a>并且已经对它已经<a href="http://davidwalsh.name/es6-generators-dive/" target="_blank" rel="external">有所熟悉</a>了，现在是时候开始使用它们来增强我们真实的代码了。</p>
<p>Generator的主要唱出在于它们提供了一个单线程的，同步样式的代码风格，<strong>同时允许你把异步隐藏为实现细节</strong>。这使得我们用一种非常自然的方式表达，专注于我们程序的步骤/声明的流程，而不必同时不得不遵循异步语法并避免陷阱。</p>
<p>换句话说，我们通过隔离对值的消费（我们的generator逻辑）与异步得到这些值的细节（generator迭代器中的<code>next(..)</code>），实现了<strong>能力与缺点的完美分离</strong>。</p>
<p>结果呢？我们获得了异步代码的强大能力，同时也获得了（看上去是）同步代码的可读性以及可维护性。</p>
<p>那么我们如何实现这个非凡的能力呢？</p>
<h2 id="最简单的异步"><a href="#最简单的异步" class="headerlink" title="最简单的异步"></a>最简单的异步</h2><p>在最简单的场景下，generator不需要任何额外的操作来实现你的程序中并没有的异步操作。</p>
<p>例如，让我们设想你已经有了这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do some ajax fun</span></span><br><span class="line">    <span class="comment">// call `cb(result)` when complete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeAjaxCall( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    makeAjaxCall( <span class="string">"http://some.url.2/?id="</span> + data.id, <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>要使用一个generator来表现同样的程序，你需要这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this is where we're hiding the asynchronicity,</span></span><br><span class="line">    <span class="comment">// away from the main code of our generator</span></span><br><span class="line">    <span class="comment">// `it.next(..)` is the generator's iterator-resume</span></span><br><span class="line">    <span class="comment">// call</span></span><br><span class="line">    makeAjaxCall( url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">        it.next( response );</span><br><span class="line">    &#125; );</span><br><span class="line">    <span class="comment">// Note: nothing returned here!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next(); <span class="comment">// get it all started</span></span><br></pre></td></tr></table></figure>
<p>让我们来解释一下它是如何工作的：</p>
<p><code>request(..)</code>功能函数基本上包装我们普通的<code>makeAjaxCall(..)</code>功能类以保证它的回调函数能调用generator iterator的<code>next(..)</code>方法。</p>
<p>对于<code>request(&quot;..&quot;)</code>调用，你会注意到它<em>没有返回值</em>（换句话说，它是<code>undefined</code>）。这不是什么大问题，但是它和我们在本文之后的实现方式有所不同：我们在这里实际上是调用了<code>yield undefined</code>。</p>
<p>因此我们调用<code>yield ..</code>（和这个<code>undefined</code>值），它实际上什么也没做，它只是在这一点上暂停了我们的generator。它将会等待直到<code>it.next(..)</code>被调用来恢复它，这个调用我们已经排列在队列中（作为回调函数），在Ajax调用结束后发生。</p>
<p>但是<code>yield ..</code>表达式的<em>结果</em>又发生了什么？我们将它赋值到变量<code>result1</code>上。它是如何得到第一个Ajax调用的内部的值的呢？</p>
<p>因为当<code>it.next(..)</code>被作为Ajax回调函数调用时，它实际是在给它传递Ajax的响应结果，这表明值在那个当前暂停的时间点被发送回我们的generator内部，也就是<code>result1 = yield ..</code>表达式的中间！</p>
<p>这的确非常的酷并且超级强大。本质上，<code>result1 = yield reequest(..)</code>是在<strong>请求这个值</strong>，但是它（几乎！）完全对我们隐藏了 – 至少我们不需要在这里担心它 – 外表之下的实际实现是异步的。它通过<em>隐藏</em><code>yield</code>中的暂停能力实现了异步，并且分离出generator的<em>恢复</em>能力到另外一个函数中，因此我们的main代码只需要进行一个<strong>（看起来是）同步的值的请求</strong>。</p>
<p>对于第二个<code>result2 = yield result(..)</code>表达式也是一样：它对于暂停和恢复是透明的，并且提供了我们所需求的值，所有这些都没有让任何异步细节打扰到我们我代码。</p>
<p>当然<code>yield</code>出现了，因此那里的确有一个细微的提示“一些神奇的东西（异步）<em>可能发生</em>在那个时间点”。但是<code>yield</code>比起回调地狱（或者甚至是promise链的API冗余！）来已经是一个简单的语法信号/冗余了。</p>
<p>注意到我刚刚说了<em>可能发生</em>。这是一个相当强大的事情。上面的程序总是发出一个Ajax请求，但是<strong>如果它不这样呢</strong>？如果我们之后将我们的程序改为读取内存中之前得到的Ajax响应呢？或者一些程序中的复杂URL rouer可能在某些条件下立即响应一个Ajax请求而不需要真的从一个外部服务器获取呢？</p>
<p>我们可以改变<code>request(..)</code>的实现使它变成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[url]) &#123;</span><br><span class="line">        <span class="comment">// "defer" cached response long enough for current</span></span><br><span class="line">        <span class="comment">// execution thread to complete</span></span><br><span class="line">        setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            it.next( cache[url] );</span><br><span class="line">        &#125;, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">            cache[url] = resp;</span><br><span class="line">            it.next( resp );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里有一个小技巧是需要使用<code>setTimeout(..0)</code>进行延迟以防cache已经在结果里面了。如果我们刚刚立即调用<code>it.next(..)</code>，它会产生一个错误，因为（这就是那个技巧）generator<em>尚未</em>处于暂停状态。我们的函数调用<code>request(..)</code><em>首先</em>被评估，然后<code>yield</code>暂停。因此我们不能再次在<code>request(..)</code>内部调用<code>it.next(..)</code>，因为在那个时刻generator扔在执行（<code>yield</code>还没有被进行）。但是我们可以”之后“调用<code>it.next(..)</code>，在当前线程执行完的一瞬间，也就是我们的<code>setTimeout(..0)</code>”伪造“的一个实现。<strong>我们会在下面有一个更好的实现</strong>。</p>
<p>现在我们的main generator代码仍然看起来像：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>看到了吧？！我们的generator逻辑（也就是控制流）和不加cache的版本比起来<strong>完全</strong>不需要变化。</p>
<p><code>*main()</code>中的代码仍然请求一个值，然后暂停直到它得到值。在我们当前的情境下，”暂停“可以非常长（发送一个真实的请求到服务器，一般为300-800ms）或者可能几乎立即结束（<code>setTimeout(..0)</code>进行延迟处理）。而我们的控制流并不关心。</p>
<p>这就是<strong>将异步行为抽象为实现细节</strong>真正的强大之处。</p>
<h2 id="更好的异步"><a href="#更好的异步" class="headerlink" title="更好的异步"></a>更好的异步</h2><p>对于一个单独的异步generator工作，上面的实现已经相当不错了。但是它马上会到达局限，所以我们需要一个更强大的异步机制来和我们的generator做搭配，它能够承担更多的负担。这个机制是什么呢？就是<strong>Promise</strong>。</p>
<p>如果你对于ES6的Promise还有点模糊不清，我写了一个<a href="http://blog.getify.com/promises-part-1/" target="_blank" rel="external">5篇文章的系列</a>，去读一读吧。我会在这里wait直到你回来的（偷笑，哈哈）。这只是个老掉牙的异步的笑话啦！</p>
<p>本文早先的Ajax代码都有同样的<a href="http://blog.getify.com/promises-part-2/" target="_blank" rel="external">控制反转</a>的问题（也就是”回调地狱“），就下你给我们最初的那个充满了回调的例子一样。到目前为止，我们缺乏这样一些东西：</p>
<ol>
<li><p>没有明确的异常处理的方式。我们已经<a href="http://davidwalsh.name/es6-generators-dive/#error-handling" target="_blank" rel="external">从上篇文章中学到</a>，我们可以探测到一个Ajax调用时的异常（通过某种方式），通过<code>it.throw(..)</code>传递回我们的generator，然后使用<code>try..catch</code>在我们的generator逻辑中处理它。但是那只是更多的手动任务来接通“后端”（我们处理generator iterator的代码），并且如果我们需要非常多的generator是，它可能无法重复使用。</p>
</li>
<li><p>如果<code>makeAjaxCall(..)</code>工具类不受控制，并且它调用了多次的callback，或者信号同时成功与失败，等等。那么我们的generator会出故障（未捕获的异常，不期待的值，等等）。处理并且阻止这些问题很多都是手动工作，并且同样无法重用。</p>
</li>
<li><p>经常的，我们并不仅仅”并发“执行任务（例如两个并行的Ajax调用那样）。由于generator<code>yield</code>表达式是一个单一暂停点，两个或两个以上的generator不可以在同时运行 – 它们不得不一次一个的执行，按顺序。因此，对于如何在单独的generator <code>yield</code>点发送多个任务，而不在表面之下进行大量的人工编码，是尚不可知的。</p>
</li>
</ol>
<p>如你所见，所有这些问题都是<em>可以被解决的</em>，但是谁又希望每次都重新发明这些解决方法呢？我们需要一个更强大的模式，设计为专为基于generator的异步编码的<a href="http://blog.getify.com/promises-part-3/" target="_blank" rel="external">可信的，可重用的解决方案</a>。</p>
<p>那个模式是？<strong><code>yield</code> out promises</strong>，并且当他们被fulfill时让它们恢复generator。</p>
<p>回想一下上面我们所做的<code>yield request(..)</code>，以及<code>request(..)</code>功能方法没有任何返回值，仅仅<code>yield undefined</code>是有效的吗？</p>
<p>让我们小小的对他进行调整。让我们改变我们的<code>request(..)</code>功能方法使其成为一个基于promise的方法，这样它会返回一个promise，并且这样的话我们<code>yield</code> out的东西<strong>实际上是一个promise</strong>（而不是<code>undefined</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Note: returning a promise now!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        makeAjaxCall( url, resolve );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，<code>request(..)</code>会构造一个Ajax调用结束后被处理的promise，并返回这个promise，所以它可以被<code>yield</code>出去，下一步呢？</p>
<p>我们会需要一个功能方法来控制我们的generator iterator，它接收这些被<code>yield</code>的promise然后将他们与恢复generator联通(通过<code>next(..)</code>)。我现在会调用下面这个<code>runGenerator(..)</code>功能类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run (async) a generator to completion</span></span><br><span class="line"><span class="comment">// Note: simplified approach: no error handling here</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> it = g(), ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// asynchronously iterate over generator</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        ret = it.next( val );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ret.done) &#123;</span><br><span class="line">            <span class="comment">// poor man's "is it a promise?" test</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</span><br><span class="line">                <span class="comment">// wait on the promise</span></span><br><span class="line">                ret.value.then( iterate );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// immediate value: just send right back in</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// avoid synchronous recursion</span></span><br><span class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    iterate( ret.value );</span><br><span class="line">                &#125;, <span class="number">0</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的关键点：</p>
<ol>
<li><p>我们自动的对generator进行初始化（创建它的<code>it</code>迭代器），然后我们异步地运行<code>it</code>直到结束（<code>done: ture</code>）。</p>
</li>
<li><p>我们寻找要被<code>yield</code>出去（即在每个<code>it.next(..)</code>调用时的返回值<code>value</code>）的promise。如果有的话，我们通过在promise之上注册<code>then(..)</code>等待直到它结束。</p>
</li>
<li><p>如果任何立即的（即非promise）值被返回，我们简单地发送这个值到generator中以便它继续立即执行。</p>
</li>
</ol>
<p>现在，我们怎么使用它呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Bam！等一等…这不<strong>和我们之前的generator代码一样</strong>吗？是的。再一次地，generator的强大之处显示出来了。实际上是，我们现在在创建promise，将他们<code>yield</code>出去，然后在generator结束时恢复他们 – <strong>所有这些都隐藏了实现细节！</strong> 当然并不是完全隐藏，只是从消费代码（我们generator内部的控制流）中分离出来了。</p>
<p>通过等待被<code>yield</code>出去的promise，并且发送完成结果回<code>it.next(..)</code>，代码<code>result1 = yield request()..</code>得到了和之前完全相同的值。</p>
<p>但是现在我们在使用promise来管理generator代码中的异步部分，我们解决所有的来自于回调风格解决方案的倒转/信任问题。我们通过使用generator + promise得到所有上面的解决方案。</p>
<ol>
<li><p>我们现在有了便于使用的内嵌的异常处理。我们在上面的<code>runGenerator(..)</code>中并没有显示它，但是从promise中监听一个异常并发送至<code>it.throw(..)</code>并不困难 – ranh9ou我们可以在我们的generator代码中使用<code>try..catch</code>来捕获并处理这些异常。</p>
</li>
<li><p>我们拥有了所有由promise提供的<a href="http://blog.getify.com/promises-part-2/#uninversion" target="_blank" rel="external">控制/可信性解决方案</a>。不需要更多的关心。</p>
</li>
<li><p>Promise拥有非常多位于上层的强大的抽象，它可以自动地处理复杂的多“并发”任务，等等。</p>
</li>
</ol>
<p>例如<code>yield Promise.all([ .. ])</code>可以接受一个prmose的数组来“并发执行”任务，然后<code>yield</code>出一个单一的promise（给generator来处理），它在处理前等待所有的子promise结束（无论以何种顺序）。你从<code>yield</code>表达式返回的（当promise结束时）是一个所有子promise的响应数组，按照它们请求的顺序（无论它们的结束顺序是如何）。</p>
<p>首先让我们来看看异常处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume: `makeAjaxCall(..)` now expects an "error-first style" callback (omitted for brevity)</span></span><br><span class="line"><span class="comment">// assume: `runGenerator(..)` now also handles error handling (omitted for brevity)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// pass an error-first style callback</span></span><br><span class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span>(<span class="params">err,text</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject( err );</span><br><span class="line">            <span class="keyword">else</span> resolve( text );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>当获取URL时promise被拒绝（或者任何形式的错误/异常），promise rejection会被映射为一个generator错误（使用我们之前没有描述的<code>runGenerator(..)</code>中的<code>it.throw(..)</code>），它会被<code>try..catch</code>语句捕获住。</p>
<p>现在，让我们来看一个更下复杂的例子，它使用了promise来管理更多异步的复杂问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        makeAjaxCall( url, resolve );</span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="comment">// do some post-processing on the returned text</span></span><br><span class="line">    .then( <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// did we just get a (redirect) URL back?</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^https?:\/\/.+/</span>.test( text )) &#123;</span><br><span class="line">            <span class="comment">// make another sub-request to the new URL</span></span><br><span class="line">            <span class="keyword">return</span> request( text );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise, assume text is what we expected to get back</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> search_terms = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all( [</span><br><span class="line">        request( <span class="string">"http://some.url.1"</span> ),</span><br><span class="line">        request( <span class="string">"http://some.url.2"</span> ),</span><br><span class="line">        request( <span class="string">"http://some.url.3"</span> )</span><br><span class="line">    ] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> search_results = <span class="keyword">yield</span> request(</span><br><span class="line">        <span class="string">"http://some.url.4?search="</span> + search_terms.join( <span class="string">"+"</span> )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( search_results );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Search results: "</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><code>Promise.all([ .. ])</code>构造一个promise，它等待3个子promise。并且，被<code>yield</code>出提供给<code>runGenerator(..)</code>功能函数的主promise会被监听作为generator的恢复。子promise可以接收一个响应，它看起来像另一个URL，并且以链式连接另一个子promise到达新的地点。如果要学习更多promise链式表达，<a href="http://blog.getify.com/promises-part-5/#the-chains-that-bind-us" target="_blank" rel="external">阅读这篇文章</a>。</p>
<p>任何异步的功能性/复杂性问题都可以由promise解决，而同步风格代码则可以通过使用generator <code>yield</code>出promise（的promise的promise…）来实现。<strong>这真是两全其美</strong></p>
<h2 id="runGenerator-功能库"><a href="#runGenerator-功能库" class="headerlink" title="runGenerator(..): 功能库"></a>runGenerator(..): 功能库</h2><p>我们已经定义了我们自己的<code>runGenerator(..)</code>来启用这个强大的generator+promise组合。我们省略了这个功能函数的完全实现（为了简单起见），因为还有很多细节上和异常处理相关的内容需要完成。</p>
<p>但是，你并不想编写你自己的<code>runGenerator(..)</code>是吧？</p>
<p>我认为是的。</p>
<p>有非常多的promise/异步库提供了这样的功能。我在这里不会讲述，但你可以看一看<code>Q.spawn(..)</code>，<code>co(..)</code>库，等等。</p>
<p>我会简单的介绍一下我自己的功能库：<a href="http://github.com/getify/asynquence" target="_blank" rel="external">asynquence</a>的<a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" target="_blank" rel="external"><code>runner(..)</code>插件</a>，我认为它比上面的那些库提供了一些特殊的适配性。我写了深入的<a href="http://davidwalsh.name/asynquence-part-1/" target="_blank" rel="external">两部分的blog关于asynquence的系列文章</a>如果你感兴趣学到更多的话你可以去看一看。</p>
<p>首先，<em>asynquence</em>提供了功能类自动处理“首参数为错误风格”的回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// pass an error-first style callback</span></span><br><span class="line">        makeAjaxCall( url, done.errfcb );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这<strong>更加的友好</strong>了，不是吗！？</p>
<p>下一步，asynquence的<code>runner(..)</code>插件在<em>aynquence</em>序列（异步序列步骤）的中途消耗一个generator，所以你可以从之前的步骤向内传递消息，而你的generator可以向外或向下一步传递消息，而所有的错误会自动地如你期望的那样传播。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first call `getSomeValues()` which produces a sequence/promise,</span></span><br><span class="line"><span class="comment">// then chain off that sequence for more async steps</span></span><br><span class="line">getSomeValues()</span><br><span class="line"></span><br><span class="line"><span class="comment">// now use a generator to process the retrieved values</span></span><br><span class="line">.runner( <span class="function"><span class="keyword">function</span>*(<span class="params">token</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// token.messages will be prefilled with any messages</span></span><br><span class="line">    <span class="comment">// from the previous step</span></span><br><span class="line">    <span class="keyword">var</span> value1 = token.messages[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> value2 = token.messages[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> value3 = token.messages[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make all 3 Ajax requests in parallel, wait for</span></span><br><span class="line">    <span class="comment">// all of them to finish (in whatever order)</span></span><br><span class="line">    <span class="comment">// Note: `ASQ().all(..)` is like `Promise.all(..)`</span></span><br><span class="line">    <span class="keyword">var</span> msgs = <span class="keyword">yield</span> ASQ().all(</span><br><span class="line">        request( <span class="string">"http://some.url.1?v="</span> + value1 ),</span><br><span class="line">        request( <span class="string">"http://some.url.2?v="</span> + value2 ),</span><br><span class="line">        request( <span class="string">"http://some.url.3?v="</span> + value3 )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send this message onto the next step</span></span><br><span class="line">    <span class="keyword">yield</span> (msgs[<span class="number">0</span>] + msgs[<span class="number">1</span>] + msgs[<span class="number">2</span>]);</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// now, send the final result of previous generator</span></span><br><span class="line"><span class="comment">// off to another request</span></span><br><span class="line">.seq( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request( <span class="string">"http://some.url.4?msg="</span> + msg );</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// now we're finally all done!</span></span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( result ); <span class="comment">// success, all done!</span></span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// or, we had some error!</span></span><br><span class="line">.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>asynquence <code>runner(..)</code>功能类接受一个可选的消息来开始generator，这个消息往往是由之前的步骤而来，并且在generator的<code>token.messages</code>数组中是可见的。</p>
<p>然后，和我们之前示范使用<code>runGenerator(..)</code>功能类一样，<code>runner(..)</code>监听一个被<code>yield</code>的poromise或<em>asynquence</em>序列（在这种情况下使用<code>ASQ().all(..)</code>序列来并发执行），并且等待它的结束然后恢复generator。</p>
<p>当generator结束时，最后<code>yield</code>出的值会传递给序列的下一个步骤。</p>
<p>并且，如果有任何错误在这个序列的任何地方发生，甚至是在generator内部发生，它会被传播给单独的<code>or(..)</code>被注册的错误处理者。</p>
<p><em>asynquence</em>尝试将promise和generator尽可能简单的结合。你可以随心所欲的构造任何generator流和基于promise的序列步骤流。</p>
<h2 id="ES7-async"><a href="#ES7-async" class="headerlink" title="ES7 async"></a>ES7 <code>async</code></h2><p>ES7的时间轴上有一个提案，它看起来会被接受，来创建另一种函数：<code>async function</code>，它看起来是使用generator自动地包装一个像<code>runGenerator(..)</code>（或<em>asynquence</em>的<code>runner(..)</code>）功能类。那样的话你可以发送promise并且<code>async function</code>会自动地将其包装并且在结束时恢复promise（甚至不需要使用iterator！）</p>
<p>所以它看起来可能会像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = <span class="keyword">await</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">await</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<p>如你所见，一个<code>async function</code>可以被直接调用（就像<code>main()</code>一样），而不需要像<code>runGenerator(..)</code>或<code>ASQ().runner(..)</code>的包装功能类来包装它。在内部，有别于使用<code>yield</code>，你将会使用<code>await</code>（另一个新的关键词）来告知<code>async function</code>在继续执行前等待promise的结束。</p>
<p>基本上，我们会拥有大多数包装库包装后的generator的能力，但是<strong>直接由原生语法支持</strong></p>
<p>酷！是吧！</p>
<p>在同时，像<em>asynquence</em>这样的库给予我们这些执行功能函数来让我们使用异步generator更容易！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的说：generator + <code>yield</code>ed promise组合了双方最好的部分让我们得到了强大而优雅的同步语法+异步流程控制的能力。使用简单的包装功能函数（有非常多的功能库已经提供了这一点），我们可以自动的运行我们的generator到结束，包括正常结果以及出错的处理。</p>
<p>在ES7的大陆上，我们很可能会见到<code>async function</code>让我们可以不依靠功能库来达到（至少对基本的case可以这样实现）。</p>
<p><strong>JavaScript中异步的未来是光明的</strong>，并且只会变得更光明！我应该戴上太阳镜。</p>
<p>但是我们还没有结束，我们还有最后一个部分想要发掘一下：</p>
<p>如果你可以将两个或多个generator连接在一起会怎么样呢？让他们单独但“并发”的执行，并且让他们在执行的过程中互相发送消息？那会是一种更强大的能力，不是吗？这个模式被称为”CSP”（communicating sequential processes）。我们会在下一篇文章中解锁CSP的强大能力。请继续关注！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2014/12/26/Going-Async-With-ES6-Generators/" data-id="cirfvhfng0005bknbmd46vea0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/generator-async-translation/">generator async translation</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog-hexo/2015/01/04/Getting-Concurrent-With-ES6-Generators/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Getting Concurrent With ES6 Generators
        
      </div>
    </a>
  
  
    <a href="/blog-hexo/2014/12/24/Diving-Deeper-With-ES6-Generators/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Diving Deeper With ES6 Generators</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/Haskell/">Haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/NodeJS/">NodeJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/Translation/">Translation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/generator-async-translation/">generator async translation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/generator-translation/">generator translation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/jison/">jison</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/js-generator-tanslation/">js, generator, tanslation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/translation/">translation</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog-hexo/tags/Haskell/" style="font-size: 10px;">Haskell</a> <a href="/blog-hexo/tags/NodeJS/" style="font-size: 15px;">NodeJS</a> <a href="/blog-hexo/tags/Translation/" style="font-size: 10px;">Translation</a> <a href="/blog-hexo/tags/docker/" style="font-size: 10px;">docker</a> <a href="/blog-hexo/tags/generator-async-translation/" style="font-size: 10px;">generator async translation</a> <a href="/blog-hexo/tags/generator-translation/" style="font-size: 10px;">generator translation</a> <a href="/blog-hexo/tags/jison/" style="font-size: 15px;">jison</a> <a href="/blog-hexo/tags/js-generator-tanslation/" style="font-size: 10px;">js, generator, tanslation</a> <a href="/blog-hexo/tags/translation/" style="font-size: 20px;">translation</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/06/">June 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog-hexo/2016/08/03/fix-docker-x509-error/">fix-docker-x509-error</a>
          </li>
        
          <li>
            <a href="/blog-hexo/2016/04/29/Parsing-text-table-with-jison-3/">Parsing-text-table-with-jison-3</a>
          </li>
        
          <li>
            <a href="/blog-hexo/2016/04/28/Parsing-text-table-with-jison-2/">Parsing-text-table-with-jison-2</a>
          </li>
        
          <li>
            <a href="/blog-hexo/2016/04/21/Parsing-text-table-with-jison/">Parsing-text-table-with-jison</a>
          </li>
        
          <li>
            <a href="/blog-hexo/2015/10/31/Tail-Recursion-in-Haskell/">Tail Recursion in Haskell</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Xiaochen Nie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog-hexo/" class="mobile-nav-link">Home</a>
  
    <a href="/blog-hexo/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog-hexo/fancybox/jquery.fancybox.css">
  <script src="/blog-hexo/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog-hexo/js/script.js"></script>

  </div>
</body>
</html>