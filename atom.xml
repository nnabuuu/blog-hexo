<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <link href="/blog-hexo/atom.xml" rel="self"/>
  
  <link href="http://nnabuuu.github.io/blog-hexo/"/>
  <updated>2016-08-03T09:26:31.997Z</updated>
  <id>http://nnabuuu.github.io/blog-hexo/</id>
  
  <author>
    <name>Xiaochen Nie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fix-docker-x509-error</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2016/08/03/fix-docker-x509-error/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2016/08/03/fix-docker-x509-error/</id>
    <published>2016-08-03T09:24:59.000Z</published>
    <updated>2016-08-03T09:26:31.997Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>问题描述</li>
</ol>
<p>由于公司内部证书被IT部门修改，我们在使用docker pull某些镜像的时候会抛出x509错误 x509: certificate signed by unknown authority。<br>例如，我在尝试用docker-compose获取最新版本的spark时会显示：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">abuuu-VirtualBox<span class="meta"># sudo docker-compose up</span></span><br><span class="line">Pulling master (gettyimages/spark:latest)...</span><br><span class="line"><span class="symbol">latest:</span> Pulling from gettyimages/spark</span><br><span class="line"><span class="number">357</span>ea8c3d80b: Pulling fs layer</span><br><span class="line"><span class="symbol">c6cf625461b9:</span> Pulling fs layer</span><br><span class="line"><span class="number">06f</span>d4f43f066: Pulling fs layer</span><br><span class="line"><span class="symbol">dd98390795f4:</span> Waiting</span><br><span class="line"><span class="number">36769</span>b1579ad: Waiting</span><br><span class="line"><span class="symbol">b2e57763c10f:</span> Waiting</span><br><span class="line"><span class="symbol">ERROR:</span> error pulling image configuration: Get https:<span class="comment">//dseasb33srnrn.cloudfront.net/registry-v2/docker/registry/v2/blobs/sha256/4e/4ef9bff9a39ea255de6945d1480a771b4785b17a0da492fd6427e98ec5d624dd/data?Expires=1470184587&amp;Signature=TpEb2htK0E8yUKVinb03onAc35rMqzC4JPJeWnXQ1DkmFifVORmP9-Vusc8vtZjFG3yCyWgfIL8zRVLhmj3koVtb~QLcx5eHcmHprzj6nxXt~GC-MuUT91t65Q2eOqwQDNQAwlcPxP9moxggWmoGQaHyII0bIwBtvdZ7GiUnE0w_&amp;Key-Pair-Id=APKAJECH5M7VWIS5YZ6Q: x509: certificate signed by unknown authority</span></span><br></pre></td></tr></table></figure>
<p>我们可以看出，在访问dseasb33srnrn.cloudfront.net时产生了证书验证错误。</p>
<ol>
<li>解决方法</li>
</ol>
<p>参考<a href="http://www.cnblogs.com/sting2me/p/5596222.html上描述的方式，用openssl访问该网站，并将被替换后的证书保存至本地并用update-ca-certificates更新：" target="_blank" rel="external">http://www.cnblogs.com/sting2me/p/5596222.html上描述的方式，用openssl访问该网站，并将被替换后的证书保存至本地并用update-ca-certificates更新：</a></p>
<p>代码如下(在Ubuntu14.04下测试通过)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo -n | openssl s_client -showcerts -connect dseasb33srnrn.cloudfront.<span class="string">net:</span><span class="number">443</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | sed -ne <span class="string">'/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'</span> &gt; <span class="regexp">/usr/</span>local<span class="regexp">/share/</span>ca-certificates/cloudfront.crt</span><br><span class="line">update-ca-certificates</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>
<p>然后重新执行就会发现成功了，从此以后就可以在上班的时候轻松摸鱼了（误）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;问题描述&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于公司内部证书被IT部门修改，我们在使用docker pull某些镜像的时候会抛出x509错误 x509: certificate signed by unknown authority。&lt;br&gt;例如，我在尝试用docke
    
    </summary>
    
    
      <category term="docker" scheme="http://nnabuuu.github.io/blog-hexo/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Parsing-text-table-with-jison-3</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2016/04/29/Parsing-text-table-with-jison-3/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2016/04/29/Parsing-text-table-with-jison-3/</id>
    <published>2016-04-29T18:58:45.000Z</published>
    <updated>2016-04-29T18:58:46.004Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Parsing-text-table-with-jison-2</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2016/04/28/Parsing-text-table-with-jison-2/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2016/04/28/Parsing-text-table-with-jison-2/</id>
    <published>2016-04-28T07:11:16.000Z</published>
    <updated>2016-04-29T18:43:51.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用jison解析一个文本表格2"><a href="#用jison解析一个文本表格2" class="headerlink" title="用jison解析一个文本表格2"></a>用jison解析一个文本表格2</h1><p>在上一篇文章中，我们完成了一个最初版本的的Parser，它可以用来解析一个基本的表格文本。接下来，我们将以此为基础逐步完善更多内容。</p>
<h3 id="将表格内容存入对象-Store-cells-in-an-object-instead-of-array"><a href="#将表格内容存入对象-Store-cells-in-an-object-instead-of-array" class="headerlink" title="将表格内容存入对象 Store cells in an object instead of array"></a>将表格内容存入对象 Store cells in an object instead of array</h3><p>我们知道在bison中，使用者可以通过yylval保存全局变量。类似的，在jison中，我们可以通过全局变量yy来储存。<br>见<a href="http://zaa.ch/jison/docs/#sharing-scope" target="_blank" rel="external">官网描述：http://zaa.ch/jison/docs/#sharing-scope</a></p>
<p>那么，首先我们好奇的是，这个变量yy到底包含哪些内容。我们在执行时将它输出到控制台一探究竟：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123; lexer:</span><br><span class="line">  &#123;</span><br><span class="line">    yy: [Circular],</span><br><span class="line">    _input: '',</span><br><span class="line">    done: true,</span><br><span class="line">    _backtrack: false,</span><br><span class="line">    _more: false,</span><br><span class="line">    yyleng: 0,</span><br><span class="line">    yylineno: 16,</span><br><span class="line">    match: '',</span><br><span class="line">    matched: '+---------------------------------+---------+----------------+---------------+\r\n|<span class="string"> VM </span>|<span class="string"> State </span>|<span class="string"> VM Type </span>|<span class="string"> IP </span>|<span class="string">\r\n+---------------------------------+---------+----------------+---------------+\r\n</span>|<span class="string"> a/0 </span>|<span class="string"> running </span>|<span class="string"> a </span>|<span class="string"> 192.168.1.159 </span>|<span class="string">\r\n</span>|<span class="string"> b/0 </span>|<span class="string"> running </span>|<span class="string"> b </span>|<span class="string"> 192.168.1.161 </span>|<span class="string">\r\n</span>|<span class="string"> b/1 </span>|<span class="string"> running </span>|<span class="string"> b </span>|<span class="string"> 192.168.1.162 </span>|<span class="string">\r\n</span>|<span class="string"> b/2 </span>|<span class="string"> running </span>|<span class="string"> b </span>|<span class="string"> 192.168.1.163 </span>|<span class="string">\r\n</span>|<span class="string"> eeee/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.164 </span>|<span class="string">\r\n</span>|<span class="string"> haaaaaaa/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.168 </span>|<span class="string">\r\n</span>|<span class="string"> c/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.166 </span>|<span class="string">\r\n</span>|<span class="string"> lllllllllloooooooooolllllller/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.167 </span>|<span class="string">\r\n</span>|<span class="string"> n1/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.156 </span>|<span class="string">\r\n</span>|<span class="string"> n2/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.157 </span>|<span class="string">\r\n</span>|<span class="string"> n3/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.158 </span>|<span class="string">\r\n</span>|<span class="string"> n4/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.165 </span>|<span class="string">\r\n</span>|<span class="string"> u1/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.160 </span>|<span class="string">\r\n+---------------------------------+---------+----------------+---------------+',</span><br><span class="line">    yytext: '',</span><br><span class="line">    conditionStack: [ 'INITIAL' ],</span><br><span class="line">    yylloc:</span><br><span class="line">    &#123;</span><br><span class="line">      first_line: 17,</span><br><span class="line">      last_line: 17,</span><br><span class="line">      first_column: 78,</span><br><span class="line">      last_column: 78 &#125;,</span><br><span class="line">    offset: 0,</span><br><span class="line">    matches: [ '', index: 0, input: '' ] &#125;,</span><br><span class="line">    parser: &#123; yy: &#123;&#125;, parseError: [Function: parseError] &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>我们看到，yy中储存了多个运行时用到的变量。我们很容易在里面找到bison中其他变量的对应，例如yytext和yyleng。<br>这些变量在语法解析的过程中均可以被访问到，因此，我们大胆猜想一下，如果我们想要保存/使用自己的变量，或许可以直接通过yy.myVarible进行访问。<br>我们修改jison文件如下（仅标出修改部分），并保存为table-v2.jison：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">%lex</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">yy.convert = function(obj, header)&#123;</span><br><span class="line">  <span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;obj._content.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    obj[header[i]]=obj._content[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> obj._content;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">headerline</span><br><span class="line">  : line</span><br><span class="line">    &#123;</span><br><span class="line">      yy.header = [];</span><br><span class="line">      <span class="keyword">for</span>(var i=<span class="number">0</span>;i&lt;$1._content.length;i++)&#123;</span><br><span class="line">        yy.header.push($1._content[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      $$ = $1;</span><br><span class="line">    &#125;</span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">content</span><br><span class="line">  : line</span><br><span class="line">    &#123;</span><br><span class="line">      $$ = &#123;_content: []&#125;;</span><br><span class="line">      $$._content.push(yy.convert($1,yy.header));</span><br><span class="line">    &#125;</span><br><span class="line">  | content line</span><br><span class="line">    &#123;</span><br><span class="line">      $1._content.push(yy.convert($2,yy.header));</span><br><span class="line">      $$ = $1;</span><br><span class="line">    &#125;</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>再运行下面的代码看看：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jison <span class="keyword">table</span>-v2.jison</span><br><span class="line">node <span class="keyword">table</span>-v2.js <span class="comment">sample.txt</span></span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attribute">_content</span>:</span><br><span class="line">  [ &#123; VM: <span class="string">'a/0'</span>,</span><br><span class="line">  State: <span class="string">'running'</span>,</span><br><span class="line">  <span class="string">'VM Type'</span>: <span class="string">'a'</span>,</span><br><span class="line">  IP: <span class="string">'192.168.1.159'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'b/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'b'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.161'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'b/1'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'b'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.162'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'b/2'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'b'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.163'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'eeee/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'iiiiiiiiiiiiii'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.164'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'haaaaaaa/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'iiiiiiiiiiiiii'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.168'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'c/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'iiiiiiiiiiiiii'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.166'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'lllllllllloooooooooolllllller/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'iiiiiiiiiiiiii'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.167'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'n1/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'iiiiiiiiiiiiii'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.156'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'n2/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'iiiiiiiiiiiiii'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.157'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'n3/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'iiiiiiiiiiiiii'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.158'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'n4/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'iiiiiiiiiiiiii'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.165'</span> &#125;,</span><br><span class="line">    &#123; <span class="attribute">VM</span>: <span class="string">'u1/0'</span>,</span><br><span class="line">    State: <span class="string">'running'</span>,</span><br><span class="line">    <span class="string">'VM Type'</span>: <span class="string">'iiiiiiiiiiiiii'</span>,</span><br><span class="line">    IP: <span class="string">'192.168.1.160'</span> &#125; ] &#125;</span><br></pre></td></tr></table></figure>
<p>干的不错，我们成功的将表格内容存入了对应的对象中，收工！</p>
<h3 id="一些jison的坑"><a href="#一些jison的坑" class="headerlink" title="一些jison的坑"></a>一些jison的坑</h3><p>从上面的代码中可以看到，我在预编译阶段声明并定义了yy.convert函数。我们可以在语法分析阶段直接使用该函数。<br>但是，如果我们在预编译阶段声明我们要用到的变量例如<code>yy.header = [];</code>，则会出现严重问题。Jison在每一个语法匹配完成之后将重置yy.header为最初声明的空的Array。导致在匹配<code>content</code>语法时无法拿到正确的yy.header。<br>因此，我将yy.header的初始化放到了headerline的处理逻辑中，以此绕过这个坑。<br>我已经在github题了一个<a href="https://github.com/zaach/jison/issues/327" target="_blank" rel="external">issue</a>，暂时没有人回复。。。</p>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>我想到可以继续扩展的功能点包括：</p>
<ol>
<li>多行Header</li>
<li>表格中有空的Cell</li>
</ol>
<p>这些会在接下来的文章中一一补充。</p>
<p>众人：才刚刚填了一个坑立马又挖了两个，眼看着就要烂尾了。。<br>abuuu：就算烂尾我也要挖-。-！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用jison解析一个文本表格2&quot;&gt;&lt;a href=&quot;#用jison解析一个文本表格2&quot; class=&quot;headerlink&quot; title=&quot;用jison解析一个文本表格2&quot;&gt;&lt;/a&gt;用jison解析一个文本表格2&lt;/h1&gt;&lt;p&gt;在上一篇文章中，我们完成了一个最初版
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://nnabuuu.github.io/blog-hexo/tags/NodeJS/"/>
    
      <category term="jison" scheme="http://nnabuuu.github.io/blog-hexo/tags/jison/"/>
    
  </entry>
  
  <entry>
    <title>Parsing-text-table-with-jison</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2016/04/21/Parsing-text-table-with-jison/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2016/04/21/Parsing-text-table-with-jison/</id>
    <published>2016-04-21T23:02:41.000Z</published>
    <updated>2016-04-29T18:43:51.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用jison解析一个文本表格"><a href="#用jison解析一个文本表格" class="headerlink" title="用jison解析一个文本表格"></a>用jison解析一个文本表格</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文受到文章<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=210542047&amp;idx=1&amp;sn=9c813595c727c0fa028651b9dcdbab12" target="_blank" rel="external">如何愉快地写个小parser</a>的启发，尝试用文中所介绍的Jison来进行文本解析处理。</p>
<h3 id="什么是Jison"><a href="#什么是Jison" class="headerlink" title="什么是Jison"></a>什么是Jison</h3><p>Jison的<a href="http://zaa.ch/jison/about/" target="_blank" rel="external">官网介绍</a>是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parsers <span class="keyword">help</span> computers derive meaning <span class="keyword">from</span> arbitrary text. <span class="keyword">And</span> Jison helps you <span class="keyword">build</span> parsers!</span><br><span class="line"></span><br><span class="line">Jison <span class="keyword">is</span> essentially a <span class="keyword">clone</span> <span class="keyword">of</span> the parser generator Bison (thus Yacc,) but <span class="keyword">in</span> JavaScript. It includes its own lexical analyzer modeled <span class="keyword">after</span> Flex.</span><br></pre></td></tr></table></figure>
<p>Jison是一个”Bison in JavaScript”。也就是说，首先Jison是一个类似Bison的parser生成器。区别在于，Jison使用JavaScript编写，可以同时用于NodeJS和浏览器执行环境中。</p>
<p>Jison的安装请参照<a href="http://zaa.ch/jison/docs/，在NodeJS的开发环境中使用`npm" target="_blank" rel="external">http://zaa.ch/jison/docs/，在NodeJS的开发环境中使用`npm</a> install jison -g`即可完成安装。</p>
<h3 id="使用Jison"><a href="#使用Jison" class="headerlink" title="使用Jison"></a>使用Jison</h3><p>这里我们用一个简单的例子来介绍如何使用Jison。</p>
<p>最近的工作都在使用CloudFoundry，在使用BOSH的时候经常需要通过<code>bosh vms</code>去抓ip地址。这个命令会返回一个类似于下面格式的表格：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------+---------+----------------+---------------+</span><br><span class="line">|<span class="string"> VM                              </span>|<span class="string"> State   </span>|<span class="string"> VM Type        </span>|<span class="string"> IP            </span>|</span><br><span class="line">+---------------------------------+---------+----------------+---------------+</span><br><span class="line">|<span class="string"> a/0                             </span>|<span class="string"> running </span>|<span class="string"> a              </span>|<span class="string"> 192.168.1.159 </span>|</span><br><span class="line">|<span class="string"> b/0                             </span>|<span class="string"> running </span>|<span class="string"> b              </span>|<span class="string"> 192.168.1.161 </span>|</span><br><span class="line">|<span class="string"> b/1                             </span>|<span class="string"> running </span>|<span class="string"> b              </span>|<span class="string"> 192.168.1.162 </span>|</span><br><span class="line">|<span class="string"> b/2                             </span>|<span class="string"> running </span>|<span class="string"> b              </span>|<span class="string"> 192.168.1.163 </span>|</span><br><span class="line">|<span class="string"> eeee/0                          </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.164 </span>|</span><br><span class="line">|<span class="string"> haaaaaaa/0                      </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.168 </span>|</span><br><span class="line">|<span class="string"> c/0                             </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.166 </span>|</span><br><span class="line">|<span class="string"> lllllllllloooooooooolllllller/0 </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.167 </span>|</span><br><span class="line">|<span class="string"> n1/0                            </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.156 </span>|</span><br><span class="line">|<span class="string"> n2/0                            </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.157 </span>|</span><br><span class="line">|<span class="string"> n3/0                            </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.158 </span>|</span><br><span class="line">|<span class="string"> n4/0                            </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.165 </span>|</span><br><span class="line">|<span class="string"> u1/0                            </span>|<span class="string"> running </span>|<span class="string"> iiiiiiiiiiiiii </span>|<span class="string"> 192.168.1.160 </span>|</span><br><span class="line">+---------------------------------+---------+----------------+---------------+</span><br></pre></td></tr></table></figure>
<p>对于这样一个格式规整的多行文本，如果用正则表达式去匹配整个表格并提取所有的内容，写出的代码可维护性会比较差。我们下面思考一下如何使用Jison来创建一个parser解析这个表格。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先做词法分析，</p>
<p><img src="https://raw.githubusercontent.com/nnabuuu/blog-hexo/gh-pages/img/Parsing-text-table-with-jison/LexicalAnalysis.png" alt=""></p>
<p>通过如下的正则表达式来描述所有的词法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\s+                                 <span class="comment">/* skip whitespace */</span></span><br><span class="line">&lt;&lt;EOF&gt;&gt;               <span class="keyword">return</span> <span class="string">'EOF'</span>  <span class="comment">/* End of file*/</span></span><br><span class="line"><span class="string">"+"</span>                   <span class="keyword">return</span> <span class="string">'HEAD'</span> <span class="comment">/* Header of the separate line */</span></span><br><span class="line">(<span class="string">"-"</span>)+<span class="string">"+"</span>             <span class="keyword">return</span> <span class="string">'TAIL'</span> <span class="comment">/* Tail of the separate line */</span></span><br><span class="line">[^+|-]*[^\s+|-]		    <span class="keyword">return</span> <span class="string">'CELL'</span> <span class="comment">/* Content in the cell, this is what we want */</span></span><br><span class="line"><span class="string">"|"</span>                   <span class="keyword">return</span> <span class="string">'|'</span>    <span class="comment">/* Vertical bar of the cell */</span></span><br></pre></td></tr></table></figure></p>
<p>然后是语法分析，如下：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">%start <span class="keyword">table</span></span><br><span class="line"></span><br><span class="line">%% <span class="comment">/* language grammar */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">table</span></span><br><span class="line">    : separateline headerline separateline content separateline EOF</span><br><span class="line">        &#123;</span><br><span class="line">          console.log(&#123;header: $<span class="number">2</span>, body: $<span class="number">4</span>&#125;); <span class="comment">// Print out for debug</span></span><br><span class="line">          return &#123;header: <span class="symbol">$</span><span class="number">2</span>, body: <span class="symbol">$</span><span class="number">4</span>&#125;;       <span class="comment">// Separate lines are ignored</span></span><br><span class="line">        &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">separateline</span><br><span class="line">    : HEAD</span><br><span class="line">        &#123;<span class="symbol">$</span><span class="symbol">$</span> = <span class="symbol">$</span><span class="number">1</span>;&#125;</span><br><span class="line">    | separateline TAIL</span><br><span class="line">        &#123;<span class="symbol">$</span><span class="symbol">$</span> = <span class="symbol">$</span><span class="number">1</span> + <span class="symbol">$</span><span class="number">2</span>;&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">headerline</span><br><span class="line">    : line</span><br><span class="line">		    &#123;<span class="symbol">$</span><span class="symbol">$</span> = <span class="symbol">$</span><span class="number">1</span>&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">content</span><br><span class="line">    :  line</span><br><span class="line">       &#123;<span class="symbol">$</span><span class="symbol">$</span> = &#123;content: []&#125;;<span class="symbol">$</span><span class="symbol">$</span>.content.push(<span class="symbol">$</span><span class="number">1</span>);&#125;</span><br><span class="line">    |  content + line</span><br><span class="line">       &#123;<span class="symbol">$</span><span class="number">1.</span>content.push(<span class="symbol">$</span><span class="number">2</span>); <span class="symbol">$</span><span class="symbol">$</span> = <span class="symbol">$</span><span class="number">1</span>;&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">line</span><br><span class="line">    : <span class="string">'|'</span></span><br><span class="line">        &#123;<span class="symbol">$</span><span class="symbol">$</span> = &#123;content: []&#125;;&#125;</span><br><span class="line">    |  line CELL <span class="string">'|'</span></span><br><span class="line">        &#123;<span class="symbol">$</span><span class="number">1.</span>content.push(<span class="symbol">$</span><span class="number">2</span>); <span class="symbol">$</span><span class="symbol">$</span> = <span class="symbol">$</span><span class="number">1</span>;&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>最后我们得到了jison文件<a href="https://gist.github.com/nnabuuu/e35074b7b34b2324aa478de74e097203" target="_blank" rel="external">table-v1.jison</a></p>
<h3 id="生成parser"><a href="#生成parser" class="headerlink" title="生成parser"></a>生成parser</h3><p>我们使用jison命令生成对应的parser：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jison <span class="keyword">table</span>-v1.jison</span><br></pre></td></tr></table></figure></p>
<p>执行之后，我们会得到名为table-v1.js的parser文件，该文件可以直接使用进行parse。我们首先将表格文本保存为sample.txt。然后执行命令：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">table-v1</span>.js sample.txt</span><br></pre></td></tr></table></figure>
<p>输出如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123; header: &#123; content: [ <span class="string">'VM'</span>, <span class="string">'State'</span>, <span class="string">'VM Type'</span>, <span class="string">'IP'</span> ] &#125;,</span><br><span class="line">  body:</span><br><span class="line">   &#123; content:</span><br><span class="line">      [ [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>],</span><br><span class="line">        [<span class="symbol">Object</span>] ] &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，即完成了一个简单的解析。</p>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>当然，仅仅解析成这样是不够的，我们希望最后能够得到一个这样的“开箱即用”的结果格式：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;     [ &#123;<span class="string">'VM'</span>: <span class="string">'a/0'</span>, <span class="string">'State'</span>: <span class="string">'running'</span>, <span class="string">'VM Type'</span>: <span class="string">'a'</span>, <span class="string">'IP'</span>: <span class="string">'192.168.1.159'</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'VM'</span>: <span class="string">'b/0'</span>, <span class="string">'State'</span>: <span class="string">'running'</span>, <span class="string">'VM Type'</span>: <span class="string">'b'</span>, <span class="string">'IP'</span>: <span class="string">'192.168.1.161'</span>&#125;,</span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们要怎么做呢？</p>
<p>且听下回分解。</p>
<p>另：<br>后面会完成的内容：<br>table-v1.jison重构为table-v2.jison<br>通过NodeJS封装parser调用<br>NodeJS与BOSH的集成<br>将parser服务化，对外提供service</p>
<p>众人：abuuu同学你列了这么多后面烂尾了怎么办<br>abuuu：那就删掉啊，不然要怎样（手动白眼）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;用jison解析一个文本表格&quot;&gt;&lt;a href=&quot;#用jison解析一个文本表格&quot; class=&quot;headerlink&quot; title=&quot;用jison解析一个文本表格&quot;&gt;&lt;/a&gt;用jison解析一个文本表格&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://nnabuuu.github.io/blog-hexo/tags/NodeJS/"/>
    
      <category term="jison" scheme="http://nnabuuu.github.io/blog-hexo/tags/jison/"/>
    
  </entry>
  
  <entry>
    <title>Tail Recursion in Haskell</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2015/10/31/Tail-Recursion-in-Haskell/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2015/10/31/Tail-Recursion-in-Haskell/</id>
    <published>2015-11-01T05:30:36.000Z</published>
    <updated>2016-04-29T18:43:51.168Z</updated>
    
    <content type="html"><![CDATA[<p>Today I was solving the problem of “calculate Fibonacci sequence” in Haskell.</p>
<p>The normal fibonacci function is implemented as:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fib</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> n = fib (n - <span class="number">1</span>) + fib (n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>However, this implement runs very slow.</p>
<p>There is one possible way to optimize the code as follow:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fib</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib</span> n = aux n (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">where</span> aux n (a, b) | n == <span class="number">0</span> = a</span><br><span class="line">                          | otherwise = aux (n - <span class="number">1</span>) (b, a + b)</span><br></pre></td></tr></table></figure>
<p>This version is a lot faster than the original version. Why?</p>
<p>The trick is tail recursion.</p>
<p>In previous code, when executing <code>fib n = fib (n - 1) + fib (n - 2)</code>, there is context switch by pushing current context into call stack in order to resume after <code>fib (n - 1)</code> and <code>fib (n - 2)</code> are calculated.</p>
<p>However, by using tail recursion, because our function <code>aux n (a, b)</code> directly return the result from <code>aux (n - 1) (b, a + b)</code>, program can re-use current stack space without change.</p>
<p>This video is a very good explanation:</p>
<p><a href="https://www.youtube.com/watch?v=L1jjXGfxozc" target="_blank" rel="external">https://www.youtube.com/watch?v=L1jjXGfxozc</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Today I was solving the problem of “calculate Fibonacci sequence” in Haskell.&lt;/p&gt;
&lt;p&gt;The normal fibonacci function is implemented as:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Haskell" scheme="http://nnabuuu.github.io/blog-hexo/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Getting Concurrent With ES6 Generators</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2015/01/04/Getting-Concurrent-With-ES6-Generators/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2015/01/04/Getting-Concurrent-With-ES6-Generators/</id>
    <published>2015-01-05T05:44:36.000Z</published>
    <updated>2016-04-29T18:43:51.161Z</updated>
    
    <content type="html"><![CDATA[<p>#用generator实现并发（译）</p>
<p>原文地址：<a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">http://davidwalsh.name/concurrent-generators</a></p>
<p>ES6 Generators：全系列</p>
<ol>
<li><a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">The Basics Of ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">Diving Deeper With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">Getting Concurrent With ES6 Generators</a></li>
</ol>
<p>如果你已经阅读并消化了本系列的第一、第二和第三章节，你应该对ES6 generator已经相当有把握了。希望你真正的被激发来开始用它们做一些事情。</p>
<p>我们要探索的最后的话题是比较前沿的东西，它可能会让你的大脑有点混乱（老实的说，我的大脑仍然处于混乱状态）。所以慢慢的看完并且思考这些概念以及例子。并且还需要读一读其他关于这个话题的文章。</p>
<p>你在这里所做的投入，会从一个长远的角度给你带来回报。我完全确信JS完美的异步能力的未来会来自于这些概念。</p>
<h2 id="标准CSP（Communicating-Sequential-Processes）"><a href="#标准CSP（Communicating-Sequential-Processes）" class="headerlink" title="标准CSP（Communicating Sequential Processes）"></a>标准CSP（Communicating Sequential Processes）</h2><p>受限，我受到这个话题的激发完全是来自于<a href="http://github.com/swannodette" target="_blank" rel="external">David Nolen</a> <a href="http://twitter.com/swannodette" target="_blank" rel="external">@swannodette</a>。严肃的说，他所写得一切文章都值得一读。这里有一些可以让你起步的链接：</p>
<ul>
<li><a href="http://swannodette.github.io/2013/07/12/communicating-sequential-processes/" target="_blank" rel="external">“Communicating Sequential Processes”</a></li>
<li><a href="http://swannodette.github.io/2013/08/24/es6-generators-and-csp/" target="_blank" rel="external">“ES6 Generators Deliver Go Style Concurrency”</a></li>
<li><a href="http://swannodette.github.io/2013/07/31/extracting-processes/" target="_blank" rel="external">“Extracting Processes”</a></li>
</ul>
<p>好的，下面我就来讲一讲我在这个题目上的探索。我并不是从一个正式的Clojure背景转向JS的，我也没有GO或者ClojureScript相关的经验。我很快发现我迷失在这些文章中，并且我必须要做大量的实验和猜测来收集这些文章中有用的部分。</p>
<p>在探索的过程中，我认为我已经学到了一些目标以及精神都想通的东西，但来自于并不是那么古板的思维方式。</p>
<p>我试图要做的是简历一个简单的Go-风格的CSP（已经ClojureScript core.async）API，同时（我希望）保留大部分潜在的能力。当然，那些比我聪明的人完全有可能迅速地看到我目前为止探索过程中错过的部分。如果这牙膏的话，我希望我的探索能够继续进行下去，并且我会继续和我们分享我的启示！</p>
<h2 id="（部分）分解CSP理论"><a href="#（部分）分解CSP理论" class="headerlink" title="（部分）分解CSP理论"></a>（部分）分解CSP理论</h2><p>CSP是讲些什么的？它提到的“communicating”、“Sequential”是什么？“Processes”又是什么？</p>
<p>首先，CSP来自于<a href="http://www.usingcsp.com/" target="_blank" rel="external">Tony Hoare的书”Communicating Sequential Processes”</a>。这是一些厚重的CS理论的东西，但如果你有兴趣在学术范围有所建树的话，那么这是最好的开始的地方。当然我并不是要用一种深奥的、令人头痛的、CS的方式来讲述它。我会用一种非正式的方式来描述。</p>
<p>所以，我们先从“sequential”这个词开始。这个部分你应该已经非常熟悉了。它所谈论的是另一种单线程行为以及我们用ES6 generators实现的同步风格代码的方式。</p>
<p>回忆一下，generator是的语法是像这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一条语句都是有序的（按照顺序）执行，每次执行一条。<code>yield</code>关键词表明代码中有可能发生堵塞暂停（只堵塞当前generator自己代码，并不堵塞外部程序！）的地方，但是这并不改变<code>*main()</code>内部自上而下的代码处理顺序。很简单，是吧？</p>
<p>下面，让我们谈谈“processes”，这又是关于些什么的呢？</p>
<p>从本质上来说，一个generator就像是一个虚拟“进程”。它是一块自我包含的程序，它可以，如果JS允许这样做的话，完全和程序剩余部分并发执行。</p>
<p>事实上，这样说有一点点问题。如果generator访问共享内存（也就是说，如果它访问它自身内部本地变量中的“free viriables”），这就不是独立的了。但是让我们先假设一下我们的generator函数并不访问外部变量（因此在函数式编程中我们会把它叫做一个“combinator”）。这样它就可以在理论上以自己单独进程的方式运行。</p>
<p>但是上面我们所说的是“processes” – 复数形式 – 因为有一点很重要的是，同时有两个或多个进程在运行。换句话说，两个或更多的generator进行配对，一般来说是进行协作以便完成更大的任务。</p>
<p>为什么要分离generators而不仅仅用一个呢？最重要的原因是：<strong>内容隔离</strong>。如果你可以将任务XYZ分解为各个子任务X、Y和Z，那么它们的实现代码会更加容易看懂和维护。</p>
<p>当你将一个函数<code>function XYZ()</code>分解为<code>X()</code>，<code>Y()</code>和<code>Z()</code>也是同样的道理，这里<code>X()</code>会调用<code>Y()</code>，<code>Y()</code>会调用<code>Z()</code>。我们将函数分解为单独的子函数来进行更好的代码隔离，使我们的代码更容易维护。</p>
<p><strong>我们可以对多个generator做同样的事情。</strong></p>
<p>最后我们来说一说“communicating”。这又是什么呢？这是从上面两个词推论出来的 – 协作 – 如果generator需要一起工作，它们需要一种通信渠道（不仅仅是访问共享词法作用域中的内容，而是实实在在的能够进行排他性访问的共享通信渠道）。</p>
<p>这个通信渠道是用来发送什么的呢？可以发送无论任何你需要发送的东西（数字、字符串、等等）。事实上，你甚至不需要真正的往通道中发送数据以便使用该通道进行通信。“Communication”可以是简单的协调 – 就像将控制权从一个地方转移到另一个地方。</p>
<p>为什么我们要转移控制权？主要的原因是JS是单线程的，并且在任何时刻它们中只有一个可以处于活动状态。其余的都处在暂停执行的状态，也就意味着它们处在任务的中途阶段，而只是暂停了，它们在等待必要时恢复。</p>
<p>任意独立的“进程”可以神奇的合作和交流，这似乎并不现实。松散耦合的目标是相当令人敬佩的，但它其实不切实际。</p>
<p>相反，似乎所有成功的CSP实现都是一种对某个特定领域内现有已知逻辑集合的因式分解，它的每一个部分都是特地为其他部分的协作而设计的。</p>
<p>或许我完全错了，但是我还没有看到任何方式让两个随机的generator函数可以非常容易的粘在一起变成一个CSP配对。他们都需要被设计成为另一方工作，接受同样的通信协议，等等。</p>
<h2 id="JS中的CSP"><a href="#JS中的CSP" class="headerlink" title="JS中的CSP"></a>JS中的CSP</h2><p>这里有几个已经应用在JS中了的CSP理论。</p>
<p>我们之前提到的Dabid Nolen创建了几个有趣的项目，包括<a href="https://github.com/swannodette/om" target="_blank" rel="external">Om</a>以及<a href="http://www.hakkalabs.co/articles/core-async-a-clojure-library/" target="_blank" rel="external">core.async</a>。<a href="http://koajs.com/" target="_blank" rel="external">Koa</a>库(为node.js创建)有一些非常有趣的实现，主要是通过它的<code>use(..)</code>方法。另一个对core.async/Go CSP API非常“忠诚”的库是<a href="https://github.com/ubolonton/js-csp" target="_blank" rel="external">js-csp</a>。</p>
<p>你应该确切的研究一下这些伟大的项目来看看不同的实现方式以及关于如何探索JS中的CSP的例子。</p>
<h2 id="asynquence的runner-设计CSP"><a href="#asynquence的runner-设计CSP" class="headerlink" title="asynquence的runner(..): 设计CSP"></a>asynquence的<code>runner(..)</code>: 设计CSP</h2><p>由于我一直以来都在积极地探索如何将CSP模式的并发性应用到我自己的JS代码中，因此为我的异步流控制库<a href="http://github.com/getify/asynquence" target="_blank" rel="external">asynquence</a>扩展CSP能力是非常自然的。</p>
<p>我已经有了<code>runner(..)</code>功能插件来处理generator的异步运行（见 <a href="http://davidwalsh.name/async-generators/#rungenerator-library-utility" target="_blank" rel="external">“Part 3: Going Async With Generators”</a>），所以在我看来，它可以很容易地扩展为用<a href="https://github.com/getify/asynquence/tree/master/contrib#csp-style-concurrency" target="_blank" rel="external">类-CSP的方式</a>同时处理多个generator。</p>
<p>我所要解决的第一个问题：你怎么知道下面是哪一个generator要获得控制权？</p>
<p>给每个generator赋予一个ID并让其他generator知晓以便它们将消息或者控制权传递给另一个进程的方式未免太繁琐和笨重了。在经过多次试验之后，我选定了一个简单的round-robin的调度方法。因此如果你将三个generator A、B和C匹配起来之后，A会先获得控制权，然后B在A进行yield时接管，然后C在B进行yield时接管，然后再到达A，以此类推。</p>
<p>但是我们要怎样才能真正的传递控制呢？需要一个明确的API来描述它吗？再一次地，经过多次试验之后，我使用了一个更加隐式的实现方式，它和<a href="http://koajs.com/#cascading" target="_blank" rel="external">Koa的实现方式</a>（碰巧）很相似：每个generator获得一个共享“token”的引用 – `yield它以便传递控制权转移的信号。</p>
<p>另一个问题则是消息通道应该是什么样的。一方面，你有一个非常确定了的API就像core.async以及js-csp中的那些（<code>put(..)</code>以及<code>take(..)</code>）。在我自己的经验中，我则倾向于另一个方面：一个不那么正式的方法（它甚至不是一个API，只是一个共享的数据结构就像<code>array</code>这样），这看起来就够了。</p>
<p>我决定使用一个数组(称为<code>messages</code>)这样你便可以大刀阔斧的决定你要如何来使用它。可以将消息<code>push()</code>进入这个数组，也可以从这个数组中<code>pop()</code>消息，指定数组中会话相关的元素组建不同消息，并可以在这些空间内创建更加复杂的数据结构，等等。</p>
<p>我的设想是有些任务只需要非常简单的消息传递，而另外一些会非常的复杂，因此以其将简单的内容变得复杂，不如将消息通道变得正式而使其成为一个<code>array</code>（这样就不需要除了<code>array</code>自身以外的API了）。将消息传递机制转化为其他形式是非常容易的，你会发现它的妙用（见我们接下来会瘫倒的状态机的例子）。</p>
<p>最后，我留意到这些generator“进程”仍然可以从普通generator的异步能力中获益。换句话说，如果你<code>yield</code>出一个Promise（或asynquence sequence）而不是一个控制token，<code>runner(..)</code>机制将会暂停并等待将来的结果值而不会<strong>移交控制权</strong> – 相反，它会将结果返回给当前的进程（generator）并使它继续享有控制权。</p>
<p>因此最后一点备受争议的应该是（如果我的想法都是正确的话），它和空间内的其它库都不一样。看起来真正的CSP对我这样的实现方式嗤之以鼻。但是我认为我的提议最终会变得非常非常有用。</p>
<h2 id="一个简单的FooBar示例"><a href="#一个简单的FooBar示例" class="headerlink" title="一个简单的FooBar示例"></a>一个简单的FooBar示例</h2><p>好的，我们说够了理论，现在让我们来看看代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: omitting fictional `multBy20(..)` and</span></span><br><span class="line"><span class="comment">// `addTo2(..)` asynchronous-math functions, for brevity</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// grab message off the top of the channel</span></span><br><span class="line">    <span class="keyword">var</span> value = token.messages.pop(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// put another message onto the channel</span></span><br><span class="line">    <span class="comment">// `multBy20(..)` is a promise-generating function</span></span><br><span class="line">    <span class="comment">// that multiplies a value by `20` after some delay</span></span><br><span class="line">    token.messages.push( <span class="keyword">yield</span> multBy20( value ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transfer control</span></span><br><span class="line">    <span class="keyword">yield</span> token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a final message from the CSP run</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"meaning of life: "</span> + token.messages[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// grab message off the top of the channel</span></span><br><span class="line">    <span class="keyword">var</span> value = token.messages.pop(); <span class="comment">// 40</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// put another message onto the channel</span></span><br><span class="line">    <span class="comment">// `addTo2(..)` is a promise-generating function</span></span><br><span class="line">    <span class="comment">// that adds value to `2` after some delay</span></span><br><span class="line">    token.messages.push( <span class="keyword">yield</span> addTo2( value ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transfer control</span></span><br><span class="line">    <span class="keyword">yield</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，现在我们有两个generator“进程”， <code>*foo()</code>和<code>*bar()</code>。你能留意到他们都处理了<code>token</code>对象（当然你也可以给它们任意命名）。<code>token</code>的<code>messages</code>熟悉是我们的共享消息通道。在初始时，它们充满了我们在初始化CSP运行时所产生的消息（见下文）。</p>
<p><code>yield token</code>显示地将控制权传递给“下一个”generator（通过round-robin策略）。然而，<code>yield multiBy20(value)</code>以及<code>yield addTo2(value)</code>都在yield promise（从这些虚构的延迟数学函数中），这表明generator在这一点会暂停知道promise结束。在promise结束时，当前处于控制的generator会获取返回值并继续下去。</p>
<p>无论最后的<code>yield</code>返回值是什么，在本例中是<code>yield &quot;meaning of...</code>表达式，它都是我们的CSP运行完成的消息（见下文）。</p>
<p>现在我们有了两个CSP进程generator，我们要如何执行它们呢？使用asynquence吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start out a sequence with the initial message value of `2`</span></span><br><span class="line">ASQ( <span class="number">2</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">// run the two CSP processes paired together</span></span><br><span class="line">.runner(</span><br><span class="line">    foo,</span><br><span class="line">    bar</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// whatever message we get out, pass it onto the next</span></span><br><span class="line"><span class="comment">// step in our sequence</span></span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( msg ); <span class="comment">// "meaning of life: 42"</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>显然，这只是一个简单的示例。但是我认为它准确的解释了这个概念。</p>
<p>现在或许你该<a href="http://jsbin.com/tunec/2/edit?js,console" target="_blank" rel="external">自己试一试</a>了（试着将返回值进行链式处理！）来确保你已经理解了这些概念并且能够编写你自己的代码了！</p>
<h2 id="另一个玩具Demo的例子"><a href="#另一个玩具Demo的例子" class="headerlink" title="另一个玩具Demo的例子"></a>另一个玩具Demo的例子</h2><p>让我们用一个经典的CSP例子来试一试，但是让我们从我所观测到的简单部分开始，而不是像通常人们做的那样从一个学术的角度开始。</p>
<p><strong>Ping-pong</strong>。很有趣的运动是吧？这是我最喜欢的运动。</p>
<p>让我们设想一下你已经实现了进行一次乒乓球比赛的代码。你用一个循环来运行，然后你有两块代码（例如，用一个<code>if</code>或者<code>switch</code>实现的分支）每一块代表者一名选手。</p>
<p>你的代码运行得很好，你的游戏就看起来像是一个真正的乒乓球比赛一样！</p>
<p>但是我们之前看到的是CSP在什么方面非常有用？<strong>逻辑隔离</strong>。我们在乒乓球运动中要隔离的逻辑是？这两名选手！</p>
<p>因此，我们可以，站在一个非常高的角度，来给两个“进程”（generators）建模，每一个代表一名选手。随着我们的深入，我们会发现这些用来在两名选手之间传递控制权的“胶水代码”其自身是一个task，并且它的代码可以被放到第三个generator中，这里我们可以将其建模为一个裁判。</p>
<p>我们会过滤掉所有的领域相关问题，例如得分、赛制、物理学、策略、AI、控制、等等。我们唯一关心的只是模拟来回击球（这也就是我们的CSP控制权转移的描述）。</p>
<p>想看看Demo吗？<a href="http://jsbin.com/qutabu/1/edit?js,output" target="_blank" rel="external">点击这里运行</a>（注：你需要使用最新版本的FF或者Chrome，它们支持ES6 JavaScript，来看到generator是如何运作的）。</p>
<p>好，下面我们逐条讲解我们的代码。</p>
<p>受限，asynquence sequence看起来长什么样呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ASQ(</span><br><span class="line">    [<span class="string">"ping"</span>,<span class="string">"pong"</span>], <span class="comment">// player names</span></span><br><span class="line">    &#123; hits: <span class="number">0</span> &#125; <span class="comment">// the ball</span></span><br><span class="line">)</span><br><span class="line">.runner(</span><br><span class="line">    referee,</span><br><span class="line">    player,</span><br><span class="line">    player</span><br><span class="line">)</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    message( <span class="string">"referee"</span>, msg );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>我们将序列初始化为两条消息：<code>[&quot;ping&quot;, &quot;pong&quot;]</code>和<code>{hits: 0}</code>。我们马上就会用到它们。</p>
<p>然后，我们设置CSP运行3个进程（通过轮询的方式）：一个<code>*referee()</code>和两个<code>*player()</code>实例。</p>
<p>比赛最后的消息在我们的序列中不停传输，并最后作为裁判的消息被打印出来。</p>
<p>裁判的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">referee</span>(<span class="params">table</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alarm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// referee sets an alarm timer for the game on</span></span><br><span class="line">    <span class="comment">// his stopwatch (10 seconds)</span></span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alarm = <span class="literal">true</span>; &#125;, <span class="number">10000</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep the game going until the stopwatch</span></span><br><span class="line">    <span class="comment">// alarm sounds</span></span><br><span class="line">    <span class="keyword">while</span> (!alarm) &#123;</span><br><span class="line">        <span class="comment">// let the players keep playing</span></span><br><span class="line">        <span class="keyword">yield</span> table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal to players that the game is over</span></span><br><span class="line">    table.messages[<span class="number">2</span>] = <span class="string">"CLOSED"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// what does the referee say?</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"Time's up!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我把控制token称为<code>table</code>以便和问题的domain（乒乓球）相匹配。语义上让一个选手击球时”yield the table”给另一个选手相当恰当，不是吗？</p>
<p><code>while</code>循环<code>*referee()</code>只是不停的yield <code>table</code>回给选手只要它的手表还没有计时结束。当结束时，它会宣布<code>&quot;Time&#39;s up!&quot;</code></p>
<p>现在，让我们来看看<code>*player()</code> generator（我们使用了两个实例）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">player</span>(<span class="params">table</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = table.messages[<span class="number">0</span>].shift();</span><br><span class="line">    <span class="keyword">var</span> ball = table.messages[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (table.messages[<span class="number">2</span>] !== <span class="string">"CLOSED"</span>) &#123;</span><br><span class="line">        <span class="comment">// hit the ball</span></span><br><span class="line">        ball.hits++;</span><br><span class="line">        message( name, ball.hits );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// artificial delay as ball goes back to other player</span></span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">500</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// game still going?</span></span><br><span class="line">        <span class="keyword">if</span> (table.messages[<span class="number">2</span>] !== <span class="string">"CLOSED"</span>) &#123;</span><br><span class="line">            <span class="comment">// ball's now back in other player's court</span></span><br><span class="line">            <span class="keyword">yield</span> table;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message( name, <span class="string">"Game over!"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个选手从数组中获取他自己的名字（<code>&quot;ping&quot;</code>），然后第二个选手获取他的名字（<code>“pong”</code>），因此他们可以同时辨别双方。双方都保留一个对共享<code>ball</code>对象的引用（包含了<code>hits</code>计数器）。</p>
<p>当选手还未听到裁判结束的消息时，他们通过将计数器<code>hits</code>增加1的方式”击打”<code>ball</code>（并且输出一条消息进行公告），然后他们等待500毫秒（只是来模拟一下球速并没有达到光速啦！）</p>
<p>如果比赛仍在继续，他们会”yield table”回到另一名选手中。</p>
<p>就是这样啦！</p>
<p><a href="http://jsbin.com/qutabu/1/edit?js,output" target="_blank" rel="external">看看这里的Demo代码</a>，通过将所有的代码放在一起看看它们是如何共同工作的。</p>
<h2 id="状态机：Generator协作"><a href="#状态机：Generator协作" class="headerlink" title="状态机：Generator协作"></a>状态机：Generator协作</h2><p>我们最后一个例子：定义一个<a href="http://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="external">状态机</a>作为一系列generator的协同程序，它们有一个简单的helper驱动。</p>
<p><a href="http://jsbin.com/luron/1/edit?js,console" target="_blank" rel="external">Demo</a>（用最新的FF或者Chrome打开）</p>
<p>首先，让我们顶一个一个help函数来控制我们的有限状态句柄：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">state</span>(<span class="params">val,handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// make a coroutine handler (wrapper) for this state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>*(<span class="params">token</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// state transition handler</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">transition</span>(<span class="params">to</span>) </span>&#123;</span><br><span class="line">            token.messages[<span class="number">0</span>] = to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// default initial state (if none set yet)</span></span><br><span class="line">        <span class="keyword">if</span> (token.messages.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            token.messages[<span class="number">0</span>] = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keep going until final state (false) is reached</span></span><br><span class="line">        <span class="keyword">while</span> (token.messages[<span class="number">0</span>] !== <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// current state matches this handler?</span></span><br><span class="line">            <span class="keyword">if</span> (token.messages[<span class="number">0</span>] === val) &#123;</span><br><span class="line">                <span class="comment">// delegate to state handler</span></span><br><span class="line">                <span class="keyword">yield</span> *handler( transition );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// transfer control to another state handler?</span></span><br><span class="line">            <span class="keyword">if</span> (token.messages[<span class="number">0</span>] !== <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">yield</span> token;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该<code>state(..)</code> helper工具方法创建了一个为一个具体的状态值准备的<a href="http://davidwalsh.name/es6-generators-dive#delegating-generators" target="_blank" rel="external">delegating-generator</a>包装器，它会自动的运行状态机，并且将控制权在每个状态间进行传递。</p>
<p>出于惯例，我决定共享<code>token.messages[0]</code>位置来保存当前状态机的状态。这表明你可以从之前的步骤中传递一条消息作为初始状态。但是如果没有这样的初始消息被传递的话，我们会简单的将第一个状态定义为我们的初始状态。同样出于惯例，最终状态被断言为<code>false</code>。这很容易实现：</p>
<p>状态值可以是任何种类的值：<code>number</code>s, <code>string</code>s，等等。只要这个值能被<code>===</code>处理，你就可以使用它来做你的状态。</p>
<p>在下面这个例子中，我展示了一个状态机从4个<code>number</code>形式的状态值之间进行转化，采用这种顺序<code>1 -&gt; 4 -&gt; 3 -&gt; 2</code>。为了demo的目的，它也会进行计数以便进行不止一次的转换。当我们的generator状态机最终到达终止位（<code>false</code>）时，<em>asynquence</em>序列会移动到下一个步骤，如你所期待的那样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter (for demo purposes only)</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ASQ( <span class="comment">/* optional: initial state value */</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">// run our state machine, transitions: 1 -&gt; 4 -&gt; 3 -&gt; 2</span></span><br><span class="line">.runner(</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state `1` handler</span></span><br><span class="line">    state( <span class="number">1</span>, <span class="function"><span class="keyword">function</span>*(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"in state 1"</span> );</span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">1000</span> ); <span class="comment">// pause state for 1s</span></span><br><span class="line">        <span class="keyword">yield</span> transition( <span class="number">4</span> ); <span class="comment">// goto state `4`</span></span><br><span class="line">    &#125; ),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state `2` handler</span></span><br><span class="line">    state( <span class="number">2</span>, <span class="function"><span class="keyword">function</span>*(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"in state 2"</span> );</span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">1000</span> ); <span class="comment">// pause state for 1s</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for demo purposes only, keep going in a</span></span><br><span class="line">        <span class="comment">// state loop?</span></span><br><span class="line">        <span class="keyword">if</span> (++counter &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> transition( <span class="number">1</span> ); <span class="comment">// goto state `1`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// all done!</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">"That's all folks!"</span>;</span><br><span class="line">            <span class="keyword">yield</span> transition( <span class="literal">false</span> ); <span class="comment">// goto terminal state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state `3` handler</span></span><br><span class="line">    state( <span class="number">3</span>, <span class="function"><span class="keyword">function</span>*(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"in state 3"</span> );</span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">1000</span> ); <span class="comment">// pause state for 1s</span></span><br><span class="line">        <span class="keyword">yield</span> transition( <span class="number">2</span> ); <span class="comment">// goto state `2`</span></span><br><span class="line">    &#125; ),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state `4` handler</span></span><br><span class="line">    state( <span class="number">4</span>, <span class="function"><span class="keyword">function</span>*(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"in state 4"</span> );</span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">1000</span> ); <span class="comment">// pause state for 1s</span></span><br><span class="line">        <span class="keyword">yield</span> transition( <span class="number">3</span> ); <span class="comment">// goto state `3`</span></span><br><span class="line">    &#125; )</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// state machine complete, so move on</span></span><br><span class="line">.val(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>应该很容易看出这里将发生什么。</p>
<p><code>yield ASQ.after(1000)</code>表明这些generator可以做任何基于异步流的promise/sequence操作，就像我们之前看到的那样。<code>yield transition(..)</code>是我们如何转移到一个新的状态上。</p>
<p>我们前面的<code>state(..)</code> helper实际上做了处理<code>yield*</code><a href="http://davidwalsh.name/es6-generators-dive#delegating-generators" target="_blank" rel="external">代理</a>以及状态转换的复杂工作，是的我们的状态句柄可以以一种非常简单和自然的格式进行编写。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSP的关键在于将两个或多个generator“进程”结合在一起，给予他们一个共享的通信渠道，以及一个它们之前传递控制权的方法。</p>
<p>JS中非常多的库都或多或少的有一些正式的实现，它们基本符合Go/Clojure/ClojureScript的API和语法。所有这些库的背后都有一些非常聪明的开发者，并且他们对于今后的研究都是一笔巨大的财富。</p>
<p><a href="http://github.com/getify/asynquence" target="_blank" rel="external">asynquence</a>尝试了一种非正式的实现方式但仍然希望它能满足这个机制。如果没有别的，asynquence的<code>runner(..)</code>使上手使用CSP风格的generator非常简单，你可以进行尝试并且学习。</p>
<p>然而最好的部分仍然是asynquence CSP可以和其他异步功能（promise、generators、控制流等等）无缝结合，你可以使用你所拥有的任何工具，都在这样一个小小的库里。</p>
<p>在过去的4篇文章中我们已经讨论了相当多的关于generator的细节。我希望你对此感到兴奋并受到启发去探索如何改变你自己的JS代码！你会用generator来做些什么呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#用generator实现并发（译）&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://davidwalsh.name/concurrent-generators&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://davidwalsh.na
    
    </summary>
    
    
      <category term="generator translation" scheme="http://nnabuuu.github.io/blog-hexo/tags/generator-translation/"/>
    
  </entry>
  
  <entry>
    <title>Going Async With ES6 Generators</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/12/26/Going-Async-With-ES6-Generators/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/12/26/Going-Async-With-ES6-Generators/</id>
    <published>2014-12-27T05:01:21.000Z</published>
    <updated>2016-04-29T18:43:51.163Z</updated>
    
    <content type="html"><![CDATA[<p>#用Generator进行异步编程（译）</p>
<p>原文地址：<a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">http://davidwalsh.name/async-generators</a></p>
<p>ES6 Generators：全系列</p>
<ol>
<li><a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">The Basics Of ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">Diving Deeper With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">Getting Concurrent With ES6 Generators</a></li>
</ol>
<p>现在你已经<a href="http://davidwalsh.name/es6-generators/" target="_blank" rel="external">见识过了ES6 generator</a>并且已经对它已经<a href="http://davidwalsh.name/es6-generators-dive/" target="_blank" rel="external">有所熟悉</a>了，现在是时候开始使用它们来增强我们真实的代码了。</p>
<p>Generator的主要唱出在于它们提供了一个单线程的，同步样式的代码风格，<strong>同时允许你把异步隐藏为实现细节</strong>。这使得我们用一种非常自然的方式表达，专注于我们程序的步骤/声明的流程，而不必同时不得不遵循异步语法并避免陷阱。</p>
<p>换句话说，我们通过隔离对值的消费（我们的generator逻辑）与异步得到这些值的细节（generator迭代器中的<code>next(..)</code>），实现了<strong>能力与缺点的完美分离</strong>。</p>
<p>结果呢？我们获得了异步代码的强大能力，同时也获得了（看上去是）同步代码的可读性以及可维护性。</p>
<p>那么我们如何实现这个非凡的能力呢？</p>
<h2 id="最简单的异步"><a href="#最简单的异步" class="headerlink" title="最简单的异步"></a>最简单的异步</h2><p>在最简单的场景下，generator不需要任何额外的操作来实现你的程序中并没有的异步操作。</p>
<p>例如，让我们设想你已经有了这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do some ajax fun</span></span><br><span class="line">    <span class="comment">// call `cb(result)` when complete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeAjaxCall( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    makeAjaxCall( <span class="string">"http://some.url.2/?id="</span> + data.id, <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>要使用一个generator来表现同样的程序，你需要这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this is where we're hiding the asynchronicity,</span></span><br><span class="line">    <span class="comment">// away from the main code of our generator</span></span><br><span class="line">    <span class="comment">// `it.next(..)` is the generator's iterator-resume</span></span><br><span class="line">    <span class="comment">// call</span></span><br><span class="line">    makeAjaxCall( url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">        it.next( response );</span><br><span class="line">    &#125; );</span><br><span class="line">    <span class="comment">// Note: nothing returned here!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next(); <span class="comment">// get it all started</span></span><br></pre></td></tr></table></figure>
<p>让我们来解释一下它是如何工作的：</p>
<p><code>request(..)</code>功能函数基本上包装我们普通的<code>makeAjaxCall(..)</code>功能类以保证它的回调函数能调用generator iterator的<code>next(..)</code>方法。</p>
<p>对于<code>request(&quot;..&quot;)</code>调用，你会注意到它<em>没有返回值</em>（换句话说，它是<code>undefined</code>）。这不是什么大问题，但是它和我们在本文之后的实现方式有所不同：我们在这里实际上是调用了<code>yield undefined</code>。</p>
<p>因此我们调用<code>yield ..</code>（和这个<code>undefined</code>值），它实际上什么也没做，它只是在这一点上暂停了我们的generator。它将会等待直到<code>it.next(..)</code>被调用来恢复它，这个调用我们已经排列在队列中（作为回调函数），在Ajax调用结束后发生。</p>
<p>但是<code>yield ..</code>表达式的<em>结果</em>又发生了什么？我们将它赋值到变量<code>result1</code>上。它是如何得到第一个Ajax调用的内部的值的呢？</p>
<p>因为当<code>it.next(..)</code>被作为Ajax回调函数调用时，它实际是在给它传递Ajax的响应结果，这表明值在那个当前暂停的时间点被发送回我们的generator内部，也就是<code>result1 = yield ..</code>表达式的中间！</p>
<p>这的确非常的酷并且超级强大。本质上，<code>result1 = yield reequest(..)</code>是在<strong>请求这个值</strong>，但是它（几乎！）完全对我们隐藏了 – 至少我们不需要在这里担心它 – 外表之下的实际实现是异步的。它通过<em>隐藏</em><code>yield</code>中的暂停能力实现了异步，并且分离出generator的<em>恢复</em>能力到另外一个函数中，因此我们的main代码只需要进行一个<strong>（看起来是）同步的值的请求</strong>。</p>
<p>对于第二个<code>result2 = yield result(..)</code>表达式也是一样：它对于暂停和恢复是透明的，并且提供了我们所需求的值，所有这些都没有让任何异步细节打扰到我们我代码。</p>
<p>当然<code>yield</code>出现了，因此那里的确有一个细微的提示“一些神奇的东西（异步）<em>可能发生</em>在那个时间点”。但是<code>yield</code>比起回调地狱（或者甚至是promise链的API冗余！）来已经是一个简单的语法信号/冗余了。</p>
<p>注意到我刚刚说了<em>可能发生</em>。这是一个相当强大的事情。上面的程序总是发出一个Ajax请求，但是<strong>如果它不这样呢</strong>？如果我们之后将我们的程序改为读取内存中之前得到的Ajax响应呢？或者一些程序中的复杂URL rouer可能在某些条件下立即响应一个Ajax请求而不需要真的从一个外部服务器获取呢？</p>
<p>我们可以改变<code>request(..)</code>的实现使它变成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[url]) &#123;</span><br><span class="line">        <span class="comment">// "defer" cached response long enough for current</span></span><br><span class="line">        <span class="comment">// execution thread to complete</span></span><br><span class="line">        setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            it.next( cache[url] );</span><br><span class="line">        &#125;, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">            cache[url] = resp;</span><br><span class="line">            it.next( resp );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里有一个小技巧是需要使用<code>setTimeout(..0)</code>进行延迟以防cache已经在结果里面了。如果我们刚刚立即调用<code>it.next(..)</code>，它会产生一个错误，因为（这就是那个技巧）generator<em>尚未</em>处于暂停状态。我们的函数调用<code>request(..)</code><em>首先</em>被评估，然后<code>yield</code>暂停。因此我们不能再次在<code>request(..)</code>内部调用<code>it.next(..)</code>，因为在那个时刻generator扔在执行（<code>yield</code>还没有被进行）。但是我们可以”之后“调用<code>it.next(..)</code>，在当前线程执行完的一瞬间，也就是我们的<code>setTimeout(..0)</code>”伪造“的一个实现。<strong>我们会在下面有一个更好的实现</strong>。</p>
<p>现在我们的main generator代码仍然看起来像：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>看到了吧？！我们的generator逻辑（也就是控制流）和不加cache的版本比起来<strong>完全</strong>不需要变化。</p>
<p><code>*main()</code>中的代码仍然请求一个值，然后暂停直到它得到值。在我们当前的情境下，”暂停“可以非常长（发送一个真实的请求到服务器，一般为300-800ms）或者可能几乎立即结束（<code>setTimeout(..0)</code>进行延迟处理）。而我们的控制流并不关心。</p>
<p>这就是<strong>将异步行为抽象为实现细节</strong>真正的强大之处。</p>
<h2 id="更好的异步"><a href="#更好的异步" class="headerlink" title="更好的异步"></a>更好的异步</h2><p>对于一个单独的异步generator工作，上面的实现已经相当不错了。但是它马上会到达局限，所以我们需要一个更强大的异步机制来和我们的generator做搭配，它能够承担更多的负担。这个机制是什么呢？就是<strong>Promise</strong>。</p>
<p>如果你对于ES6的Promise还有点模糊不清，我写了一个<a href="http://blog.getify.com/promises-part-1/" target="_blank" rel="external">5篇文章的系列</a>，去读一读吧。我会在这里wait直到你回来的（偷笑，哈哈）。这只是个老掉牙的异步的笑话啦！</p>
<p>本文早先的Ajax代码都有同样的<a href="http://blog.getify.com/promises-part-2/" target="_blank" rel="external">控制反转</a>的问题（也就是”回调地狱“），就下你给我们最初的那个充满了回调的例子一样。到目前为止，我们缺乏这样一些东西：</p>
<ol>
<li><p>没有明确的异常处理的方式。我们已经<a href="http://davidwalsh.name/es6-generators-dive/#error-handling" target="_blank" rel="external">从上篇文章中学到</a>，我们可以探测到一个Ajax调用时的异常（通过某种方式），通过<code>it.throw(..)</code>传递回我们的generator，然后使用<code>try..catch</code>在我们的generator逻辑中处理它。但是那只是更多的手动任务来接通“后端”（我们处理generator iterator的代码），并且如果我们需要非常多的generator是，它可能无法重复使用。</p>
</li>
<li><p>如果<code>makeAjaxCall(..)</code>工具类不受控制，并且它调用了多次的callback，或者信号同时成功与失败，等等。那么我们的generator会出故障（未捕获的异常，不期待的值，等等）。处理并且阻止这些问题很多都是手动工作，并且同样无法重用。</p>
</li>
<li><p>经常的，我们并不仅仅”并发“执行任务（例如两个并行的Ajax调用那样）。由于generator<code>yield</code>表达式是一个单一暂停点，两个或两个以上的generator不可以在同时运行 – 它们不得不一次一个的执行，按顺序。因此，对于如何在单独的generator <code>yield</code>点发送多个任务，而不在表面之下进行大量的人工编码，是尚不可知的。</p>
</li>
</ol>
<p>如你所见，所有这些问题都是<em>可以被解决的</em>，但是谁又希望每次都重新发明这些解决方法呢？我们需要一个更强大的模式，设计为专为基于generator的异步编码的<a href="http://blog.getify.com/promises-part-3/" target="_blank" rel="external">可信的，可重用的解决方案</a>。</p>
<p>那个模式是？<strong><code>yield</code> out promises</strong>，并且当他们被fulfill时让它们恢复generator。</p>
<p>回想一下上面我们所做的<code>yield request(..)</code>，以及<code>request(..)</code>功能方法没有任何返回值，仅仅<code>yield undefined</code>是有效的吗？</p>
<p>让我们小小的对他进行调整。让我们改变我们的<code>request(..)</code>功能方法使其成为一个基于promise的方法，这样它会返回一个promise，并且这样的话我们<code>yield</code> out的东西<strong>实际上是一个promise</strong>（而不是<code>undefined</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Note: returning a promise now!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        makeAjaxCall( url, resolve );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，<code>request(..)</code>会构造一个Ajax调用结束后被处理的promise，并返回这个promise，所以它可以被<code>yield</code>出去，下一步呢？</p>
<p>我们会需要一个功能方法来控制我们的generator iterator，它接收这些被<code>yield</code>的promise然后将他们与恢复generator联通(通过<code>next(..)</code>)。我现在会调用下面这个<code>runGenerator(..)</code>功能类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run (async) a generator to completion</span></span><br><span class="line"><span class="comment">// Note: simplified approach: no error handling here</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> it = g(), ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// asynchronously iterate over generator</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        ret = it.next( val );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ret.done) &#123;</span><br><span class="line">            <span class="comment">// poor man's "is it a promise?" test</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</span><br><span class="line">                <span class="comment">// wait on the promise</span></span><br><span class="line">                ret.value.then( iterate );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// immediate value: just send right back in</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// avoid synchronous recursion</span></span><br><span class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    iterate( ret.value );</span><br><span class="line">                &#125;, <span class="number">0</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的关键点：</p>
<ol>
<li><p>我们自动的对generator进行初始化（创建它的<code>it</code>迭代器），然后我们异步地运行<code>it</code>直到结束（<code>done: ture</code>）。</p>
</li>
<li><p>我们寻找要被<code>yield</code>出去（即在每个<code>it.next(..)</code>调用时的返回值<code>value</code>）的promise。如果有的话，我们通过在promise之上注册<code>then(..)</code>等待直到它结束。</p>
</li>
<li><p>如果任何立即的（即非promise）值被返回，我们简单地发送这个值到generator中以便它继续立即执行。</p>
</li>
</ol>
<p>现在，我们怎么使用它呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Bam！等一等…这不<strong>和我们之前的generator代码一样</strong>吗？是的。再一次地，generator的强大之处显示出来了。实际上是，我们现在在创建promise，将他们<code>yield</code>出去，然后在generator结束时恢复他们 – <strong>所有这些都隐藏了实现细节！</strong> 当然并不是完全隐藏，只是从消费代码（我们generator内部的控制流）中分离出来了。</p>
<p>通过等待被<code>yield</code>出去的promise，并且发送完成结果回<code>it.next(..)</code>，代码<code>result1 = yield request()..</code>得到了和之前完全相同的值。</p>
<p>但是现在我们在使用promise来管理generator代码中的异步部分，我们解决所有的来自于回调风格解决方案的倒转/信任问题。我们通过使用generator + promise得到所有上面的解决方案。</p>
<ol>
<li><p>我们现在有了便于使用的内嵌的异常处理。我们在上面的<code>runGenerator(..)</code>中并没有显示它，但是从promise中监听一个异常并发送至<code>it.throw(..)</code>并不困难 – ranh9ou我们可以在我们的generator代码中使用<code>try..catch</code>来捕获并处理这些异常。</p>
</li>
<li><p>我们拥有了所有由promise提供的<a href="http://blog.getify.com/promises-part-2/#uninversion" target="_blank" rel="external">控制/可信性解决方案</a>。不需要更多的关心。</p>
</li>
<li><p>Promise拥有非常多位于上层的强大的抽象，它可以自动地处理复杂的多“并发”任务，等等。</p>
</li>
</ol>
<p>例如<code>yield Promise.all([ .. ])</code>可以接受一个prmose的数组来“并发执行”任务，然后<code>yield</code>出一个单一的promise（给generator来处理），它在处理前等待所有的子promise结束（无论以何种顺序）。你从<code>yield</code>表达式返回的（当promise结束时）是一个所有子promise的响应数组，按照它们请求的顺序（无论它们的结束顺序是如何）。</p>
<p>首先让我们来看看异常处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume: `makeAjaxCall(..)` now expects an "error-first style" callback (omitted for brevity)</span></span><br><span class="line"><span class="comment">// assume: `runGenerator(..)` now also handles error handling (omitted for brevity)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// pass an error-first style callback</span></span><br><span class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span>(<span class="params">err,text</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject( err );</span><br><span class="line">            <span class="keyword">else</span> resolve( text );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>当获取URL时promise被拒绝（或者任何形式的错误/异常），promise rejection会被映射为一个generator错误（使用我们之前没有描述的<code>runGenerator(..)</code>中的<code>it.throw(..)</code>），它会被<code>try..catch</code>语句捕获住。</p>
<p>现在，让我们来看一个更下复杂的例子，它使用了promise来管理更多异步的复杂问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        makeAjaxCall( url, resolve );</span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="comment">// do some post-processing on the returned text</span></span><br><span class="line">    .then( <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// did we just get a (redirect) URL back?</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^https?:\/\/.+/</span>.test( text )) &#123;</span><br><span class="line">            <span class="comment">// make another sub-request to the new URL</span></span><br><span class="line">            <span class="keyword">return</span> request( text );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise, assume text is what we expected to get back</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> search_terms = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all( [</span><br><span class="line">        request( <span class="string">"http://some.url.1"</span> ),</span><br><span class="line">        request( <span class="string">"http://some.url.2"</span> ),</span><br><span class="line">        request( <span class="string">"http://some.url.3"</span> )</span><br><span class="line">    ] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> search_results = <span class="keyword">yield</span> request(</span><br><span class="line">        <span class="string">"http://some.url.4?search="</span> + search_terms.join( <span class="string">"+"</span> )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( search_results );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Search results: "</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><code>Promise.all([ .. ])</code>构造一个promise，它等待3个子promise。并且，被<code>yield</code>出提供给<code>runGenerator(..)</code>功能函数的主promise会被监听作为generator的恢复。子promise可以接收一个响应，它看起来像另一个URL，并且以链式连接另一个子promise到达新的地点。如果要学习更多promise链式表达，<a href="http://blog.getify.com/promises-part-5/#the-chains-that-bind-us" target="_blank" rel="external">阅读这篇文章</a>。</p>
<p>任何异步的功能性/复杂性问题都可以由promise解决，而同步风格代码则可以通过使用generator <code>yield</code>出promise（的promise的promise…）来实现。<strong>这真是两全其美</strong></p>
<h2 id="runGenerator-功能库"><a href="#runGenerator-功能库" class="headerlink" title="runGenerator(..): 功能库"></a>runGenerator(..): 功能库</h2><p>我们已经定义了我们自己的<code>runGenerator(..)</code>来启用这个强大的generator+promise组合。我们省略了这个功能函数的完全实现（为了简单起见），因为还有很多细节上和异常处理相关的内容需要完成。</p>
<p>但是，你并不想编写你自己的<code>runGenerator(..)</code>是吧？</p>
<p>我认为是的。</p>
<p>有非常多的promise/异步库提供了这样的功能。我在这里不会讲述，但你可以看一看<code>Q.spawn(..)</code>，<code>co(..)</code>库，等等。</p>
<p>我会简单的介绍一下我自己的功能库：<a href="http://github.com/getify/asynquence" target="_blank" rel="external">asynquence</a>的<a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" target="_blank" rel="external"><code>runner(..)</code>插件</a>，我认为它比上面的那些库提供了一些特殊的适配性。我写了深入的<a href="http://davidwalsh.name/asynquence-part-1/" target="_blank" rel="external">两部分的blog关于asynquence的系列文章</a>如果你感兴趣学到更多的话你可以去看一看。</p>
<p>首先，<em>asynquence</em>提供了功能类自动处理“首参数为错误风格”的回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// pass an error-first style callback</span></span><br><span class="line">        makeAjaxCall( url, done.errfcb );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这<strong>更加的友好</strong>了，不是吗！？</p>
<p>下一步，asynquence的<code>runner(..)</code>插件在<em>aynquence</em>序列（异步序列步骤）的中途消耗一个generator，所以你可以从之前的步骤向内传递消息，而你的generator可以向外或向下一步传递消息，而所有的错误会自动地如你期望的那样传播。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first call `getSomeValues()` which produces a sequence/promise,</span></span><br><span class="line"><span class="comment">// then chain off that sequence for more async steps</span></span><br><span class="line">getSomeValues()</span><br><span class="line"></span><br><span class="line"><span class="comment">// now use a generator to process the retrieved values</span></span><br><span class="line">.runner( <span class="function"><span class="keyword">function</span>*(<span class="params">token</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// token.messages will be prefilled with any messages</span></span><br><span class="line">    <span class="comment">// from the previous step</span></span><br><span class="line">    <span class="keyword">var</span> value1 = token.messages[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> value2 = token.messages[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> value3 = token.messages[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make all 3 Ajax requests in parallel, wait for</span></span><br><span class="line">    <span class="comment">// all of them to finish (in whatever order)</span></span><br><span class="line">    <span class="comment">// Note: `ASQ().all(..)` is like `Promise.all(..)`</span></span><br><span class="line">    <span class="keyword">var</span> msgs = <span class="keyword">yield</span> ASQ().all(</span><br><span class="line">        request( <span class="string">"http://some.url.1?v="</span> + value1 ),</span><br><span class="line">        request( <span class="string">"http://some.url.2?v="</span> + value2 ),</span><br><span class="line">        request( <span class="string">"http://some.url.3?v="</span> + value3 )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send this message onto the next step</span></span><br><span class="line">    <span class="keyword">yield</span> (msgs[<span class="number">0</span>] + msgs[<span class="number">1</span>] + msgs[<span class="number">2</span>]);</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// now, send the final result of previous generator</span></span><br><span class="line"><span class="comment">// off to another request</span></span><br><span class="line">.seq( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request( <span class="string">"http://some.url.4?msg="</span> + msg );</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// now we're finally all done!</span></span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( result ); <span class="comment">// success, all done!</span></span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// or, we had some error!</span></span><br><span class="line">.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>asynquence <code>runner(..)</code>功能类接受一个可选的消息来开始generator，这个消息往往是由之前的步骤而来，并且在generator的<code>token.messages</code>数组中是可见的。</p>
<p>然后，和我们之前示范使用<code>runGenerator(..)</code>功能类一样，<code>runner(..)</code>监听一个被<code>yield</code>的poromise或<em>asynquence</em>序列（在这种情况下使用<code>ASQ().all(..)</code>序列来并发执行），并且等待它的结束然后恢复generator。</p>
<p>当generator结束时，最后<code>yield</code>出的值会传递给序列的下一个步骤。</p>
<p>并且，如果有任何错误在这个序列的任何地方发生，甚至是在generator内部发生，它会被传播给单独的<code>or(..)</code>被注册的错误处理者。</p>
<p><em>asynquence</em>尝试将promise和generator尽可能简单的结合。你可以随心所欲的构造任何generator流和基于promise的序列步骤流。</p>
<h2 id="ES7-async"><a href="#ES7-async" class="headerlink" title="ES7 async"></a>ES7 <code>async</code></h2><p>ES7的时间轴上有一个提案，它看起来会被接受，来创建另一种函数：<code>async function</code>，它看起来是使用generator自动地包装一个像<code>runGenerator(..)</code>（或<em>asynquence</em>的<code>runner(..)</code>）功能类。那样的话你可以发送promise并且<code>async function</code>会自动地将其包装并且在结束时恢复promise（甚至不需要使用iterator！）</p>
<p>所以它看起来可能会像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = <span class="keyword">await</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">await</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<p>如你所见，一个<code>async function</code>可以被直接调用（就像<code>main()</code>一样），而不需要像<code>runGenerator(..)</code>或<code>ASQ().runner(..)</code>的包装功能类来包装它。在内部，有别于使用<code>yield</code>，你将会使用<code>await</code>（另一个新的关键词）来告知<code>async function</code>在继续执行前等待promise的结束。</p>
<p>基本上，我们会拥有大多数包装库包装后的generator的能力，但是<strong>直接由原生语法支持</strong></p>
<p>酷！是吧！</p>
<p>在同时，像<em>asynquence</em>这样的库给予我们这些执行功能函数来让我们使用异步generator更容易！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的说：generator + <code>yield</code>ed promise组合了双方最好的部分让我们得到了强大而优雅的同步语法+异步流程控制的能力。使用简单的包装功能函数（有非常多的功能库已经提供了这一点），我们可以自动的运行我们的generator到结束，包括正常结果以及出错的处理。</p>
<p>在ES7的大陆上，我们很可能会见到<code>async function</code>让我们可以不依靠功能库来达到（至少对基本的case可以这样实现）。</p>
<p><strong>JavaScript中异步的未来是光明的</strong>，并且只会变得更光明！我应该戴上太阳镜。</p>
<p>但是我们还没有结束，我们还有最后一个部分想要发掘一下：</p>
<p>如果你可以将两个或多个generator连接在一起会怎么样呢？让他们单独但“并发”的执行，并且让他们在执行的过程中互相发送消息？那会是一种更强大的能力，不是吗？这个模式被称为”CSP”（communicating sequential processes）。我们会在下一篇文章中解锁CSP的强大能力。请继续关注！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#用Generator进行异步编程（译）&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://davidwalsh.name/async-generators&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://davidwalsh.name/
    
    </summary>
    
    
      <category term="generator async translation" scheme="http://nnabuuu.github.io/blog-hexo/tags/generator-async-translation/"/>
    
  </entry>
  
  <entry>
    <title>Diving Deeper With ES6 Generators</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/12/24/Diving-Deeper-With-ES6-Generators/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/12/24/Diving-Deeper-With-ES6-Generators/</id>
    <published>2014-12-25T06:29:28.000Z</published>
    <updated>2016-04-29T18:43:51.160Z</updated>
    
    <content type="html"><![CDATA[<p>#深入ES6Generators（译）</p>
<p>原文地址：<a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">http://davidwalsh.name/es6-generators-dive</a></p>
<p>ES6 Generators：全系列</p>
<ol>
<li><a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">The Basics Of ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">Diving Deeper With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">Getting Concurrent With ES6 Generators</a></li>
</ol>
<p>如果你仍然不熟悉ES6 generator，首先去读一读并理解“<a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">第一部分：ES6Generator基础</a>”。一旦你认为你已经了解了这些基础，现在我们就可以深入到一些细节之中了。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>ES6 generator设计时一个最为强大的部分就是它内部的代码语义是同步的，即使外部迭代控制是异步执行的。</p>
<p>这是个很棒而且复杂的方式，意味着你可以使用简单的错误处理技术，这个技术你可能已经非常熟悉了 – 也就是<code>try..catch</code>机制</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"x: "</span> + x ); <span class="comment">// may never get here!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管函数会在<code>yield 3</code>表达式处停止，并且可能随意暂停一段时间，如果一个错误没回传到generator，那个<code>try..catch</code>会捕获它！尝试用普通的异步能力（例如callback）来做做看？：）</p>
<p>但是，怎样才能使一个错误返回到generator中呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instead of resuming normally with another `next(..)` call,</span></span><br><span class="line"><span class="comment">// let's throw a wrench (an error) into the gears:</span></span><br><span class="line">it.throw( <span class="string">"Oops!"</span> ); <span class="comment">// Error: Oops!</span></span><br></pre></td></tr></table></figure>
<p>这里，你可以看到我们使用了iterator上的另一个方法 – <code>throw(..)</code> – 它会“抛”一个异常到generator中，就像它正好在generator当前<code>yield</code>暂停处发生一样。<code>try..catch</code>捕获如你所期望的那样这个错误！</p>
<p>注：如果你<code>throw(..)</code>一个错误进入generator，而没有<code>try..catch</code>住它，那么这个错误会（和普通错误一样）传播会来（如果最终没有被捕获，则会成为一个未被捕获的异常）。因此：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    it.throw( <span class="string">"Oops!"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err ); <span class="comment">// Error: Oops!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，反方向的错误处理方式同样可行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> y = x.toUpperCase(); <span class="comment">// could be a TypeError error!</span></span><br><span class="line">    <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    it.next( <span class="number">42</span> ); <span class="comment">// `42` won't have `toUpperCase()`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( err ); <span class="comment">// TypeError (from `toUpperCase()` call)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="generator代理"><a href="#generator代理" class="headerlink" title="generator代理"></a>generator代理</h2><p>你可能想做的另一件事情是从你的generator函数内部调用另一个generator。我指的并不仅仅是普通方式实例化一个generator，而是代理你自己的的迭代控制到那一个另外的generator上。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> *foo(); <span class="comment">// `yield *` delegates iteration control to `foo()`</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> bar()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<p>如在第一部分解释的那样（我使用<code>function *foo(){ }</code>而不是<code>function* foo(){ }</code>），我这里同样使用<code>yield *foo()</code>来代替很多其他文章/文档使用的<code>yield* foo()</code>。我认为这样可以更加准确/清晰地说明代码正在做些什么。</p>
<p>让我们分解一下看看它是如何工作的。<code>yield 1</code>和<code>yield 2</code>直接发送他们的值到<code>for..of</code>循环外的<code>next()</code>的（隐式）调用中，就像我们已经理解/期望的那样。</p>
<p>但是接着程序就走到了<code>yield*</code>，然后你会注意到，我们正在通过实例化它（foo()）yield到另一个generator。因此我们基本上是在yield或代理到另一个generator的iterator上 – 这可能是最准确的想象它的方式。</p>
<p>一旦<code>yield*</code>被（临时）从<code>*bar()</code>代理到<code>*foo()</code>，那么现在<code>for..of</code>循环的<code>next()</code>调用实际上是在控制<code>foo()</code>，因此<code>yield 3</code>和<code>yield 4</code>发送他们的值到外面的<code>for..of</code>循环中。</p>
<p>一旦<code>*foo()</code>结束，控制权会返回到最初的generator上，它最终调用到<code>yield 5</code></p>
<p>为了简化起见，这个例子仅仅<code>yield</code>值出去，但是当然如果你不适用一个<code>for..of</code>循环，而是就手动调用iterator的<code>next(..)</code>并且通过消息传递，这些消息会通过同样的行为穿过<code>yield*</code>代理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> w = <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"z: "</span> + z + <span class="string">", w: "</span> + w );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> *foo(); <span class="comment">// `yield*` delegates iteration control to `foo()`</span></span><br><span class="line">    <span class="keyword">var</span> v = <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"x: "</span> + x + <span class="string">", y: "</span> + y + <span class="string">", v: "</span> + v );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next();      <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line">it.next( <span class="string">"X"</span> ); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line">it.next( <span class="string">"Y"</span> ); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line">it.next( <span class="string">"Z"</span> ); <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line">it.next( <span class="string">"W"</span> ); <span class="comment">// &#123; value:5, done:false &#125;</span></span><br><span class="line"><span class="comment">// z: Z, w: W</span></span><br><span class="line"></span><br><span class="line">it.next( <span class="string">"V"</span> ); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br><span class="line"><span class="comment">// x: X, y: Y, v: V</span></span><br></pre></td></tr></table></figure>
<p>尽管我们在这里只显示了一层代理，而<code>*foo()</code>去<code>yield*</code>代理到另一个、另一个、另一个generator也是可以的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"foo"</span>; <span class="comment">// return value back to `yield*` expression</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="keyword">yield</span> *foo();</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"v: "</span> + v );</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// "v: foo"   &#123; value:4, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>如你所见，<code>yield *foo()</code>代理迭代循环（这些<code>next()</code>调用）知道结束，然后一旦它这样做，任何从<code>foo()</code>中<code>return</code>的值（在本例里：字符串<code>&quot;foo&quot;</code>）会被设置为<code>yield*</code>表达式的结果值，然后被赋值给本地变量<code>v</code>。</p>
<p><code>yield</code>和<code>yield*</code>之间有一个有趣的区别：对于<code>yiled</code>表达式，其结果是任何同事子序列<code>next(..)</code>传入的值，但是对于<code>yield*</code>表达式，它仅仅接收被代理的generator的<code>return</code>值（因为<code>next(..)</code>发送的值是对代理透明的）。</p>
<p>你也可以通过<code>yield*</code>代理从两个方向进行错误处理（如前所示）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"foo caught: "</span> + err );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// pause</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now, throw another error</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Oops!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> *foo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"bar caught: "</span> + err );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line"></span><br><span class="line">it.throw( <span class="string">"Uh oh!"</span> ); <span class="comment">// will be caught inside `foo()`</span></span><br><span class="line"><span class="comment">// foo caught: Uh oh!</span></span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:undefined, done:true &#125;  --&gt; No error here!</span></span><br><span class="line"><span class="comment">// bar caught: Oops!</span></span><br></pre></td></tr></table></figure>
<p>如你所见，<code>throw(&quot;Uh oh!&quot;)</code>通过<code>yield*</code>代理抛出错误到<code>*foo()</code>内部的<code>try..catch</code>中。同样的，<code>*foo()</code>内部的<code>throw &quot;Oops!&quot;</code>抛回到<code>*bar()</code>中，然后它在另一个<code>try..catch</code>中捕获这个错误，如果我们没有捕获其中的某一个，那么这些错误会继续向外传播像你平常期望的那样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Generator具有同步的语法，这表示你可以穿过<code>yield</code>表达式使用<code>try..catch</code>错误处理机制。generator同时也有一个<code>throw(..)</code>方法将一个错误抛入generator的暂停位置，这当然也可以被generator内部的<code>try..catch</code>捕获。</p>
<p><code>yield*</code>允许你从当前的generator代理迭代控制到另一个generator。其结果是<code>yield*</code>表现得像一个连接两个方向的通道，同时可供传递消息以及错误。</p>
<p>但是，到现在位置，我们还有一个基本的问题没有解决：generator是如何帮助我们处理异步模式的呢？我们现在在这两篇文章中所见的一切都是generator函数的同步迭代。</p>
<p>其中的关键就是建立一种机制，generator暂停以开始一个异步任务，然后在异步任务结束时恢复（通过他的iterator的<code>next()</code>调用）。我们将在下一篇文章中探索各种关于使用generator创造这样的异步控制机制的方式。请继续关注！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#深入ES6Generators（译）&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://davidwalsh.name/es6-generators-dive&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://davidwalsh.nam
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>The Basics Of ES6 Generators</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/12/21/The-Basics-Of-ES6-Generators/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/12/21/The-Basics-Of-ES6-Generators/</id>
    <published>2014-12-21T19:33:48.000Z</published>
    <updated>2016-04-29T18:43:51.169Z</updated>
    
    <content type="html"><![CDATA[<p>#ES6Generator基础（译）</p>
<p>原文地址：<a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">http://davidwalsh.name/es6-generators</a></p>
<p>ES6 Generators：全系列</p>
<ol>
<li><a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">The Basics Of ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">Diving Deeper With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">Getting Concurrent With ES6 Generators</a></li>
</ol>
<p>Javascript ES6 带来的一种最激动人心的新特性是一种新的函数，称为<strong>generator</strong>。它的名字可能有一点奇怪，但是它的行为在第一次看来却<em>更让人陌生</em>。这篇文章旨在解释它的是如何工作的基础概念，并且使你明白为什么它们对于JS的未来如此的强大。</p>
<p>##运行至完成</p>
<p>当我们讨论generator时我们所要见到的第一件事情就是：它们与普通函数对于“运行至完成”的概念是多么的不同。</p>
<p>无论你是否意识到，你对于函数的基础已经常常可以断言一些事情：一旦函数开始执行，在其他JS代码可以执行之前，它总会执行到结束。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> don't ever do crazy long-running loops like this</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;=<span class="number">1E10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0..1E10</span></span><br><span class="line"><span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure>
<p>在这里，<code>for</code>循环会花费非常长的时间直到结束，至少比一毫秒要长，但是我们的计时器回调<code>console.log(...)</code>语句无法在<code>foo()</code>函数执行时打断它，因此它被堵塞语句之后（在event-loop中）并耐心地等到自己的回合。</p>
<p>如果<code>foo()</code>可以被打断，会怎么样呢？那样不会对我们的程序造成极大的破坏吗？</p>
<p>那就是多线程编程的<del>噩梦</del>挑战。但我们非常幸运地处在JavaScript的世界里而不必担心这些事情，因为JS总是单线程的（只有一个命令/函数可以在一个时刻执行）。</p>
<p>注：Web Worker是一种机制，它允许你开启一个完全单独的线程让一部分JS程序在其中执行，该线程完全与你的主JS程序线程并行。此机制并未向我们的程序中引入多线程并发，是因为两个线程只能通过普通的异步事件进行通信，而它总是遵循event-loop的<em>一次执行一个</em>的行为，该行为是由“运行至完成”所要求的。</p>
<p>##运行..停止..运行</p>
<p>对于ES6 generator，我们有另一种类型的函数，它可能在中间<em>暂停</em>，一次或多次，并在<em>之后</em>恢复，允许其他代码在暂停的间隙执行。</p>
<p>如果你曾经阅读过任何有关并发或基于线程的编程的内容，你可能见过“协作”这个词，它基本上意味着一个进程（在我们的例子中，是一个函数）自身选择何时它允许一个中断，这样它可以与其他代码进行<strong>“协作”</strong>。与这个概念相对应的是“抢占”，它表明一个进程/函数可以不依照其意愿被打断。</p>
<p>ES6 generator函数在其并发行为上是“协作”式的。在generator函数体内，你可以使用新的<code>yield</code>关键词来从函数自身中暂停。没有任何东西可以从一个generator的外部暂停它，仅当generator（在内部）遇到一个yield时，它才会暂停自己。</p>
<p>但是，一旦generator使用<code>yield</code>暂停了自身，它自己无法进行恢复。必须使用一个外部的控制方式重启generator。我们会在下面解释这是如何发生的。</p>
<p>因此，基本上，一个generator函数可以停止以及被重启任意次数。事实上，你可以在一个无限循环（例如臭名昭著的<code>while (true) { .. }</code>）中指定一个generator函数，尽管这基本上是非常疯狂的并且在普通的JS程序中是错误的，而使用generator函数这是完全正常的并且有时候正事你所希望做的那样。</p>
<p>甚至更为重要的是，停止和重启并不仅仅是控制generator函数的执行，它也使得执行时的双向的信息传递（出入generator）变为可能。使用普通函数时，你会在开始获取参数并在结束时<code>return</code>一个值。使用generator函数，你可以使用每一个<code>yield</code>发出消息，并且你可以在每次重启时回传消息。</p>
<h2 id="请告诉我语法，谢谢！"><a href="#请告诉我语法，谢谢！" class="headerlink" title="请告诉我语法，谢谢！"></a>请告诉我语法，谢谢！</h2><p>让我们看看这些新的激动人心的generator函数的语法。</p>
<p>首先，它有新的声明语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这里的<code>*</code>了吗？这是一种新的语法并且看起来有一点奇怪。对于那些来自于其他语言的开发者来说，这可能看起来非常像函数返回值的指针。但是请不要被它迷惑！这仅仅是一个来标志特殊的generator函数类型的方式。</p>
<p>你可能见过其它文章/文档使用<code>function* foo(){ }</code> 而不是<code>function *foo(){ }</code> （<code>*</code>的位置不同）。它们都是有效的，但是我最近决定使用<code>function *foo() {}</code>因为这样更加准确，因此我会在这里这样写。</p>
<p>现在，让我们来谈谈我们的generator函数的内容。generator函数在很多方面都只是普通的JS函数。在generator函数内部，新的语法非常少。</p>
<p>我们主要使用的语法，入上面所述，是<code>yield</code>关键词。<code>yield ___</code>被称为“yield表达式”（不是一个语句），因为当我们重启generator时，我们会回传一个值到内部，并且无论我们返回的是什么它都会被作为<code>yield ___</code>表达式的计算结果。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="string">"foo"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，当generator函数在<code>yield &quot;foo&quot;</code>暂停时，表达式会发送<code>&quot;foo&quot;</code>字符串出去，并且无论何时，只要generator被重启，无论什么值被发送，它会被作为这个表达式的结果，这个值然后会加上<code>1</code>并且赋值给<code>x</code>变量。</p>
<p>看见这里的双向交流了吗？你发送<code>&quot;foo&quot;</code>出去，暂停你自己，然后在某一个<em>之后</em>的时间点（可能是立即，也可能是距离现在非常长的时间！），generator会被重启并且提供你一个返回值。差不多<code>yield</code>关键词是某种创造向外请求一个值的方式。</p>
<p>在任何表达式的地方，你可以仅仅使用<code>yield</code>自身，这表明你向外<code>yield</code>一个<code>undefined</code>。像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: `foo(..)` here is NOT a generator!!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"x: "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// just pause</span></span><br><span class="line">    foo( <span class="keyword">yield</span> ); <span class="comment">// pause waiting for a parameter to pass into `foo(..)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##Generator迭代器</p>
<p>“Generator Iterator”。的确又长又难念，是吧？</p>
<p>迭代器是一种特殊的行为类型，事实上，它是一种设计模式，我们按某种顺序遍历一组值，每次通过调用<code>next()</code>获取一个值。例如设想一下对这样一个数组<code>[1, 2, 3, 4, 5]</code>使用一个迭代器。第一个<code>next()</code>调用会返回<code>1</code>，第二个<code>next()</code>会返回<code>2</code>，并一次类推。当所有的值都被返回之后，最后的<code>next()</code>会返回<code>null</code>或者<code>false</code>，或者其他的信号标志你已经迭代完容器内的所有值。</p>
<p>我们从外部控制generator函数的方式，是使用一个<em>generator iterator</em>构造并且交互。这听起来比实际上做起来要复杂。想想一下这个很蠢的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了从<code>*foo()</code>这个generator函数中遍历值，我们需要构造一个迭代器，如何做呢？非常简单！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = foo();</span><br></pre></td></tr></table></figure>
<p>噢！所以，用普通方式调用generator函数实际上并没有执行它的任何内容。</p>
<p>把这些塞进你的大脑有一点奇怪。你可能尝试疑问：为什么不是<code>var it = new foo()</code>？好吧，这个语法背后的原因很复杂并且不在我们所要讨论的范围内。</p>
<p>那么现在，开始迭代我们自己的generator函数，我们只需：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = it.next();</span><br></pre></td></tr></table></figure>
<p>这会给我们从<code>yield 1</code>语句中提供<code>1</code>，但这并不是唯一我们得到的东西。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>我们事实上从每个<code>next()</code>调用中获取了一个对象，它包含一个<code>value</code>属性用来描述<code>yield</code>出的值，而<code>done</code>是一个布尔值它用来标志是否generator函数是否已经完全结束。</p>
<p>让我们继续我们的迭代：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:5, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>有趣的是，当我们取出<code>`5</code>时，done<code>仍然是</code>false<code>。这是因为*严格来说*，generator函数并没有完成。我们仍然需要调用最后一个</code>next()<code>，并且我们传入一个值时，它会被设置为</code>yield 5`表达式的结果。只有<strong>那时</strong>，generator函数才算是结束了。</p>
<p>那么，现在：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>因此，最后我们generator函数的结果是我们完成了这个函数，并且没有提供任何结果（因为我们已经耗尽了所有的<code>yield ___</code>表达式）。</p>
<p>你可能在这一点上想：我能不能在generator函数中使用<code>return</code>呢，如果我这样做，最后的结果会被设置在<code>value</code>属性上吗？</p>
<p>###是…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:2, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>###…又不是</p>
<p>依赖来自于generator的<code>return</code>值不是一个好主意，因为当使用<code>for..of</code>来迭代generator函数（见下）时，最后的<code>return</code>值会被扔掉。</p>
<p>为了完整性考虑，我们也来看看早我们遍历一个generator函数时同时向内和向外发送消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo( <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// note: not sending anything into `next()` here</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() );       <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next( <span class="number">12</span> ) );   <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next( <span class="number">13</span> ) );   <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到我们仍然可以通过最初的实例化调用<code>foo(5)</code>传递初始值，就像普通的函数那样。</p>
<p>第一个<code>next(..)</code>调用，我们不传递任何值，为什么？因为没有<code>yield</code>表达式接受我们传入的值。</p>
<p>但是如果我们的确向第一个<code>next(..)</code>调用传递了值，也不会有任何坏的事情发生，它只会被抛弃掉。对于这种情况，ES6描述了generator函数忽略未使用的值。（<strong>注：</strong>在写作这篇文章时，最新版本的Chrome和FF都表现如此，但是其他浏览器可能不完全兼容并可能不正确地对这种情况抛出一个异常）。</p>
<p>第二个<code>next(12)</code>调用将<code>12</code>传递给第一个<code>yield (x + 1)</code>表达式。第三个<code>next(13)</code>调用将<code>13</code>传递给第二个<code>yield (y / 3)</code>表达式。<strong>反复地重新阅读这段代码</strong>。对于很多人来说，在他们刚开始看这些代码的时候感觉奇怪。</p>
<p>##<code>for...of</code></p>
<p>ES6同样在语法级别拥抱这种迭代器模式，通过直接提供对执行迭代器到结束的支持：<code>for..of</code>循环。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( v ); <span class="comment">// still `5`, not `6` :(</span></span><br></pre></td></tr></table></figure>
<p>如你所见，由<code>foo()</code>创建的迭代器被<code>for..of</code>循环自动地捕获，并且会为你自动地进行迭代，每轮迭代获取一个值直到得到一个<code>done:true</code>。只要<code>done</code>是<code>false</code>，它就会自动的提取<code>value</code>属性并分配给你的迭代变量中（在我们这里是<code>v</code>）。一旦<code>done</code>已经变为<code>true</code>，迭代循环停止（并且不对最后返回的<code>value</code>做任何处理，如果有的话）。</p>
<p>如之前所述，你可以看到<code>for..of</code>循环忽略并抛弃了<code>return 6</code>的值。同事由于没有暴露<code>next()</code>调用，<code>for..of</code>循环无法用于像我们之前那样向generator传入值的场合。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的，这就是generator的基础。如果你还有一些不明白的话，不必担心。我们每个人开始时都感觉像那样！</p>
<p>想一想这种新的玩具会如何改变你的代码是很自然的。尽管还有<strong>很多</strong>内容，我们刚刚触及了表面。所以在我们了解它们是多么强大之前我们必须要更深入地了解。</p>
<p>在你运行过上面的代码片段之后（试试最新的Chrome,FF或者node0.11+带上<code>--harmony</code>标志），你可能会产生以下的疑问：</p>
<ol>
<li>如何进行错误处理？</li>
<li>一个generator可以调用另一个generator吗？</li>
<li>异步代码如何与generator交互？</li>
</ol>
<p>这些，或更多的问题，会在接下来的几篇文章中阐述，请继续关注！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#ES6Generator基础（译）&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://davidwalsh.name/es6-generators&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://davidwalsh.name/es6-
    
    </summary>
    
    
      <category term="js, generator, tanslation" scheme="http://nnabuuu.github.io/blog-hexo/tags/js-generator-tanslation/"/>
    
  </entry>
  
  <entry>
    <title>Getting Started with Koa, part 2</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/12/06/Getting-Started-with-Koa,-part-2/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/12/06/Getting-Started-with-Koa,-part-2/</id>
    <published>2014-12-07T06:37:41.000Z</published>
    <updated>2016-04-29T18:43:51.163Z</updated>
    
    <content type="html"><![CDATA[<p>#开始使用Koa，第二部分（译）</p>
<p><a href="http://blog.risingstack.com/getting-started-with-koa-part-2/" target="_blank" rel="external">http://blog.risingstack.com/getting-started-with-koa-part-2/</a></p>
<p>原作者： Gellért Hegyi <a href="https://twitter.com/native_cat" target="_blank" rel="external">https://twitter.com/native_cat</a></p>
<p>在<a href="http://blog.risingstack.com/introduction-to-koa-generators/" target="_blank" rel="external">上一节</a>我们掌握了generators并且明白了一点，那就是我们可以<strong>以同步的形式编写代码而异步的执行</strong>。这非常棒，因为同步代码非常简单，优雅而且具有更好的可读性，而异步代码可能会导致“尖叫”与“哭泣”（回调地狱）。</p>
<p>这一章将讲述解决这个痛苦的工具，这样我们就可以只编写那些有趣的部分。它会给予基本Koa特性和机制的介绍。</p>
<h2 id="前述"><a href="#前述" class="headerlink" title="前述"></a>前述</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First part</span></span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Second part</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> read(<span class="string">'input.txt'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Third part</span></span><br><span class="line"><span class="keyword">var</span> gen = bar();</span><br><span class="line">gen.next().value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    gen.throw(err);</span><br><span class="line">  &#125;</span><br><span class="line">  gen.next(data.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在上一篇文章的最后一个例子里，如你所见，我们可以将其分为3个重要地部分。第一是我们必须创造我们的<strong>thunkified functions</strong>，它会被用在一个generator中。然后我们必须使用thunkified functions编写我们的<strong>generator functions</strong>。最后一个部分是我们调用并遍历generators，处理异常以及其他。如果你想一想你会发现，最有一部分和我们程序的本质并没有什么关系，基本上它让我们运行一个generator。幸运地是，有一个模块帮我们这样做。来见一见<strong>co</strong>。</p>
<h2 id="CO"><a href="#CO" class="headerlink" title="CO"></a>CO</h2><p><a href="https://github.com/visionmedia/co" target="_blank" rel="external"><strong>Co</strong></a>是一个node的基于generator的流程控制模块。下面的代码和上面做的事情完全一样，但是我们摆脱了调用generator的代码。唯一我们需要做的事情，是<strong>将generator传递给一个函数<code>co</code></strong>,<strong>调用它</strong>，然后魔力就发生了。好吧，其实并不是什么魔力，它只是为你处理所有的generator调用代码，因此我们不需要为那操心了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line"> </span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *<span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> read(<span class="string">'input.txt'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>就像我们已经知道的那样，你可以防止一个<code>yield</code>z在任何东西之前来<strong>对一些东西进行评价</strong>。因此并不是只有<em>trunks</em>可以被<code>yield</code>。因为<code>co</code>想要创建一个简单的控制流，它对一些特殊的类型进行yield。当前<strong>支持yield的类型</strong>：</p>
<ul>
<li>thunks（函数)</li>
<li>array （并发执行）</li>
<li>objects （并发执行）</li>
<li>generators （代理）</li>
<li>generator functions （代理）</li>
<li>promises</li>
</ul>
<p>我们已经讨论过<strong>thunks</strong>是如何工作的了，因此让我们去看看其他的。</p>
<h2 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line"> </span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 3 concurrent reads</span></span><br><span class="line">  <span class="keyword">var</span> reads = <span class="keyword">yield</span> [read(<span class="string">'input.txt'</span>), read(<span class="string">'input.txt'</span>), read(<span class="string">'input.txt'</span>)];</span><br><span class="line">  <span class="built_in">console</span>.log(reads);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2 concurrent reads</span></span><br><span class="line">  reads = <span class="keyword">yield</span> &#123; a: read(<span class="string">'input.txt'</span>), b: read(<span class="string">'input.txt'</span>) &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(reads);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>如果你<code>yield</code>一个数组或一个对象，它将<strong>并行地评估它的内容</strong>。当然你的集合也可以是<code>thunks</code>、<code>generators</code>。你可以<strong>nest</strong>，它会穿过数组或者对象并发执行你所有的函数。<strong>注意</strong>：被yield的结果不会是展开的，它会保留同样的结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line"> </span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = [read(<span class="string">'input.txt'</span>), read(<span class="string">'input.txt'</span>)];</span><br><span class="line">  <span class="keyword">var</span> b = [read(<span class="string">'input.txt'</span>), read(<span class="string">'input.txt'</span>)];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 4 concurrent reads</span></span><br><span class="line">  <span class="keyword">var</span> files = <span class="keyword">yield</span> [a, b];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(files);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>你也可以通过在thunk的调用<strong>之后</strong>进行yield实现并发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line"> </span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = read(<span class="string">'input.txt'</span>);</span><br><span class="line">  <span class="keyword">var</span> b = read(<span class="string">'input.txt'</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2 concurrent reads</span></span><br><span class="line">  <span class="built_in">console</span>.log([<span class="keyword">yield</span> a, <span class="keyword">yield</span> b]);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2 concurrent reads</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">yield</span> [a, b]);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>你当然也可以yield generators。注意我们并不需要使用<code>yield *</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stat = thunkify(fs.stat);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">size</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">yield</span> stat(file);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> s.size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> size(<span class="string">'input.txt'</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我们过一下产不多所有你使用<code>co</code>时进行yield的可能性。这里有一个最新的示例（取自于co的<a href="https://github.com/visionmedia/co" target="_blank" rel="external">github页面</a>）把它们结合起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">size</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fs.stat(file, <span class="function"><span class="keyword">function</span>(<span class="params">err, stat</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> fn(err);</span><br><span class="line">      fn(<span class="literal">null</span>, stat.size);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">yield</span> size(<span class="string">'un.txt'</span>);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">yield</span> size(<span class="string">'deux.txt'</span>);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">yield</span> size(<span class="string">'trois.txt'</span>);</span><br><span class="line">  <span class="keyword">return</span> [a, b, c];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">yield</span> size(<span class="string">'quatre.txt'</span>);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">yield</span> size(<span class="string">'cinq.txt'</span>);</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">yield</span> size(<span class="string">'six.txt'</span>);</span><br><span class="line">  <span class="keyword">return</span> [a, b, c];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> results = <span class="keyword">yield</span> [foo(), bar()];</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>我相信现在你已经足够掌握generators了，你已有有了一个关于如何使用这些工具操作<strong>异步控制流</strong>的很好的概念。</p>
<p>现在是时候转到我们整个系列的主题，<strong>Koa</strong>了！</p>
<h2 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h2><p>你所需要知道的，关于<code>koa</code>模块自身的信息并没有多少。你甚至可以看它的源码，只有4个文件，每个文件约300行。Koa遵循你写的每个程序都只做并且做好一件事情的传统。因此你会看到，每个好的koa模块都是（并且每个node模块都应该是）简短的。只做一件事情并且重度依赖于其他模块。你应该记住这些并且依照它进行开发。它会有利于每个人，你以及其他阅读你源代码的人。记住这一点然后让我们移动到Koa的主要特性。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">var</span> app = koa();</span><br></pre></td></tr></table></figure>
<p>创建一个Koa应用只是简单的引入模块函数。这提供给你一个对象，它包含了一个generators（中间件）的数组，对一个新的请求以类似栈的方式进行执行。</p>
<h2 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h2><p>一个重要的术语，当使用Koa时，它指的是<strong>中间件</strong>。因此让我们先弄清楚这个。</p>
<p>Koa中的中间件是处理请求的函数。一个由Koa创建的服务器可以有一个与它关联的中间件的栈。</p>
<p>Koa中的级联的意思是，控制流穿过一系列的中间件。在Web开发中这是非常重要的，你可以简单地用这种方式构造复杂的行为。Koa使用generator非常直观并且简洁地实现它。<strong>它yield下游，然后控制流程回到上游</strong>。要向流程中添加一个generator，调用<code>use</code>函数并传入一个generator。试着猜猜看为什么下面的代码对每一个到达的请求产生<code>A, B, C, D, E</code>的输出！</p>
<p>这是一个服务器，因此<code>listen</code>函数进行你所认为的行为，它监听一个特殊的端口。（它的参数和纯node的<code>listen</code>方法是一样的）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">  <span class="keyword">yield</span> next;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'E'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'B'</span>);</span><br><span class="line">  <span class="keyword">yield</span> next;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'D'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'C'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>当一个新的请求到达时，它开始流经中间件，以你所编写的顺序执行。因此在示例中，请求触发了第一个中间件，它输出<code>A</code>，然后到达<code>yield next</code>。<strong>当一个中间件到达<code>yield next</code>，它会走向下一个中间件直到离开。</strong>因此我们到达第二个中间件它输出<code>B</code>。然后又跳转到最后一个<code>C</code>。没有更多的中间件了，我们完成了<strong>下游流程</strong>，现在我们开始返回到之前的中间件（就像一个栈），<code>D</code>。然后第一个中间件结束，<code>F</code>，然后我们成功的完成了上游。</p>
<p>在这一点上，<code>koa</code>模块自身并没有包含任何其他的复杂性 - 因此我们不拷贝/粘贴已经很完备的<a href="http://koajs.com/" target="_blank" rel="external">Koa站点</a>的文档，你可以再那里阅读。这里是这些部分的链接：</p>
<p><a href="http://koajs.com/#context" target="_blank" rel="external">Context</a></p>
<p><a href="http://koajs.com/#request" target="_blank" rel="external">Request</a></p>
<p><a href="http://koajs.com/#response" target="_blank" rel="external">Response</a></p>
<p><a href="http://koajs.com/#settings" target="_blank" rel="external">Others</a></p>
<p>让我们看一个例子（也是来自于Koa的站点），它使用而来HTTP功能。第一个中间件计算响应时间。看看你能够多么容易地接触到响应的开始和结束，多么优雅地分离这些函数行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">yield</span> next;</span><br><span class="line">  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'X-Response-Time'</span>, ms + <span class="string">'ms'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">  <span class="keyword">yield</span> next;</span><br><span class="line">  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s %s - %s'</span>, <span class="keyword">this</span>.method, <span class="keyword">this</span>.url, ms);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>现在你已经熟悉Koa的核心了，你可以说你的旧web框架已经做了所有其他有用的事情并且你需要它们。但是也请记住那里还有数以万计的功能你从未使用过，或者还有一些工作并未按照你想象的方式工作。这就是Koa以及现代node框架好的方面。<strong>你可以从<code>npm</code>中以简短模块的方式向你的应用添加需要的功能，并且它会完全按照你需要的方式运行。</strong></p>
<p>在下一章，我们会看到，使用Koa以上述哲学创建一个网站是多么简单。再那之后，再使用这些你已经了解的知识来感受一下Koa和它的自然感吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#开始使用Koa，第二部分（译）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.risingstack.com/getting-started-with-koa-part-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Getting Started with Koa, part 1 - Generators</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/12/05/Getting-Started-with-Koa,-part-1---Generators/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/12/05/Getting-Started-with-Koa,-part-1---Generators/</id>
    <published>2014-12-06T07:58:10.000Z</published>
    <updated>2016-04-29T18:43:51.162Z</updated>
    
    <content type="html"><![CDATA[<p>#开始使用Koa，第一部分 - Generators （译）</p>
<p>原文地址：<a href="http://blog.risingstack.com/introduction-to-koa-generators/" target="_blank" rel="external">http://blog.risingstack.com/introduction-to-koa-generators/</a></p>
<p>原作者： Gellért Hegyi <a href="https://twitter.com/native_cat" target="_blank" rel="external">https://twitter.com/native_cat</a></p>
<p><a href="http://koajs.com/" target="_blank" rel="external">Koa</a>是一个小巧而简单的web框架，由<a href="http://expressjs.com/" target="_blank" rel="external">Express</a>的team带来，其目标是创造一个更加现代的开发web的方式。</p>
<p>在本系列中，你会了解Koa的机制，学习如何高效正确地使用它来编写web应用。第一部分包含一些基本概念（generators, thunks）</p>
<h2 id="为什么是Koa？"><a href="#为什么是Koa？" class="headerlink" title="为什么是Koa？"></a>为什么是Koa？</h2><p>Koa包含的关键特性允许你简单并且快速地编写web应用（并且不包含callback）。它使用来自于<a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts" target="_blank" rel="external">ES6</a>的新语言元素使得控制逻辑管理在Node中比其他框架更加容易。</p>
<p>Koa自身非常小巧，这是是因为不同于试下流行的web框架（例如express），Koa追随高度模块化的原则，意味着每一个模块只做一件事情。将这句话记在脑中，让我们开始吧！</p>
<h2 id="你好Koa"><a href="#你好Koa" class="headerlink" title="你好Koa"></a>你好Koa</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);  </span><br><span class="line"><span class="keyword">var</span> app = koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>在我们开始之前，为了运行示例以及你自己的ES6代码，你需要使用0.11.9或更高的版本并设置<code>--harmony</code>标志位。</p>
<p>你可以从上面的示例中看到，这里没有什么让人感兴趣的点，除了在函数声明之后比较陌生的<code>*</code>号。这样，就使这个函数变成了一个generator函数。</p>
<h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h2><pre><code>当你执行函数时，如果能够在任何点暂停它，进行一些其他计算，做一些其他操作，再返回到这个函数里，并带有一些值，然后继续，这样不好吗？
</code></pre><p>这是另外一种迭代器（像循环一样）。那就是一个generator做的最好的事情，它在ES6中被实现，因此我们可以轻松使用它。</p>
<p>让我们来构造一些generators！首先我们需要创建你的generator函数，它看起来和普通的函数完全一样，除了一点，你需要在<code>function</code>关键词后放置一个<code>*</code>符号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params"></span>) </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就有了一个<em>generator函数</em>。当我们调用这个函数时它会返回一个迭代对象，因此不像普通的函数调用，当我们调用一个generator时，代码并没有开始执行，其原因我们会在之后讲述，我们将手动地遍历它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params">arg</span>) </span>&#123; &#125;  <span class="comment">// generator function  </span></span><br><span class="line"><span class="keyword">var</span> bar = foo(<span class="number">123</span>);      <span class="comment">// iterator  object</span></span><br></pre></td></tr></table></figure>
<p>通过它返回的对象<code>bar</code>，我们可以遍历这个函数。为了开始并且迭代到下一个generator步骤我们可以简单的调用<code>bar</code>的<code>next()</code>方法，当<code>next()</code>被调用时，函数开始执行，或从上一次停止的地方执行，直到它到达一个暂停点。</p>
<p>但是除了继续，它也返回一个对象，该对象给予有关generator的信息。它有一个<code>value</code>属性，标识当我们暂停generator时当前迭代的值。另外一个布尔值是<code>done</code>，它用来标识generator已经结束执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params">arg</span>) </span>&#123; <span class="keyword">return</span> arg &#125;  </span><br><span class="line"><span class="keyword">var</span> bar = foo(<span class="number">123</span>);  </span><br><span class="line">bar.next();          <span class="comment">// &#123; value: 123, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>像我们看到的那样，实际上示例那里并没有任何暂停，因此当它返回一个对象的时候<code>done</code>就变成了<code>true</code>。如果你在generator中指定一个return值，它会在最后一个迭代对象（当<code>done</code>是<code>true</code>的时候）中被返回。现在我们要做的只是来暂停一个generator。和我们所说的那样，它就像是遍历一个函数并且在每个迭代周期它产出（yield）一个值（在我们暂停的地方），因此我们使用<code>yield</code>关键词进行暂停。</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><pre><code>yield [[expression]];
</code></pre><p>调用<code>next()</code>会使generator开始执行并且它会运行直到遇到一个<code>yield</code>。然后它返回一个带有<code>value</code>和<code>done</code>属性的对象，这里<code>value</code>持有表达式的值。该表达式可以是任何形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar =  foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.next());    <span class="comment">// &#123; value: 0, done: false &#125;  </span></span><br><span class="line"><span class="built_in">console</span>.log(bar.next());    <span class="comment">// &#123; value: 1, done: false &#125;  </span></span><br><span class="line"><span class="built_in">console</span>.log(bar.next());    <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>当我们再一次调用<code>next()</code>时，<em>yield值</em>会在generator中返回并且它会继续执行。也可以在generator中从<em>迭代对象</em>接受一个值（使用<code>next(val)</code>），然后当它geneator继续时它会被返回到generator中。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果你在迭代对象的值中发现了错误，你可以使用<code>throw()</code>方法并在generator中捕获这个错误。这使得错误处理在generator中是非常友好的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    x = <span class="keyword">yield</span> <span class="string">'asd B'</span>;   <span class="comment">// Error will be thrown</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar =  foo();  </span><br><span class="line"><span class="keyword">if</span> (bar.next().value == <span class="string">'B'</span>) &#123;  </span><br><span class="line">  bar.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"it's B!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-…-of"><a href="#for-…-of" class="headerlink" title="for … of"></a>for … of</h2><p>在ES6中有一个循环类别，可以用来在generator中进行遍历，即<code>for...of</code>循环。该遍历器会进行执行直到<code>done</code>是<code>false</code>。留意一点，如果你使用这个循环，你将无法在一个<code>next()</code>的调用中中传递值，并且该循环会抛弃返回值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (v <span class="keyword">of</span> foo()) &#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="yeild"><a href="#yeild" class="headerlink" title="yeild *"></a>yeild *</h2><p>如之前所说，你可以yield几乎任何东西，甚至可以yield一个generator，但是那样你就必须使用<code>yield *</code>，这被称为代理。你正在代理到另一个generator上，因此你可以使用一个迭代对象对多个generator进行遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>; </span><br><span class="line">  <span class="keyword">yield</span> *bar();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'c'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (v <span class="keyword">of</span> foo()) &#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Thunks"><a href="#Thunks" class="headerlink" title="Thunks"></a>Thunks</h2><p>为了完全理解Koa，thunks是另外一种你必须掌握的概念。它们主要用来帮助调用另外一个函数。你可以把它和<em>lazy evaluation</em>联系起来。对我们来说，最重要的是它们可以用来在一个函数调用的外部从参数列表中移动node的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> read = <span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'fs'</span>).readFile(file, cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(<span class="string">'package.json'</span>)(<span class="function"><span class="keyword">function</span> (<span class="params">err, str</span>) </span>&#123; &#125;)</span><br></pre></td></tr></table></figure>
<p>有一个小型的模块叫做<a href="https://github.com/visionmedia/node-thunkify" target="_blank" rel="external">thunkify</a>，它将一个普通的node函数转化为一个thunk。你可以质疑它的使用，但是其结果是它可以很好的移除generator中的回调。</p>
<p>首先，我们需要将想要在generator中使用的node函数装换为一个<em>thunk</em>。然后在generator中使用这个thunk，就像它会返回一个值一样，否则我们就必须进入到回调中了。当调用起始<code>next()</code>时，它的value会是一个函数，它的参数是<em>被thunkified的</em>函数的回调。在回调中我们可以检验错误（并且进行<code>throw</code>，如果需要的话）或者用接收到的值调用<code>next()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);  </span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);  </span><br><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> read(<span class="string">'input.txt'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gen = bar();  </span><br><span class="line">gen.next().value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (err) gen.throw(err);</span><br><span class="line">  gen.next(data.toString());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>慢慢花时间了解这个例子的每一个细节，因为这对于理解Koa非常重要。如果你专注于示例的generator部分，你会看到它非常棒。它有同步代码的简洁，优秀的错误捕获，而它仍然是异步执行的。</p>
<h2 id="待续…"><a href="#待续…" class="headerlink" title="待续…"></a>待续…</h2><p>最后的例子看起来很繁琐，但是在下一部分我们会找到一些工具来处理繁琐的部分，仅剩优美的部分。并且我们最终会明白Koa以及它流畅的机制，正事该机制使得web开发如此简单。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#开始使用Koa，第一部分 - Generators （译）&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.risingstack.com/introduction-to-koa-generators/&quot; target=&quot;_blank&quot; rel=&quot;ext
    
    </summary>
    
    
      <category term="translation" scheme="http://nnabuuu.github.io/blog-hexo/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>火焰中的Nodejs</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/11/24/Nodejs-in-flames/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/11/24/Nodejs-in-flames/</id>
    <published>2014-11-25T06:53:21.000Z</published>
    <updated>2016-04-29T18:43:51.165Z</updated>
    
    <content type="html"><![CDATA[<p>#火焰中的Nodejs</p>
<p>原文链接：<a href="http://techblog.netflix.com/2014/11/nodejs-in-flames.html" target="_blank" rel="external">http://techblog.netflix.com/2014/11/nodejs-in-flames.html</a></p>
<p>我们一直在忙于用Node.js构建我们的下一代Netflix.com网络应用。你可以从我们几个月前放在NodeConf.eu的<a href="https://www.youtube.com/watch?v=gtjzjiTI96c&amp;list=PLfXiENmg6yyUpIVY9XVOkbdmBPx6PUm9_" target="_blank" rel="external">这个演讲</a>中了解更多。今天，我想要分享一些我们在新应用栈的性能调优中学到的一些东西。</p>
<p>我们首先得知了一个可能的问题，当我们注意到我们的Node.js应用中的请求延迟会随时间逐渐增加。并且，应用比起我们的期望消耗了更多的CPU，并且CPU消耗的增长与更高的延迟是密切相关的。我们一边使用循环重启的方式作为一个临时解决方案，一边努力地在我们Linux EC2环境中使用新的性能检测工具与技术想要找到问题的根源。</p>
<p>##火焰上升</p>
<p>我们留意到我们的Node.js应用请求延迟随着时间慢慢增长。特别的，一些方法的延迟会从刚开始时的1ms每小时增加到10ms。并且我们也发现了相关的CPU使用率的增长。</p>
<p><img src="https://raw.githubusercontent.com/nnabuuu/blog-hexo/gh-pages/img/nodejs-in-flames/skitch.png" alt="skitch.png"></p>
<p>这幅图描绘了对于每个时间区域的请求延迟（以ms为单位）。每种颜色和一个不同的AWS AZ相关。你可以看到延迟稳定地以每小时10ms的速度增长，在实例重启之前能达到60ms的峰值。</p>
<p>##浇灭火焰</p>
<p>最初我们猜想我们自己的request handler里面有一些错误，比如memory leak，因此导致了延迟的增长。我们通过对应用单独的压力测试尝试验证这一猜想，增加了一些系统变量监控：既有我们的request handler单独的延迟，也有整个request的延迟。同时，我们将Node.js的heap size增加到32Gb。</p>
<p>我们发现我们的request handler的延迟在整个性能测试的周期中都是一个常量1ms。我们同时也看到进程的heap size处在约1.2Gb的常量中。但是，整体的request延迟和CPU使用率持续的增长。这宣告了我们自己的handler无罪，并且将问题指向了更深处。</p>
<p>有一些其他的东西消耗了额外的60ms来处理这个request。我们所需要的是一个方法来描述应用的CPU使用率并且将其可视化以便识别我们在哪里部分我们消耗了CPU绝大多数的时间。进入CPU火焰图和Linux <a href="https://perf.wiki.kernel.org/index.php/Main_Page" target="_blank" rel="external">Perf Events</a>来进行急救。</p>
<p>对于这些不熟悉火焰图的人，最好的了解方式是阅读Brendan Gregg的<a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html" target="_blank" rel="external">精彩的文章</a>，这篇文章解释了它们是什么 - 这里我们给出一个快速的总结（从文章中直接提取）。</p>
<ul>
<li>每一个方块表示一个stack中的函数（一个”stack框架”）</li>
<li>y轴显示的是stack深度（stack中的框架数量）。最上层的方块显示了当前在CPU的函数。其下面的所有都是它的祖先，紧贴着它下面的是它的父函数，就像我们之前看到的stack trace一样。</li>
<li>x轴显示的是样例群体。它并不是像绝大多数图片那样从左到右的显示时间流逝。它们的左右顺序不表示任何含义（仅仅是按照字母表顺序排列）。</li>
<li>如果有多个CPU并行执行和采样的话，样本数量可能超过所耗时间。</li>
<li>颜色并不明显，它们是随机选择成为暖色调。它被成为“火焰图”是因为它显示了现在CPU什么更”hot”。并且它是可交互的，鼠标放置于SVG之上可以看到细节。</li>
</ul>
<p>之前的Node.js火焰图只被用在使用了DTrace的系统上，使用Dave Pacheco的<a href="http://dtrace.org/blogs/dap/2012/04/25/profiling-node-js/" target="_blank" rel="external">Node.js jstack()支持</a>。然而，最近Google v8组添加了v8的perf_events支持，它包含Linux上类似的Javascript symbol。Brendan写了关于如何使用这个新支持特性的指南，在Node.js版本0.11.13中到来。<a href="http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html" target="_blank" rel="external">在Linux中创建Node.js火焰图</a>。</p>
<p><img src="https://raw.githubusercontent.com/nnabuuu/blog-hexo/gh-pages/img/nodejs-in-flames/flame.png" alt="flame.png"></p>
<p>这里是火焰图的<a href="http://cdn.nflximg.com/ffe/siteui/blog/yunong/200mins.svg" target="_blank" rel="external">原始SVG</a>。我们立刻就注意到在我们的应用中有一些非常高的stack（y轴），我们也能看到我们耗费了非常多的时间在这些stack上（x轴）。更进一步的研究发现，看起来这些stack框全是对Express.js的router handle以及router handle.next函数的引用。Express.js的源代码中我们看到了一些有趣的“花边新闻”。</p>
<ul>
<li>所有endpoint的Route handler都储存在<strong>一个全局</strong>的数组中</li>
<li>Express.js通过递归的方式进行遍历并调用这些handler直到它发现正确的路由handler</li>
</ul>
<p>对于这种应用场景，一个全局数组并不是一个理想的数据结构。我们不清楚为什么Express.js不选择使用一个常量时间的数据结构例如map来保存它的handler。每个请求都需要在路由数组中进行昂贵的O(n)查找以便发现它的route handler。更为复杂的是，数组是通过递归进行遍历的。这也就解释了为什么我们会在火焰图中看到如此高的stack。有趣的是，Express。js甚至允许你对一个路由设置很多相同的route handler。你可能不经意地将将请求链设置成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c, c, c, c, d, e, f, g, h]</span><br></pre></td></tr></table></figure>
<p>对于路由c的请求会在第一次发现c handler时停止（数组的位置2）。但是对于路由d 的请求会在位置6处停止，在轮询a,b以及非常多的c之间无用地耗费了时间。我们通过执行下面的纯express应用来验证它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">'/foo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.send(<span class="string">'hi'</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// add a second foo route handler</span></span><br><span class="line">app.get(<span class="string">'/foo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.send(<span class="string">'hi2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'stack'</span>, app._router.stack);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>执行该Express.js应用来返回这些route handler。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stack [ &#123; keys: [], regexp: <span class="regexp">/^\/?(?=/</span>|$)/i, handle: [<span class="built_in">Function</span>: query] &#125;,</span><br><span class="line"> &#123; keys: [],</span><br><span class="line">   regexp: <span class="regexp">/^\/?(?=/</span>|$)/i,</span><br><span class="line">   handle: [<span class="built_in">Function</span>: expressInit] &#125;,</span><br><span class="line"> &#123; keys: [],</span><br><span class="line">   regexp: <span class="regexp">/^\/foo\/?$/i</span>,</span><br><span class="line">   handle: [<span class="built_in">Function</span>],</span><br><span class="line">   route: &#123; path: <span class="string">'/foo'</span>, stack: [<span class="built_in">Object</span>], methods: [<span class="built_in">Object</span>] &#125; &#125;,</span><br><span class="line"> &#123; keys: [],</span><br><span class="line">   regexp: <span class="regexp">/^\/foo\/?$/i</span>,</span><br><span class="line">   handle: [<span class="built_in">Function</span>],</span><br><span class="line">   route: &#123; path: <span class="string">'/foo'</span>, stack: [<span class="built_in">Object</span>], methods: [<span class="built_in">Object</span>] &#125; &#125; ]</span><br></pre></td></tr></table></figure>
<p>注意到这里对/foo有两个完全一样的route handler。如果Express.js在对于一个路由有多余一个route handler时可以抛出一个异常就好了。</p>
<p>到现在为止，我们主要的猜想变成了handler数组随着时间在增长，由于每个handler都被调用，因此导致了延迟的增长。极有可能我们在代码中的某处泄露了handler，可能是由于重复handler问题导致的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[...</span><br><span class="line">&#123; handle: [<span class="built_in">Function</span>: serveStatic],</span><br><span class="line">   name: <span class="string">'serveStatic'</span>,</span><br><span class="line">   params: <span class="literal">undefined</span>,</span><br><span class="line">   path: <span class="literal">undefined</span>,</span><br><span class="line">   keys: [],</span><br><span class="line">   regexp: &#123; <span class="regexp">/^\/?(?=\/|$)/i</span> fast_slash: <span class="literal">true</span> &#125;,</span><br><span class="line">   route: <span class="literal">undefined</span> &#125;,</span><br><span class="line"> &#123; handle: [<span class="built_in">Function</span>: serveStatic],</span><br><span class="line">   name: <span class="string">'serveStatic'</span>,</span><br><span class="line">   params: <span class="literal">undefined</span>,</span><br><span class="line">   path: <span class="literal">undefined</span>,</span><br><span class="line">   keys: [],</span><br><span class="line">   regexp: &#123; <span class="regexp">/^\/?(?=\/|$)/i</span> fast_slash: <span class="literal">true</span> &#125;,</span><br><span class="line">   route: <span class="literal">undefined</span> &#125;,</span><br><span class="line"> &#123; handle: [<span class="built_in">Function</span>: serveStatic],</span><br><span class="line">   name: <span class="string">'serveStatic'</span>,</span><br><span class="line">   params: <span class="literal">undefined</span>,</span><br><span class="line">   path: <span class="literal">undefined</span>,</span><br><span class="line">   keys: [],</span><br><span class="line">   regexp: &#123; <span class="regexp">/^\/?(?=\/|$)/i</span> fast_slash: <span class="literal">true</span> &#125;,</span><br><span class="line">   route: <span class="literal">undefined</span> &#125;,</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>有些东西在以10次每小时的速度添加同样的Express.js静态route handler中。更进一步的基准测试显示了仅仅是遍历每一个handler耗费约1ms的CPU时间。这和我们所见的延迟问题是相关联的，我们看到的响应时间的增加是每小时10ms。</p>
<p>最终结果是：它是由我们代码中的一个周期性函数（10次/小时）导致的。其主要的目的是为了从一个外部源刷新我们的route handler。它是通过从数组中删除旧的handler并添加新的handler来实现的。不幸地是，它在每次执行时也在不经意间增加了一个同样路径的静态route handler。由于Express.js允许对同一路径含有多个route handler，这些重复的handler被全部添加进了数组中。更糟糕的是，它们是被添加到了其他API handler的前面，这表示在任何我们server的请求被执行之前，它们全部都会被调用到。</p>
<p>这完全解释了为什么我们的清秋延迟是以每小时10ms的速度增长的。事实上，当我们修复代码使之停止添加重复route handler之后，我们的延迟以及CPU使用率的增长都消失了。</p>
<p><img src="https://raw.githubusercontent.com/nnabuuu/blog-hexo/gh-pages/img/nodejs-in-flames/graph.png" alt="graph.png"></p>
<p>现在，在我们部署了修复代码之后，我们的延迟降低到了1ms并且能够一直保持了。</p>
<h2 id="当烟雾散去"><a href="#当烟雾散去" class="headerlink" title="当烟雾散去"></a>当烟雾散去</h2><p>我们从这个悲惨的经验中学到了什么呢？首先，在我们将依赖对象放入生产环境之前，我们必须完全的了解它。我们对Express.js的API进行了错误的假设而没有深度到代码基础中。结果，我们错误的使用了Express.js的API就是我们最终性能问题的根源。</p>
<p>第二，在处理性能问题时，可观察性是至关重要的。火焰图使我们能够洞察到我们的应用程序在哪部分花费了最多的时间在CPU上。难以想象在没有能够对Node.js的stack进行采样以及用火焰图可视化他们的条件下我们该如何解决这个问题。</p>
<p>为了进一步提高可观察性，我们迁移到了Restify，它给了我们更多的同茶行，可见性以及对我们应用程序的操作性。这已经超出了本文的范围，因此请期待我们之后关于如何在Netlix中利用Node.js文章。</p>
<p>本文原作者: Yunong Xiao <a href="https://twitter.com/YunongX" target="_blank" rel="external">@yunongx</a></p>
<h4 id="脚注："><a href="#脚注：" class="headerlink" title="脚注："></a>脚注：</h4><p>1 特别的，注意在这个<a href="https://github.com/strongloop/express/blob/d40dc65/lib/router/route.js#L81-L102" target="_blank" rel="external">代码片段</a>中，next()被递归地调用来遍历名为stack的全局route handler数组。</p>
<p>2 Restify提供了非常多的机制以获取你的应用的可见性。从<a href="http://mcavage.me/presentations/dtrace_conf_2012-04-03/" target="_blank" rel="external">DTrace</a>支持，到与<a href="https://github.com/trentm/node-bunyan" target="_blank" rel="external">node-bunyan</a>日志框架集成。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#火焰中的Nodejs&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://techblog.netflix.com/2014/11/nodejs-in-flames.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://techblo
    
    </summary>
    
    
      <category term="Translation" scheme="http://nnabuuu.github.io/blog-hexo/tags/Translation/"/>
    
  </entry>
  
  <entry>
    <title>神经网络骇客指南（翻译中）</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/11/16/Hackers-guide-to-Neural-Networks/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/11/16/Hackers-guide-to-Neural-Networks/</id>
    <published>2014-11-16T21:51:07.000Z</published>
    <updated>2016-04-29T18:43:51.164Z</updated>
    
    <content type="html"><![CDATA[<p>原文见：<a href="http://karpathy.github.io/neuralnets/" target="_blank" rel="external">http://karpathy.github.io/neuralnets/</a></p>
<p>##神经网络骇客指南（译）</p>
<p>各位好，我是一名<a href="http://cs.stanford.edu/people/karpathy/" target="_blank" rel="external">斯坦福的计算机科学的博士</a>。作为我研究的一部分，我已经在深度学习上研究了好几年，我有几个“pet project”，其中一个是<a href="http://convnetjs.com/" target="_blank" rel="external">ConvNetJS</a> - 一个用来训练神经网络的Javascript库。Javascript允许一个人轻松地将现在所发生的事情可视化，并且可以实现多样的参数选择设置，但是我仍然经常听到人们想要一些更加彻底的话题。这篇文章（我打算慢慢地写到几个章节那么长）是我一份谦逊地尝试。我把它放在网上而不是以一个PDF文件的形式呈现是因为，所有的图书都应该这样，并且最终希望它能包括一些动画和演示。</p>
<p>我对神经网络的个人经验是：当我抛开一切整篇、密集的反向传播方程的推导，而仅仅开始写代码时，一切都清晰多了。因此这个教程会包含<strong>非常少的数学</strong>(我不认为这是有必要的，而且有些时候会混淆一些简单的概念)。由于我的背景是计算机科学以及物理，我会以<strong>骇客的角度</strong>来看待问题。我会围绕着代码以及物理直觉而不是数学推导来展示。基本上我会以一种“我刚开始学习时希望被那样教导”的方式努力地呈现算法。</p>
<pre><code>“...当我开始编写代码时一切都清晰多了。”
</code></pre><p>你可能会想急切地跳进去学习神经网络、反向传播、它们如何能应用于数据集上、等等。但是在我们到达那里之前，我想先让我们忘掉这一切。让我们后退一步，明白什么是真正的核心。让我们从元电路开始谈起。</p>
<p>###第一章：元电路</p>
<p>在我看来，思考神经网络的最佳方式是将其比作元电路。在这里，实际的值（而不是布尔值<code>{0,1}</code>）沿着边沿“流动”并且在门出交汇。但是不同于门电路的<code>与</code>、<code>或</code>、<code>非</code>等，我们的二进制门包含例如<code>*</code>（乘）、<code>+</code>（加）、<code>max</code>或者一元门例如<code>exp</code>等等。不同于基本的布尔电路，我们最终也会有<strong>gradients</strong>在同样的边沿流动，但是是向相反的方向。这已经有点超前了，我们还是先专注一下，从简单的开始。</p>
<h4 id="基本情况：电路中的单门"><a href="#基本情况：电路中的单门" class="headerlink" title="基本情况：电路中的单门"></a>基本情况：电路中的单门</h4><p>让我们先考虑一个单一的、简单的、包含一个门的电路。示例如下：</p>
<p><img src="/img/Hacker-s-guide-to-Neural-Networks/1.png" alt="simple circuit with one gate"></p>
<p>这个电路接受两个实际值<code>x</code>和<code>y</code>并且在<code>*</code>门中计算<code>x * y</code>。 Javascript的版本会非常简单，看起来像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> forwardMultiplyGate = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line">forwardMultiplyGate(<span class="number">-2</span>, <span class="number">3</span>); <span class="comment">// returns -6. Exciting.</span></span><br><span class="line"><span class="string">``</span><span class="string">`	</span><br><span class="line">以数学的形式我们可以认为这个门实现了函数：</span><br><span class="line"></span><br><span class="line">	f(x, y) = x * y</span><br><span class="line"></span><br><span class="line">在这个例子中，我们所有的门都会接受一个或两个输入，并产生一个**单一**的输出值。</span><br><span class="line"></span><br><span class="line">##### 目标</span><br><span class="line"></span><br><span class="line">我们在学习时所感兴趣的问题看起来像下面这样：</span><br><span class="line"></span><br><span class="line">1.	我们为一个已知电路提供一些具体的输入（例如 `</span>x = <span class="number">-2</span><span class="string">`，`</span>y = <span class="number">3</span><span class="string">`）</span><br><span class="line">2.	电路计算出一个输出值（例如 `</span><span class="number">-6</span><span class="string">`）</span><br><span class="line">3.	那么问题的核心变为：我们如何轻微的改变输入以便增加输出？</span><br><span class="line"></span><br><span class="line">在这个例子中，我们应该向什么方向改变`</span>x,y<span class="string">`以便得到一个比`</span><span class="number">-6</span><span class="string">`更大的数字呢？注意到，例如`</span>x = <span class="number">-1.99</span><span class="string">`以及`</span>y = <span class="number">2.99</span><span class="string">`时`</span>x * y = <span class="number">-5.95</span><span class="string">` 这是一个比`</span><span class="number">-6.0</span><span class="string">`更大的数。别被它搞晕了：`</span><span class="number">-5.95</span><span class="string">`是比`</span><span class="number">-6.0</span><span class="string">`更大的。这个增量为`</span><span class="number">0.05</span><span class="string">`，尽管`</span><span class="number">-5.95</span><span class="string">`的大小（到0的距离）更小一些。</span><br><span class="line"></span><br><span class="line">##### 策略#1：本地随机搜索</span><br><span class="line"></span><br><span class="line">好，等一下，现在我们有一个电路，我们有一些输入并且我们希望轻微地改变它们以便增加输出？为什么这个很难？我们可以简单的“转发”电路来计算对于任何给定的`</span>x<span class="string">`和`</span>y<span class="string">`的输出，所以这不是很简单吗？我们为什么不随机调整`</span>x<span class="string">`和`</span>y<span class="string">`来跟踪效果最好的策略呢：</span><br><span class="line">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// circuit with single gate for now</span></span><br><span class="line"><span class="keyword">var</span> forwardMultiplyGate = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x * y; &#125;;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">-2</span>, y = <span class="number">3</span>; <span class="comment">// some input values</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// try changing x,y randomly small amounts and keep track of what works best</span></span><br><span class="line"><span class="keyword">var</span> tweak_amount = <span class="number">0.01</span>;</span><br><span class="line"><span class="keyword">var</span> best_out = -<span class="literal">Infinity</span>;</span><br><span class="line"><span class="keyword">var</span> best_x = x, best_y = y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++) &#123;</span><br><span class="line">  <span class="keyword">var</span> x_try = x + tweak_amount * (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>); <span class="comment">// tweak x a bit</span></span><br><span class="line">  <span class="keyword">var</span> y_try = y + tweak_amount * (<span class="built_in">Math</span>.random() * <span class="number">2</span> - <span class="number">1</span>); <span class="comment">// tweak y a bit</span></span><br><span class="line">  <span class="keyword">var</span> out = forwardMultiplyGate(x_try, y_try);</span><br><span class="line">  <span class="keyword">if</span>(out &gt; best_out) &#123;</span><br><span class="line">    <span class="comment">// best improvement yet! Keep track of the x and y</span></span><br><span class="line">    best_out = out; </span><br><span class="line">    best_x = x_try, best_y = y_try;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我执行它时，我的到了<code>best_x = -1.9928</code>，<code>best_y = 2.9901</code>，以及<code>best_out = -5.9588</code>。因为<code>-5.9588</code>比<code>-6.0</code>更大，所以我们就搞定了，是吗？并不是这样：如果你能负担得起时间的话，它对于仅包含几个门的微小的问题来说是一个完美的策略。但是对于接受上百万输入的大量的电路来说，并非如此。结果是，我们可以做的更好。</p>
<h5 id="策略-2：数值梯度"><a href="#策略-2：数值梯度" class="headerlink" title="策略#2：数值梯度"></a>策略#2：数值梯度</h5><p>这里就有一个更好的方法。再次记住，在我们前期我们被提供了一个电路（例如，我们的电路是一个单一的<code>*</code>门）和一些特殊的输入（例如<code>x = -2, y = 3</code>）。门会计算出结果(<code>-6</code>)，而现在我们希望对<code>x</code>和<code>y</code>进行微调以便得到更高的输出。</p>
<p>对于我们接下来要做的事情，一个很棒的直觉是这样：想象一下获取来自于门电路的输出值输出值，并且对其正向加压。正向电压会反过来通过们进行传输并且引起对输入<code>x</code>和<code>y</code>的推动。这个推动就告诉了我们应该如何改变<code>x</code>和<code>y</code>以便增加输出值。</p>
<p>在我们这个特定的例子中，这个推动力可能是什么样子的呢？考虑一下，我们可以凭直觉知道施加在<code>x</code>上的力应该是正向的，因为使<code>x</code>轻微地增大会增加电路的输出。例如，将<code>x</code>从<code>x = -2</code>增加到<code>x = -1</code>会使我们得到<code>-3</code> - 远大于<code>-6</code>。在另一方面，我们会希望在<code>y</code>上施加负向的力，而使它变得更小(因为更小的<code>y</code>，例如从<code>y = 3</code>降到<code>y = 2</code>会使我们的结果更高：<code>2 * -2 = -4</code>，同样比<code>-6</code>更大)。但这毕竟是我们脑中的直觉。随着我们的深入，我们会了解到，我这里提到的牵引力实际上是基于输入值(<code>x</code>和<code>y</code>)的<strong>导数</strong>输出值。你可以已经听说过这些：</p>
<pre><code>导数可以被认为是一种施加于各个输入值的力，用于使输出变得更高。
</code></pre><p>所以我们如何来精确地评价这个牵引力（导数）呢？实际上有一个非常简单的方法。我们反向地来操作：不同于增加电路的输出值，我们一个接一个地迭代每个输入值，轻微地增加它并检测输出值如何改变。输出的改变就是导数。尽管我们到现在为止还是凭借直觉。我们还是看一下数学定义。我们可以写出函数关于某个输入的导数，例如对<code>x</code>的导数可以写成：</p>
<div><br><span class="MathJax_Preview"></span><div class="MathJax_Display" role="textbox" aria-readonly="true" style="text-align: center;"><span class="MathJax" id="MathJax-Element-2-Frame"><nobr><span class="math" id="MathJax-Span-12" style="width: 15.419em; display: inline-block;"><span style="display: inline-block; position: relative; width: 12.815em; height: 0px; font-size: 120%;"><span style="position: absolute; clip: rect(0.992em 1000.003em 3.336em -0.466em); top: -2.497em; left: 0.003em;"><span class="mrow" id="MathJax-Span-13"><span class="mfrac" id="MathJax-Span-14"><span style="display: inline-block; position: relative; width: 3.076em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;"><span style="position: absolute; clip: rect(1.669em 1000.003em 2.867em -0.414em); top: -3.174em; left: 50%; margin-left: -1.456em;"><span class="mrow" id="MathJax-Span-15"><span class="mi" id="MathJax-Span-16" style="font-family: STIXGeneral-Regular;">∂</span><span class="mi" id="MathJax-Span-17" style="font-family: STIXGeneral-Italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.159em;"></span></span><span class="mo" id="MathJax-Span-18" style="font-family: STIXGeneral-Regular;">(</span><span class="mi" id="MathJax-Span-19" style="font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-20" style="font-family: STIXGeneral-Regular;">,</span><span class="mi" id="MathJax-Span-21" style="font-family: STIXGeneral-Italic; padding-left: 0.211em;">y</span><span class="mo" id="MathJax-Span-22" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.503em;"></span></span><span style="position: absolute; clip: rect(1.669em 1000.003em 2.659em -0.414em); top: -1.82em; left: 50%; margin-left: -0.466em;"><span class="mrow" id="MathJax-Span-23"><span class="mi" id="MathJax-Span-24" style="font-family: STIXGeneral-Regular;">∂</span><span class="mi" id="MathJax-Span-25" style="font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span></span><span style="display: inline-block; width: 0px; height: 2.503em;"></span></span><span style="position: absolute; clip: rect(0.836em 1000.003em 1.201em -0.466em); top: -1.247em; left: 0.003em;"><span style="border-left-width: 3.076em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.25px; vertical-align: 0.003em;"></span><span style="display: inline-block; width: 0px; height: 1.044em;"></span></span></span></span><span class="mo" id="MathJax-Span-26" style="font-family: STIXGeneral-Regular; padding-left: 0.315em;">=</span><span class="mfrac" id="MathJax-Span-27" style="padding-left: 0.315em;"><span style="display: inline-block; position: relative; width: 7.971em; height: 0px; margin-right: 0.107em; margin-left: 0.107em;"><span style="position: absolute; clip: rect(1.669em 1000.003em 2.867em -0.622em); top: -3.174em; left: 50%; margin-left: -3.904em;"><span class="mrow" id="MathJax-Span-28"><span class="mi" id="MathJax-Span-29" style="font-family: STIXGeneral-Italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.159em;"></span></span><span class="mo" id="MathJax-Span-30" style="font-family: STIXGeneral-Regular;">(</span><span class="mi" id="MathJax-Span-31" style="font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-32" style="font-family: STIXGeneral-Regular; padding-left: 0.263em;">+</span><span class="mi" id="MathJax-Span-33" style="font-family: STIXGeneral-Italic; padding-left: 0.263em;">h</span><span class="mo" id="MathJax-Span-34" style="font-family: STIXGeneral-Regular;">,</span><span class="mi" id="MathJax-Span-35" style="font-family: STIXGeneral-Italic; padding-left: 0.211em;">y</span><span class="mo" id="MathJax-Span-36" style="font-family: STIXGeneral-Regular;">)</span><span class="mo" id="MathJax-Span-37" style="font-family: STIXGeneral-Regular; padding-left: 0.263em;">−</span><span class="mi" id="MathJax-Span-38" style="font-family: STIXGeneral-Italic; padding-left: 0.263em;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.159em;"></span></span><span class="mo" id="MathJax-Span-39" style="font-family: STIXGeneral-Regular;">(</span><span class="mi" id="MathJax-Span-40" style="font-family: STIXGeneral-Italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-41" style="font-family: STIXGeneral-Regular;">,</span><span class="mi" id="MathJax-Span-42" style="font-family: STIXGeneral-Italic; padding-left: 0.211em;">y</span><span class="mo" id="MathJax-Span-43" style="font-family: STIXGeneral-Regular;">)</span></span><span style="display: inline-block; width: 0px; height: 2.503em;"></span></span><span style="position: absolute; clip: rect(1.669em 1000.003em 2.659em -0.466em); top: -1.82em; left: 50%; margin-left: -0.258em;"><span class="mi" id="MathJax-Span-44" style="font-family: STIXGeneral-Italic;">h</span><span style="display: inline-block; width: 0px; height: 2.503em;"></span></span><span style="position: absolute; clip: rect(0.836em 1000.003em 1.201em -0.466em); top: -1.247em; left: 0.003em;"><span style="border-left-width: 7.971em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.25px; vertical-align: 0.003em;"></span><span style="display: inline-block; width: 0px; height: 1.044em;"></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 2.503em;"></span></span></span><span style="border-left-width: 0.003em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 2.566em; vertical-align: -0.872em;"></span></span></nobr></span></div><script type="math/tex; mode=display" id="MathJax-Element-2"><br>\frac{\partial f(x,y)}{\partial x} = \frac{f(x+h,y) - f(x,y)}{h}<br></script><br></div>

<p>在这里，h是非常小的，这是你改变的总量。并且，如果你不太熟悉计算的话，必须要注意的是，在等式的左边，横线<strong>并不</strong>表示除法。这个符号∂f(x,y)/∂x是一个整体：函数 f(x,y) 对x的编导。等式右边的横线表示除法。我知道这非常让人迷惑，但这是一个标准符号。无论怎样，我希望这并没有太吓人，因为它的确很简单：电路被赋予一些f(x,y)的初始值，然后我们将其中的一个输入改变一个非常小的量h，并且获取新的输出f(x+h,y)。将二者相减我们能得到改变量，然后除以h我们就得到了对于任意改变量的标准量。从另一方面说，下面的代码这正反应了我上面阐述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">-2</span>, y = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> out = forwardMultiplyGate(x, y); <span class="comment">// -6</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="number">0.0001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute derivative with respect to x</span></span><br><span class="line"><span class="keyword">var</span> xph = x + h; <span class="comment">// -1.9999</span></span><br><span class="line"><span class="keyword">var</span> out2 = forwardMultiplyGate(xph, y); <span class="comment">// -5.9997</span></span><br><span class="line"><span class="keyword">var</span> x_derivative = (out2 - out) / h; <span class="comment">// 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compute derivative with respect to y</span></span><br><span class="line"><span class="keyword">var</span> yph = y + h; <span class="comment">// 3.0001</span></span><br><span class="line"><span class="keyword">var</span> out3 = forwardMultiplyGate(x, yph); <span class="comment">// -6.0002</span></span><br><span class="line"><span class="keyword">var</span> y_derivative = (out3 - out) / h; <span class="comment">// -2.0</span></span><br></pre></td></tr></table></figure>
<p>让我们对<code>x</code>进行研究，我们将输入从<code>x</code>变为<code>x + h</code>，然后电路反馈</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文见：&lt;a href=&quot;http://karpathy.github.io/neuralnets/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://karpathy.github.io/neuralnets/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##神经网
    
    </summary>
    
    
      <category term="translation" scheme="http://nnabuuu.github.io/blog-hexo/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>拥抱JavaScript中的异步2（译）</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/11/14/embracing-async-in-javascript-part-2/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/11/14/embracing-async-in-javascript-part-2/</id>
    <published>2014-11-14T19:01:29.000Z</published>
    <updated>2016-04-29T18:43:51.173Z</updated>
    
    <content type="html"><![CDATA[<p>#拥抱JavaScript中的异步2（译）<br><a href="https://twitter.com/whitehouse3001" target="_blank" rel="external">Andy White</a></p>
<p>##本系列的上一期</p>
<ul>
<li><a href="http://io.pellucid.com/blog/embracing-async-in-javascript-part-1" target="_blank" rel="external">拥抱JavaScript中的异步1</a> </li>
<li>译文：<a href="http://nnabuuu.github.io/blog-hexo/2014/10/07/embracing-async-in-javascript-part-1/">http://nnabuuu.github.io/blog-hexo/2014/10/07/embracing-async-in-javascript-part-1/</a></li>
</ul>
<p>##简介</p>
<p>在之前的文章中（第一部分），我简要的讨论了一些JavaScript事件循环的基础，函数调用栈，闭包，以及一些基本的回调模式，这些内容都与异步编程相关。在本文中，我想要继续讨论更多JavaScript异步的异步话题。</p>
<p>首先，我想要回应<a href="http://www.reddit.com/r/javascript/comments/2hzu7c/embracing_async_in_javascript_part_1/ckxjauu" target="_blank" rel="external">来自Redditor的对我之前一篇文章的评论</a>，该评论拒绝“整个应用应该被构建成为一个异步运行的系统”的思想。这个评论很棒，并且我的确赞同。在我前面的文章中，我并没有在暗示你必须在普通的回调或者其他低级语言特性上构建整个应用来处理你代码中的异步API。但即使你不这样做你也会很快的在其他地方遇到异步代码，而你需要理解并且拥抱其工作方式，这样才能更好的在JavaScript上取得成功。如何拥抱异步代码完全取决于你（以及你的目标平台的支持），有非常多的资源，库，或其他内容可以来帮助你。编写异步代码比起编写同步代码需要更小心以及更多的语言/库的支持，一旦你开始在你的代码中引入异步模式，其异步性往往会不断扩张并且需要越来越多的代码以便维护其一致性以及正确的行为。JavaScript在其核心中并没有对异步代码有太多语言层面的支持，而这个现状正在由新的语言特性改善，例如<a href="http://www.html5rocks.com/en/tutorials/es6/promises/" target="_blank" rel="external">原生的promise</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="external">ES6生成器</a>，<a href="https://github.com/laverdet/node-fibers" target="_blank" rel="external">Node.js中的libers</a>或类似的库，还有数以百计的已有的异步模块以及库在类似于<a href="https://www.npmjs.org/search?q=async" target="_blank" rel="external">npm</a>的仓库中。</p>
<p>但是，在本文中，我仍然想要定位于低层次，并且谈谈更加底层的JavaScript中的异步代码模式：events和promises。</p>
<p>##Events</p>
<p>在JavaScript中的事件是一种用来在JavaScript的对象之间进行通信的公用订阅机制。事件和回调非常相似：事件的发布者为感兴趣的对象提供一种订阅方式用来在事件发生时接收通知。订阅一个事件代表注册一个回调函数，当事件发生时回调它。当事件发生时，事件发布者简单的调用其注册的任何回调函数。和回调一样，事件可以同步或异步地发生，事件监听回调也可以被同步或异步地调用。</p>
<p>JavaScript原生地将事件用在例如DOM事件的场合，例如点击、鼠标移动、表格提交，等等。即使在非浏览器环境下的JavScript中，事件也被广泛地使用：例如Node.js的EventEmitter。在Node.js中，事件也在stream中出现。</p>
<p>使用事件的主要好处在于他们可以被多个监听器所消费。当事件发生时，事件的发布者可以调用多个被注册的回调函数，因此多个对象可以被通知到。它也可以在某块之间创造松耦合，因为发布者不应该关心“什么”或者“多少”消费者订阅了自己，并且消费者不需要知道发布者内部在做些什么。</p>
<p>大多数的JavaScript框架（浏览器端或非浏览器端）都支持一些事件方式，包括jQuery、AngularJS、Backbone、React、Ember，以及之前提到的Node.js，包含各种各样的<code>EventEmitter</code>以及<code>stream</code>。</p>
<p>下面是一个简单的使用基于事件的API的示例。这个例子是用Node.js实现的，使用基本的EventEmitter模块。</p>
<pre><code>// Get the constructor function for the Node.js EventEmitter
var EventEmitter = require(&quot;events&quot;).EventEmitter;

// Clock is our event publisher - when started, it will publish a &quot;tick&quot; event 
// every second.
function Clock() {
    this.emitter = new EventEmitter();
}

// Starts the clock ticking
Clock.prototype.start = function() {
    var self = this;
    this.interval = setInterval(function() {
        self.emitter.emit(&quot;tick&quot;, new Date());
    }, 1000);
};

// Stops the clock from ticking
Clock.prototype.stop = function() {
    if (this.interval) {
        clearInterval(this.interval);
        this.interval = null;
    }
};

// Register a callback for the &quot;tick&quot; event
Clock.prototype.onTick = function(callback) {
    this.emitter.on(&quot;tick&quot;, callback);
};

// Create our clock
var clock = new Clock();

// Register an event for the clock&apos;s tick event
clock.onTick(function(date) {
    console.log(date);
});

// Start the clock
clock.start();
</code></pre><p>这个基础的Node.js程序输出类似如下：</p>
<pre><code>% node clock.js
Wed Oct 15 2014 14:08:01 GMT-0600 (MDT)
Wed Oct 15 2014 14:08:03 GMT-0600 (MDT)
Wed Oct 15 2014 14:08:04 GMT-0600 (MDT)
Wed Oct 15 2014 14:08:05 GMT-0600 (MDT)
Wed Oct 15 2014 14:08:06 GMT-0600 (MDT)
Wed Oct 15 2014 14:08:07 GMT-0600 (MDT)
Wed Oct 15 2014 14:08:08 GMT-0600 (MDT)
...repeats forever...
</code></pre><p>这里，Clock的<code>onTick</code>函数允许任意数量的对象注册回调到每一次的时间点上。在示例中，我们只注册了一个订阅者，而实际上我们可以注册更多。</p>
<p>事件是一种又用的同步或异步通信机制，但是他们本身并不有助于解决异步调用的顺寻问题，你可以使用其他的技术来帮助你，例如回调。</p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>Promise是另外一种处理JavaScript对象间异步通信的机制。在过去几年中，Promise已经在JavaScript中变得非常流行了，并且现在已经有许多Promise的实现可供挑选，包括即将到来的ECMAScript6的原生Promise实现。</p>
<p>当异步任务完成或失败时通知其他模块方面，Promise与回调十分相似，但是实现的方式与回调以及事件有一些不同。在回调中，一个异步API函数接受一个或多个函数入参，当任务结束或失败时API函数会使用它们，然而一个基于Promise的函数并不接受回调作为参数，而是返回一个其他模块可以注册完成或者失败回调的<code>Promise</code>对象。而且，另一个回调与Promise的巨大不同之处在于，Promise对象会在满足条件之后继续持有返回值或错误对象，因此其他模块可以检验Promise的状态，访问其对象，即使Promise已经完成。使用回调以及事件时，回调的调用者以及事件的发布者都不会持有最后一次的值，因此如果一个感兴趣的模块错过了一个事件，它们可能就无法检测到这个事件已经发生，也无法得知随该事件一起被发出的值是什么了。</p>
<p>当我们谈到Promise时，我们引入了一个较为具体的术语，也就是<a href="https://promisesaplus.com/" target="_blank" rel="external">Promise/A+规范</a>的描述。当然也有一些其他的Promise规范，但Promise/A+规范似乎是最流行的。网络上有非常多的Promise教学，因此我不会在这里具体讲述，而我的确想提供一个简单的示例来演示Promise是如何被用在顺序的异步函数调用上的。我将使用非常流行的、功能强大的库<a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a>来进行演示。</p>
<p>这是一个非常“刻意”的例子，但它演示了顺序的异步调用如何能和Promise一起使用。</p>
<pre><code>function begin() {
    console.log(&quot;begin&quot;);
    return 0;
}

function end() {
    console.log(&quot;end&quot;);
}

function incrementAsync(i) {
    var defer = Q.defer();

    setTimeout(function() {
        i++;
        console.log(i);
        defer.resolve(i);
    }, 0);

    return defer.promise;
}

Q.fcall(begin)
    .then(incrementAsync)
    .then(incrementAsync)
    .then(incrementAsync)
    .then(end);
</code></pre><p>这个例子的输出是：</p>
<pre><code>begin
1
2
3
end
</code></pre><p>这个例子的主要驱动方式是Q promise链，由<code>Q.fcall</code>以begin为参数开始。<code>Q.fcall</code>是一个Q提供的静态方法，用来执行所提供的函数，并返回一个值的Promise。入参函数可以返回一个Promise值也可以返回一个非Promise值，但无论哪种方式，Q将会从<code>Q.fcall</code>返回一个Promise。由于<code>Q.fcall</code>总是返回一个Promise，你可以使用<code>then</code>方法在一个Promise上链接其他函数，<code>then</code>函数是Promise的基础方法。返回一个Promise的函数通常被成为”thenable”的函数，意味着你可以使用<code>.then()</code>在它之上链接回调函数。</p>
<p>上面的第一个<code>.then</code>将<code>incrementAsync</code>函数链接到由<code>Q.fcall(begin)</code>创造的Promise中。<code>incrementAsync</code>函数接受一个数字类型的参数，设置一个超时机制来异步地增加值，然后返回一个增加完结果的值的Promise。<code>incrementAsync</code>函数创造了一个Q的<code>deferred</code>对象（使用<code>Q.defer()</code>），这个对象是Promise的“创造者”进行操作的。Promise的创造者有义务在某一个时间点满足或者拒绝这个Promise，典型的时间点就是异步调用成功或者失败的时刻。在Q里，它是通过在deferred对象上调用<code>.resolve()</code>或<code>reject()</code>实现的。在<code>incrementAsync</code>中，Promise是通过增加i来满足的，然后调用了<code>.resolve(i)</code>，也就表示这个Promise被满足了，并且提供了一个值来传递到链接的下一个函数中。传递给<code>.resolve()</code>的值被传递到链接的下一个函数中作为函数的第一个参数。在Q的Promise链中，每一个方法都可以为一个值的Promise或者朴素的值，Q会基于成功满足或拒绝的条件顺序执行执行该链。Promise不需要被一个值满足，它可以不使用任何值，仅仅表示异步调用已经成功，没有任何值来提供。</p>
<p>Promise/A+规范要求Promise总是被异步地处理，因此上面例子中的<code>setTimeout</code>实际上是多余的，我们用它只是原来强调<code>incrementAsync</code>是天然异步的。</p>
<p>Promise是有一点复杂的话题，很难在一篇文章中讲清楚，但有数不胜数的资源用以将来的学习。</p>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>JavaScript作为一种语言以及生态系统，正在迅速地发展。只有非常多激动人心的语言特性正被开发出来支持异步代码。其中最令人激动的是<a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">ES6 generator</a>，它是一种非常的强大的、JavaScript编程的新方式。我在此不会讲述这个话题，但网络上有非常多好的教程和指南。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>异步编程是JavaScript中需要理解的重要内容，并且有非常多的方式来拥抱它。对于如何处理异步代码并没有一种定论，但是理解不同的可选项是非常重要的，这样你就可以根据你的需求选取正确的解决方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#拥抱JavaScript中的异步2（译）&lt;br&gt;&lt;a href=&quot;https://twitter.com/whitehouse3001&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Andy White&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##本系列的上一期&lt;/p&gt;

    
    </summary>
    
    
      <category term="translation" scheme="http://nnabuuu.github.io/blog-hexo/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>用Stream解决编程挑战（译）</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/10/22/Solving-Coding-Challenges-with-Streams/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/10/22/Solving-Coding-Challenges-with-Streams/</id>
    <published>2014-10-23T06:32:11.000Z</published>
    <updated>2016-04-29T18:43:51.167Z</updated>
    
    <content type="html"><![CDATA[<p>#用Stream解决编程挑战（译）</p>
<p>我第一次使用Node.js解决编程挑战的经验简直是让人焦虑不已。我设计了一个切实可行的解决方法，但我却无法找到一个有效的方法来解析输入。它的格式非常的简单：文本通过stdin的pipe输入。很简单，是吧？但我一般的时间都耗费在这个小小的细节上，最终我得到了一个非常脆弱的、缝缝补补的、处处hack过的代码，这至今仍然让我感到不寒而栗。</p>
<p>这份经验激励着我找到一种管用的方式来完成编程挑战。在解决了更多问题之后我终于找到了一种我希望大家都能觉得又用的方式。</p>
<p>##模式</p>
<p>主要的思想是：创造一个problem的stream，将每一个problem转化为一个solition。这个流程由4个步骤组成：</p>
<ol>
<li>将输入打散为行的stream。</li>
<li>将这些行转化为和问题相关的数据结构</li>
<li>解决问题</li>
<li>格式化solution并输出</li>
</ol>
<p>对于那些熟悉stream的人来说，这个模式看起来像这样：</p>
<pre><code>var split = require(&quot;split&quot;); // dominictarr’s helpful line-splitting module

process.stdin
    .pipe(split()) // split input into lines
    .pipe(new ProblemStream()) // transform lines into problem data structures
    .pipe(new SolutionStream()) // solve each problem
    .pipe(new FormatStream()) // format the solutions for output
    .pipe(process.stdout); // write solution to stdout
</code></pre><p>##我们的问题</p>
<p>为了让这个教程更接地气一点，让我们来解决一个<a href="https://code.google.com/codejam/contest/2929486/dashboard" target="_blank" rel="external">Google Code Jam challenge</a>。这个问题是让我们验证数独游戏的解答。输入看起来像这样：</p>
<pre><code>2                  // number of puzzles to verify
3                  // dimensions of first puzzle (3 * 3 = 9)
7 6 5 1 9 8 4 3 2  // first puzzle
8 1 9 2 4 3 5 7 6
3 2 4 6 5 7 9 8 1
1 9 8 4 3 2 7 6 5
2 4 3 5 7 6 8 1 9
6 5 7 9 8 1 3 2 4
4 3 2 7 6 5 1 9 8
5 7 6 8 1 9 2 4 3
9 8 1 3 2 4 6 5 7
3                  // dimensions of second puzzle
7 9 5 1 3 8 4 6 2  // second puzzle
2 1 3 5 4 6 8 7 9
6 8 4 9 2 7 4 5 1
1 3 8 4 6 2 7 9 5
5 4 6 8 7 9 2 1 3
9 2 7 3 5 1 6 8 4
4 6 2 7 9 5 1 3 8
8 7 9 2 1 3 5 4 6
3 5 1 6 8 4 9 2 7
</code></pre><p>我们输出的格式应该是：</p>
<pre><code>Case #1: Yes
Case #2: No
</code></pre><p>其中“Yes”表明解答是正确的。</p>
<p>让我们开始吧。</p>
<p>##建立</p>
<p>我们的第一步就是要从stdin中提取输入。在Node中，stdin是一个可读的stream。基本上，一个可读stream会在数据可读后立刻发送数据（更多的解释，参见<a href="http://nodejs.org/api/stream.html#stream_class_stream_readable" target="_blank" rel="external">readable stream docs</a>）。下面这行代码会输出所有输入到stdin中的内容：</p>
<pre><code>process.stdin.pipe(process.stdout);
</code></pre><p><code>pipe</code>方法从可读stream中获取所有的数据并写入一个可写stream。</p>
<p>可能从这份代码中并不显而易见，但是<code>process.stdin</code>会以大块byte的形式pipe数据，而我们感兴趣的是以行为分隔的文本。为了将这种大块数据分解成行，我们可以将<code>process.stdin</code> pipe进入dominictarr所写的<code>split</code>模块中。首先<code>npm install split</code>，然后：</p>
<pre><code>var split = require(&quot;split&quot;);

process.stdin.setEncoding(&quot;utf8&quot;); // convert bytes to utf8 characters

process.stdin
     .pipe(split())
     .pipe(process.stdout);
</code></pre><p>##使用transform stream构造问题</p>
<p>现在我们有了由行组成的序列，我们可以开始进行我们真正的工作了。我们会将这些行转化为一串代表数独问题的二维数组中。然后，我们pipe每个数独问题到另一个流并用它来检验它是否是一个正确的解答。</p>
<p>Node的原生transform stream提供了我们所需要的抽象。一个transform stream将写入它的数据进行转化，并将结果以一个可读stream的方式输出。有点疑惑？我们下面会让你清楚一些。</p>
<p>为了创建一个transform stream，我们要继承stream.Transform并调用它的构造函数。</p>
<pre><code>var Transform = require(&quot;stream&quot;).Transform;
var util = require(&quot;util&quot;);

util.inherits(ProblemStream, Transform); // inherit Transform

function ProblemStream () {
    Transform.call(this, { &quot;objectMode&quot;: true }); // invoke Transform&apos;s constructor
}
</code></pre><p>你会注意到，我们传递了<code>objectMode</code>的flag到<code>Transform</code>的构造函数中。原始的Stream上只接受string和buffer。而我们希望输出一个二维数组，所以我们需要打开object模式。</p>
<p>Transform stream有两个重要的方法：<code>_transform</code>和<code>_flush</code>。<code>_transform</code>在每当有数据写入stream时被调用。我们使用这个方法来将一系列的行转化为一个数组解答。<code>_flush</code>将在transform stream被通知没有更多的数据会被写入时被调用。这个函数有助于我们结束任何尚未结束的任务。</p>
<p>让我们草拟我们的transform函数：</p>
<pre><code>ProblemStream.prototype._transform = function (line, encoding, processed) {
     // TODO
}
</code></pre><p><code>_transform</code>接受3个参数。第一个是写入stream的数据。在我们这个情况下，就是一行文本。第二个参数是stream编码，在此我们设为utf8。最后一个参数是一个无参的回调函数用来提供已经结束输入处理的信号。</p>
<p>当你在实现<code>_transform</code>函数的时候要牢记两点：</p>
<ol>
<li>调用<code>processed</code>回调函数并不向output stream中添加任何内容。它仅仅是一个信号，标志着我们已经完成了传递给<code>_transform</code>的内容的处理</li>
<li>如果要输出一个值，使用<code>this.push(value)</code></li>
</ol>
<p>记住这些，让我们再来看看输入。</p>
<pre><code>2
3
7 6 5 1 9 8 4 3 2
8 1 9 2 4 3 5 7 6
3 2 4 6 5 7 9 8 1
1 9 8 4 3 2 7 6 5
2 4 3 5 7 6 8 1 9
6 5 7 9 8 1 3 2 4
4 3 2 7 6 5 1 9 8
5 7 6 8 1 9 2 4 3
9 8 1 3 2 4 6 5 7
3
7 9 5 1 3 8 4 6 2
2 1 3 5 4 6 8 7 9
6 8 4 9 2 7 4 5 1
1 3 8 4 6 2 7 9 5
5 4 6 8 7 9 2 1 3
9 2 7 3 5 1 6 8 4
4 6 2 7 9 5 1 3 8
8 7 9 2 1 3 5 4 6
3 5 1 6 8 4 9 2 7
</code></pre><p>我们马上就遇到了一个问题：我们的<code>_transform</code>方法每行被调用一次，但是前面三行每一行都代表不同的意义。第一行描述了要解决多少个问题，第二行是接下来的解答由几行组成，第三行是解答内容。我们的stream需要用不同的方式处理每一行。</p>
<p>幸运的是，我们可以将状态保存在transform stream内部：</p>
<pre><code>var Transform = require(&quot;stream&quot;).Transform;
var util = require(&quot;util&quot;);

util.inherits(ProblemStream, Transform);

function ProblemStream () {
    Transform.call(this, { &quot;objectMode&quot;: true });

    this.numProblemsToSolve = null;
    this.puzzleSize = null;
    this.currentPuzzle = null;
}
</code></pre><p>通过这些变量，我们就可以追踪到我们正处在行序列的何处。</p>
<pre><code>ProblemStream.prototype._transform = function (line, encoding, processed) {
    if (this.numProblemsToSolve === null) { // handle first line
        this.numProblemsToSolve = +line;
    }
    else if (this.puzzleSize === null) { // start a new puzzle
        this.puzzleSize = (+line) * (+line); // a size of 3 means the puzzle will be 9 lines long
        this.currentPuzzle = [];
    }
    else {
        var numbers = line.match(/\d+/g); // break line into an array of numbers
        this.currentPuzzle.push(numbers); // add a new row to the puzzle
        this.puzzleSize--; // decrement number of remaining lines to parse for puzzle

        if (this.puzzleSize === 0) {
            this.push(this.currentPuzzle); // we&apos;ve parsed the full puzzle; add it to the output stream
            this.puzzleSize = null; // reset; ready for next puzzle
        }
    }
    processed(); // we&apos;re done processing the current line
};

process.stdin
    .pipe(split())
    .pipe(new ProblemStream())
    .pipe(new SolutionStream()) // TODO
    .pipe(new FormatStream()) // TODO
    .pipe(process.stdout); 
</code></pre><p>让我们花点时间来回顾一下代码。记住<code>_transform</code>会为每行所调用。第一行_transform接收到对应的需要解决问题的数目。由于<code>numProblemsToSolve</code>是null，所以这个逻辑分支会被执行。被传递到<code>_transform</code>的第二行是解答的尺寸。由于我们已经知道解答的尺寸，第三行是构造数据结构的开始。一旦解答被构造，我们会将一个完整的解答推送到transform stream的输出端，然后准备创建一个新的解答。循环此过程直到我们读完所有行。</p>
<p>##解决所有的问题吧！</p>
<p>解析完并构造出数独解答的数据结构之后，我们终于可以开始解答这个问题了。</p>
<p>“解答问题”的任务，可以被解释为“将一个问题转化为一个解答”。这就是我们的下一个stream所要做的。</p>
<pre><code>util.inherits(SolutionStream, Transform);

function SolutionStream () {
    Transform.call(this, { &quot;objectMode&quot;: true });
}
</code></pre><p>然后，我们定义一个<code>_transform</code>方法，它接受一个problem参数，并返回一个布尔值。</p>
<pre><code>SolutionStream.prototype._transform = function (problem, encoding, processed) {
    var solution = solve(problem);
    this.push(solution);
    processed();

    function solve (problem) {
        // TODO
        return false;
    }
};

process.stdin
    .pipe(split())
    .pipe(new ProblemStream())
    .pipe(new SolutionStream())
    .pipe(new FormatStream()) // TODO
    .pipe(process.stdout);
</code></pre><p>不像<code>ProblemStream</code>一样，这个stream会为每一个输入构造一个输出，<code>_transform</code>会为每个问题执行一次，我们需要解决所有的问题。</p>
<p>我们所有要做的就是写一个函数来决定是否数独问题被解决了，我把这个留给你自己来解答。</p>
<h2 id="修饰输出"><a href="#修饰输出" class="headerlink" title="修饰输出"></a>修饰输出</h2><p>现在我们解决了这个问题，我们的最后一步是格式化输出。如你所料，我们又将使用一个transform stream。</p>
<p>我们的<code>FormatStream</code>接受一个解答并转化为一个字符串传递到<code>process.stdout</code>中。</p>
<p>还记得输出格式吗？</p>
<pre><code>Case #1: Yes
Case #2: No
</code></pre><p>我们需要纪录问题号，并将布尔值转化为”Yes”或者”No”。</p>
<pre><code>util.inherits(FormatStream, Transform);
function FormatStream () {
    Transform.call(this, { &quot;objectMode&quot;: true });

    this.caseNumber = 0;
}

FormatStream.prototype._transform = function (solution, encoding, processed) {
    this.caseNumber++;

    var result = solution ? &quot;Yes&quot; : &quot;No&quot;;

    var formatted = &quot;Case #&quot; + this.caseNumber + &quot;: &quot; + result + &quot;\n&quot;;

    this.push(formatted);
    processed();
};
</code></pre><p>现在，将<code>FormatStream</code>连接到我们的pipeline中，我们就完成了</p>
<pre><code>process.stdin
    .pipe(split())
    .pipe(new ProblemStream())
    .pipe(new SolutionStream())
    .pipe(new FormatStream())
    .pipe(process.stdout);
</code></pre><p><a href="https://github.com/nimbus154/node-coding-challenge-pattern" target="_blank" rel="external">从Github上获取完整代码。</a></p>
<h2 id="最后一条提示"><a href="#最后一条提示" class="headerlink" title="最后一条提示"></a>最后一条提示</h2><p>使用<code>pipe</code>的最大好处是你可以在任何可读/可写流中重用你的代码。如果你需要解答一个来自网络的问题，将<code>process.stdin</code>和<code>process.stdout</code>改为网络stream，所有的一切应该可以直接使用。</p>
<p>对于每一个问题你可以需要做相应的微调，但我希望它给出了一个好的开始。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#用Stream解决编程挑战（译）&lt;/p&gt;
&lt;p&gt;我第一次使用Node.js解决编程挑战的经验简直是让人焦虑不已。我设计了一个切实可行的解决方法，但我却无法找到一个有效的方法来解析输入。它的格式非常的简单：文本通过stdin的pipe输入。很简单，是吧？但我一般的时间都耗费
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>拥抱JavaScript中的异步（译）</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/10/07/embracing-async-in-javascript-part-1/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/10/07/embracing-async-in-javascript-part-1/</id>
    <published>2014-10-08T03:47:48.000Z</published>
    <updated>2016-04-29T18:43:51.171Z</updated>
    
    <content type="html"><![CDATA[<p>#拥抱JavaScript中的异步（译）</p>
<p><a href="https://twitter.com/whitehouse3001" target="_blank" rel="external">Andy White</a></p>
<p>##简介</p>
<p>如果你已经写过不计其数的Javascript代码，那么你会意识到，异步编程并不仅仅是一种”nice to have”的能力，而是一种必需品。为了充分利用语言与生态系统，它必须被理解和接受。</p>
<p>##回调</p>
<p>在JavaScript中，最简单的展示异步API的方式之一便是使用一个接受另一个函数作为参数的函数。这些函数参数就是所谓的“回调”或“回调函数”，因为他们给予主函数一个用来回调的钩子 – 通过在恰当的时机，调用一次或多次你所提供的函数。因为JavaScript将函数视为<a href="http://en.wikipedia.org/wiki/First-class_citizen" target="_blank" rel="external">一等公民</a>，你可以将函数实例作为参数传递给其他函数，或者从其他函数中返回函数实例，就像你可以轻松的传递或返回数值，字符串，布尔类型，对象或者数组一样。会点函数可以被主函数在任何时机，以任何的次数，同步或异步的方式，使用任何绑定的上下文以及参数所调用，这样就提供了一种非常灵活以及强大的在JavaScript模块之间进行通信的机制。</p>
<h2 id="JavaScript的事件循环与回调"><a href="#JavaScript的事件循环与回调" class="headerlink" title="JavaScript的事件循环与回调"></a>JavaScript的事件循环与回调</h2><p>在深入了解回调以及异步代码之前，对JavaScript的事件循环与回调有一个基本的认知是非常重要的。在最基本的形式中，JavaScript是一个单线程的运行时，因此它并不支持类似于多线程、多进程或内部进程通信的技术。尽管看起来（实际也是）有这些限制，缺少多线程实际上会让你作为一个javaScript开发者的认识更简单一些，并且允许几种有趣的在编译、压缩、清理（transpilation）的优化技术。</p>
<p>因为只有单线程，你将永远不会遇到基本的来自线程的挑战，例如竞争条件，资源冲突，线程死锁等。当JavaScript解释器开始执行一个代码块时（例如，一次函数调用），它将一直执行这块代码直到同步代码结束（该函数中所包含的最后一句同步代码）。在执行这段同步代码的期间，任何非同步的函数调用（例如外部事件句柄调用，异步函数调用，异步回调等等）将简单的被放置于队列中等待运行时事件循环之后执行。一旦同步代码执行完，事件循环将从队列中获取下一块代码并执行它，知道同步代码的结束，以此类推。这样，你可以安全的断言，你在一个函数中编写的任何一串的同步代码，在其他代码执行之前，将总是不被打断地执行到结束。你也无法使用CPU直到你yield它（或者运行时干掉了你的堵塞或者死循环代码）。这对于应用开发非常有帮助，但也需要一些仔细的考虑与计划，尤其是当你需要用到异步API时，你代码的顺序就非常重要了。</p>
<h2 id="是”下一个tick”还是”事件循环的下一个回合”"><a href="#是”下一个tick”还是”事件循环的下一个回合”" class="headerlink" title="是”下一个tick”还是”事件循环的下一个回合”"></a>是”下一个tick”还是”事件循环的下一个回合”</h2><p>你经常听到JavaScript开发者提到”下一个tick”还是”事件循环的下一个回合”。基本上，这些概念意味着，当当前同步代码执行完毕后，这些代码将被置于等待执行的队列中，时间循环正准备从队列中获取下一块要执行的代码。所有的异步API都暗示代码将会在之后的的”tick”或者“时间循环的回合”被执行。下一个tick的概念可能更具体的取决于你的JavaScript平台，但是基本上，它仅仅指的是一个函数调用已经被置于队列中为了将来执行。在这个条件下，”之后”这个词可能是也可能不是指向一个确定的时间延迟，但它总是表示代码会在当前同步代码执行完之后被执行。</p>
<h2 id="非堵塞操作"><a href="#非堵塞操作" class="headerlink" title="非堵塞操作"></a>非堵塞操作</h2><p>由于JavaScript的单线程特性，因此时间敏感的操作，例如IO操作，必须全部都是非堵塞且异步的，这样这些操作就不会堵塞主应用的时间循环。当事件循环被堵塞时，没有其他应用逻辑会被执行，应用程序往往陷于完全停止的情景。长时间的操作全部都应该被异步调用，并且在操作结束（或者失败）时使用一些异步完成的回调进行处理。对于长时间的操作，使用进度回调函数也非常常见，这样进度的增长可以被报告出来（例如大文件的拷贝操作时的百分比通知）。所有这些回调都是简单被加入到事件队列中，并且在事件循环的未来某一个回合被执行，这样就不会有任何代码在任何时刻堵塞事件循环。</p>
<h2 id="同步vs异步回调API"><a href="#同步vs异步回调API" class="headerlink" title="同步vs异步回调API"></a>同步vs异步回调API</h2><p>对于回调，一个重要的方面是，它可以是同步的，也可以是异步的。通常而言，理解回调将被同步还是异步调用是非常重要的，因为你可能会有一些依次执行的代码，它们不应该被执行直到这些回调函数基于的API调用结束。对于同步的回调API，你基本上不需要做任何事情来实现所期望的顺序，因为回调函数将同步地执行到结束，而对于异步回调API，你往往必须用另一种形式编写代码以确保调用顺序的正确性。</p>
<h2 id="基于同步的”each”函数"><a href="#基于同步的”each”函数" class="headerlink" title="基于同步的”each”函数"></a>基于同步的”each”函数</h2><p>一个基于”each”函数的同步回调可以很好的阐明这个问题。注意：我现在忽略了回调上下文(<code>this</code>)以及<code>Function.prototype.call</code>和<code>apply</code>。</p>
<pre><code>// Helper function for logging something to the console
function logItem(item) {
    console.log(item);
}

// Synchronous &quot;each&quot; function - invokes the callback for each item
// in the array
function each(arr, callback) {
    for (var i = 0; i &lt; arr.length; ++i) {
        // Invoke the callback synchronously for each iteration
        callback(arr[i]);
    }
}

// Try it out!
console.log(&quot;begin&quot;);
each([1, 2, 3], logItem); // &quot;logItem&quot; is our &quot;callback&quot; function here
console.log(&quot;end&quot;);
</code></pre><p>这个示例会在控制台打印：</p>
<pre><code>begin
1
2
3
end
</code></pre><p>除了<code>for</code>循环以及<code>each</code>函数会被同步执行直到到达<code>console.log(&quot;end&quot;)</code>语句，这个示例没有其他特殊的。</p>
<h2 id="基于异步的”each”函数-（第一次尝试）"><a href="#基于异步的”each”函数-（第一次尝试）" class="headerlink" title="基于异步的”each”函数 （第一次尝试）"></a>基于异步的”each”函数 （第一次尝试）</h2><p>一个异步版本的”each”可能看起来像这样。在这里，我使用setTimeout来强制使回调的执行变得异步。主要setTimeout只是一个帮助函数用来推迟一个函数的调用 – 从当前同步代码执行结束后算起（也就是，下一个事件循环的回合）。setTimeout也接受一个最小时间延迟的参数，但是在这里，我只是使用延迟0毫秒，仅仅让它异步执行，而不产生任何延迟。</p>
<pre><code>function asyncEach(arr, callback) {
    for (var i = 0; i &lt; arr.length; ++i) {
        // Enqueue a function to be called later
        // Note: this code does not do what we might expect...
        setTimeout(function() {
            callback(arr[i]);
        }, 0);
    }
}

console.log(&quot;begin&quot;);
asyncEach([1, 2, 3], logItem);
console.log(&quot;end&quot;);
</code></pre><p>由于回调函数现在异步执行，你应该期待代码执行结果为：</p>
<pre><code>begin
end
1
2
3
</code></pre><p>但是，令人吃惊（或者，其实并不吃惊）的是，代码结果为：</p>
<pre><code>begin
end
undefined
undefined
undefined
</code></pre><p>这个代码错误可能在某一个时刻绊倒过每一个JavaScript开发人员。这里发生了什么？其实，因为我们在循环中使用了<code>setTimeout</code>，而不是在每次循环中调用<code>callback(arr[i])</code>，我们实际上将一个函数调用延迟了，延迟到当前同步代码块的结束（也就是，<code>for</code>循环）。在这个例子中，我们纪录了<code>begin</code>，然后延迟3个回调函数的调用，然后纪录<code>end</code>，然后释放CPU到事件循环中。事件循环又开始执行我们延迟的回调函数，按顺序执行，而我们期望它的结果应该是纪录<code>arr[0]</code>，<code>arr[1]</code>和<code>arr[2]</code>。</p>
<h2 id="JavaScript的范围和闭包"><a href="#JavaScript的范围和闭包" class="headerlink" title="JavaScript的范围和闭包"></a>JavaScript的范围和闭包</h2><p>为什么结果会是打印三次<code>undefined</code>而不是<code>1</code>,<code>2</code>,<code>3</code>呢？这就涉及到另一个重要的内容，JavaScript函数与范围：<a href="http://en.wikipedia.org/wiki/Closure_(computer_programming" target="_blank" rel="external">闭包</a>)的概念。当你在JavaScript中创建一个函数，这个函数可以访问它被创建的那个范围的所有东西，包括任何你在函数内部创建的新变量。JavaScript不像C,C++,Java,C#那样，没有块级作用域。取而代之的是在函数级别定义作用域。你在函数中定义的任何变量，在函数的其他地方或任何内部函数中都是可以被访问到的。有趣的是，不仅仅一个函数能访问它当前环境作用域的所有变量，函数实例在其整个生命周期同样也“持有”（“关闭”）该作用域，即使其父函数（调用它的函数）已经返回或离开该作用域。只要该函数仍然“存活”（被某些东西引用，还未被回收），那么它就会持有该作用域，即使父函数早已消失。由于函数实例可以从一个函数中被返回，一个函数就可以轻易地在父函数或调用函数生命周期之外存活。这中“持有”作用域有事会导致微小的内存泄露，但我们现在不讨论它。在上面的<code>asyncEach</code>示例中，实际发生的事情是：每一个我们在<code>for</code>循环中延迟的回调函数保存了到当前作用域的引用（当时这个作用域还存在着），并且持有该作用域即使<code>for</code>循环以及<code>asyncEach</code>函数已经退出。而回调函数存活在<code>for</code>循环之外，因为回调函数实例被通过setTimeout添加至事件队列中，因此作用域变量例如<code>arr</code>和<code>i</code>还活着，但是现在<code>i</code>的值变成了<code>3</code>，因为<code>for</code>循环在之前已经同步执行到结束了。在每一个回调中，<code>logItem</code>函数每次都访问arr[3]，也就是undefined。</p>
<p>有很多种方式可以处理这个问题，但大多数都围绕着围绕我们希望之后捕获的变量周围添加一个额外的函数作用域。</p>
<h2 id="基于异步的”each”函数-（第二次尝试）"><a href="#基于异步的”each”函数-（第二次尝试）" class="headerlink" title="基于异步的”each”函数 （第二次尝试）"></a>基于异步的”each”函数 （第二次尝试）</h2><p>一个在每个回调函数中获得所期望的<code>i</code>值的解决方法是，在我们希望捕获的变量周围引入一个“立即执行的函数表达式”(<a href="http://en.wikipedia.org/wiki/Immediately-invoked_function_expression" target="_blank" rel="external">immediately-invoked function expression, IIFE</a>)。一个IIFE有多种用法，其中一个就是当你没别的办法获取一个作用域时，强制创造一个作用域（例如在<code>for</code>循环中）。<a href="http://jslinterrors.com/dont-make-functions-within-a-loop" target="_blank" rel="external">这在循环中是不被建议的</a>，但是它可以起到作用：</p>
<pre><code>// Not recommended
function asyncEach2(arr, callback) {
    for (var i = 0; i &lt; arr.length; ++i) {
        // Use an IIFE wrapper to capture the current value of &quot;i&quot; in &quot;iCopy&quot;
        // &quot;iCopy&quot; is unique for each iteration of the loop.
        (function(iCopy) {
            setTimeout(function() {
                callback(arr[iCopy]);
            }, 0);
        }(i));
    }
}

console.log(&quot;begin&quot;);
asyncEach([1, 2, 3], logItem);
console.log(&quot;end&quot;);
</code></pre><p>现在我们能得到所期望的结果了：</p>
<pre><code>begin
end
1
2
3
</code></pre><p>这之所以能够起作用是因为我们在每一个函数迭代周期创造了一个内部函数作用域，并且我们创建了新的变量<code>iCopy</code>并赋予其每个迭代周期中<code>i</code>的值。<code>iCopy</code>在每一个循环周期都是独一无二的，因此我们不再会遇到在作用域外引用一个变量的问题，在之前的示例中，我们在得到它之前它就变掉了。</p>
<h2 id="基于异步的”each”函数-（第三次尝试）"><a href="#基于异步的”each”函数-（第三次尝试）" class="headerlink" title="基于异步的”each”函数 （第三次尝试）"></a>基于异步的”each”函数 （第三次尝试）</h2><p>一个更倾向的解决问题的方式不是在循环内部使用IIFE，而是在循环外创建一个函数以创造我们的函数作用于，像这样：</p>
<pre><code>function asyncEach3(arr, callback) {
    // Utility inner function to create a wrapper function for the callback
    function makeCallbackWrapper(arr, i, callback) {
        // Create our function scope for use inside the loop
        return function() {
            callback(arr[i]);
        }
    }

    for (var i = 0; i &lt; arr.length; ++i) {
        setTimeout(makeCallbackWrapper(arr, i, callback), 0);
    }
}

console.log(&quot;begin&quot;);
asyncEach3([1, 2, 3], logItem);
console.log(&quot;end&quot;);
</code></pre><p>这一次，我们使用了一个单独的函数<code>makeCallbackWrapper</code>来为每个循环迭代创造我们的函数作用域。这次代码更简洁，容易阅读和维护，并且避免了”循环内IIFE”所带来的性能问题。</p>
<h2 id="基于异步的”each”函数-（第四次尝试）"><a href="#基于异步的”each”函数-（第四次尝试）" class="headerlink" title="基于异步的”each”函数 （第四次尝试）"></a>基于异步的”each”函数 （第四次尝试）</h2><p>另一个更先进的在<code>for</code>循环内部创造作用域的方式是使用函数绑定或者<a href="http://en.wikipedia.org/wiki/Partial_application" target="_blank" rel="external">partial application</a>，就像使用原生的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">Function.prototype.bind</a>函数（只有新的浏览器支持），或者使用由<a href="http://underscorejs.org/" target="_blank" rel="external">Underscore</a>，<a href="http://lodash.com/" target="_blank" rel="external">Lo-Dash</a>，<a href="http://jquery.org/" target="_blank" rel="external">jQuery</a>三者任意一个提供的<code>bind</code>实现。</p>
<p>函数绑定以及partial application是更大的话题，会在今后的博客文章中讨论。</p>
<pre><code>function asyncEach4(arr, callback) {
    for (var i = 0; i &lt; arr.length; ++i) {
        // boundCallback is a new function which has arr[i] permanently
        // set (partially applied) as its first argument.  The &quot;null&quot; argument
        // is the binding for the `this` context variable in the callback, which
        // we don&apos;t care about in this example...
        var boundCallback = callback.bind(null, arr[i]);
        setTimeout(boundCallback, 0);
    }
}

console.log(&quot;begin&quot;);
asyncEach4([1, 2, 3], logItem);
console.log(&quot;end&quot;);
</code></pre><h2 id="异步代码的执行顺序"><a href="#异步代码的执行顺序" class="headerlink" title="异步代码的执行顺序"></a>异步代码的执行顺序</h2><p>我们要如何才能在使用<code>asyncEach</code>时保持日志纪录顺序呢，像原先同步的<code>each</code>例子一样：</p>
<pre><code>begin
1
2
3
end
</code></pre><p>下篇文章讨论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这只是一个JavaScript中基于回调的API以及异步编程的基本介绍。在今后的博客中，我将会探索如何在asyncEach函数中获取你所期望的顺序执行的功能，这样我们仍然能打印<code>begin, 1, 2, 3, end</code>即使回调函数是异步的情况。我也会讨论JavaScript中异步编程的其他问题，包括函数上下文变量context是如何与回调一起工作的，“回调地狱”的概念，以及Javascript中的promise是如何解决这些问题的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#拥抱JavaScript中的异步（译）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/whitehouse3001&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Andy White&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##简介&lt;/p&gt;
&lt;p
    
    </summary>
    
    
      <category term="translation" scheme="http://nnabuuu.github.io/blog-hexo/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>Design-of-Q</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/08/18/Design-of-Q/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/08/18/Design-of-Q/</id>
    <published>2014-08-19T02:58:48.000Z</published>
    <updated>2016-04-29T18:43:51.160Z</updated>
    
    <content type="html"><![CDATA[<p>/*<br>本文档的目的是通过增量的、回顾其主要设计决策的方式来构建一个promise库，以此解释promises如何工作以及为何采用这样独特的方式实现。旨在让用户可以自由的体验到不同的实现方式以便满足其自身的需求，而不必错过任何重要的细节。</p>
<p>-</p>
<p>设想一下你正在编写一个无法立即返回一个值的函数。最显而易见的API是：将最终结果传递到一个作为参数的回调函数中，来代替将其返回。<br>*/</p>
<pre><code>var oneOneSecondLater = function (callback) {
    setTimeout(function () {
        callback(1);
    }, 1000);
};
</code></pre><p>/*<br>这是一个解决这种琐碎问题的一个非常简单的方案，但它还有很多进步的空间。</p>
<p>一个更通用的解决方案会同时为返回值以及被抛出的异常提供同样的工具（即回调函数）。有几个显而易见的方式来扩展回调模式以处理异常。其中一个是同时提供一个普通的回调函数(callback)以及一个处理错误的回调函数(errback)。<br>*/</p>
<pre><code>var maybeOneOneSecondLater = function (callback, errback) {
    setTimeout(function () {
        if (Math.random() &lt; .5) {
            callback(1);
        } else {
            errback(new Error(&quot;Can&apos;t provide one.&quot;));
        }
    }, 1000);
};
</code></pre><p>/*<br>还有其他的解决方案，区别在于将错误作为回调函数的一个参数传入，以位置或者“哨兵值“进行区分。但是，这样的解决方案没有一个事实上考虑了被抛出的异常。异常以及try/catch块的目的是延后明确处理异常的时间直到程序已经回到一个有意义尝试从异常中恢复的点。如果异常没有被处理，我们需要一些机制来隐式地传播异常。</p>
<h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>考虑一个更普遍的解决方式，代替返回值或者抛出异常，函数返回一个表示函数最终结果的对象，要么成功，要么失败。这个对象，无论是从打比方还是命名的角度来说，就是一个最终要被处理的promise，我们可以在promise之上调用函数来观测它是被满足还是被拒绝。如果这个promise被拒绝而并没有被主动的观测到，那么其他衍生的promise会被因为一些原因被隐式地拒绝。</p>
<p>在下面这个特殊的设计迭代中，我们将promise设计为一个带有以回调函数为参数的”then”函数的对象。<br>*/</p>
<pre><code>var maybeOneOneSecondLater = function () {
    var callback;
    setTimeout(function () {
        callback(1);
    }, 1000);
    return {
        then: function (_callback) {
            callback = _callback;
        }
    };
};
</code></pre><p>/*<br>这种设计有两个不足：</p>
<ul>
<li>第一个then的调用者决定被使用的回调函数。如果每一个被注册的回调函数都会被resolution通知到的话会更好。</li>
<li>如果回调函数在promise被构造多于一秒之后注册，那么它不会被调用。</li>
</ul>
<p>一个更普遍的解决方式在于接受任意数量的回调函数并且允许他们无论在超时（更普遍的说<br>，resolution事件被触发）前或后均可注册。我们通过将promise设置为一个两种状态的对象来实现。</p>
<p>一个promise最初处于unresolved状态，并且所有的回调函数都被加入一个pending状态观测者的数组中。当promise被resolve之后，所有的观测者都会被通知到。我们通过判断是否这个pending回调函数的队列存在的方式来区分状态是否被转换，我们在resolution之后会扔掉它（这个队列）。<br>*/</p>
<pre><code>var maybeOneOneSecondLater = function () {
    var pending = [], value;
    setTimeout(function () {
        value = 1;
        for (var i = 0, ii = pending.length; i &lt; ii; i++) {
            var callback = pending[i];
            callback(value);
        }
        pending = undefined;
    }, 1000);
    return {
        then: function (callback) {
            if (pending) {
                pending.push(callback);
            } else {
                callback(value);
            }
        }
    };
};
</code></pre><p>/<em><br>这样已经足够好了，如果将其改为一个功能函数的话会非常有用处。一个deferred是一个拥有两个部分的对象：一个用来注册观测者，另一个用来将resolution通知观测者。<br>（见 design/q0.js）
</em>/</p>
<pre><code>var defer = function () {
    var pending = [], value;
    return {
        resolve: function (_value) {
            value = _value;
            for (var i = 0, ii = pending.length; i &lt; ii; i++) {
                var callback = pending[i];
                callback(value);
            }
            pending = undefined;
        },
        then: function (callback) {
            if (pending) {
                pending.push(callback);
            } else {
                callback(value);
            }
        }
    }
};

var oneOneSecondLater = function () {
    var result = defer();
    setTimeout(function () {
        result.resolve(1);
    }, 1000);
    return result;
};

oneOneSecondLater().then(callback);
</code></pre><p>/<em><br>现在这个resolve有一个瑕疵：它能够被调用多次，从而改变被promised了的结果。它没有能够符合“一个函数只能要么返回一个值要么抛出一个错误”的事实要求。我们可以通过只允许第一次调用来设定resolution的方式保护结果免于意外或者恶意的重置。
</em>/</p>
<pre><code>var defer = function () {
    var pending = [], value;
    return {
        resolve: function (_value) {
            if (pending) {
                value = _value;
                for (var i = 0, ii = pending.length; i &lt; ii; i++) {
                    var callback = pending[i];
                    callback(value);
                }
                pending = undefined;
            } else {
                throw new Error(&quot;A promise can only be resolved once.&quot;);
            }
        },
        then: function (callback) {
            if (pending) {
                pending.push(callback);
            } else {
                callback(value);
            }
        }
    }
};
</code></pre><p>/*<br>你可以设置一个参数，在这种情况下要么抛出一个错误或者忽略之后所有其他resolution。一个测试就是给予resolver一串worker，并竞争resolve该promise，而剩余的resolution会被忽略。如果你不想让这些worker知道谁获胜了，这也是可行的。下文中，所有的示例都会忽略多重resolution而不是抛出异常。</p>
<p>现在，defer可以同时处理多resolution和多observation的情况。（见 design/q1.js）</p>
<hr>
<p>源于两个单独的立场，这个设计衍生出了几种不同的变化。第一种立场是：将promise和deferred中的resolver部分分离或者结合都是有用的。通过某种方式从其他值中识别promise也是有用的。</p>
<p>-</p>
<p>将promise从resolver中分离开允许我们在最小特权原则下进行编码。给予某人一个promise，应该仅仅给予他观测resolution的权力，而给予某人一个resolver，应该仅仅给予他决定resolition的权力。一方的权力绝不不应该被授予另一方。通过时间的检验我们发现，任何过度的授权都会不可避免地被滥用，并且这将会非常难以编写。</p>
<p>然而，分离的不好之处在于，快速地废除promise对象会给垃圾回收器带来额外负担。</p>
<p>-</p>
<p>以外，有非常多的方式来区分promise以及其他值。最显而易见并且最重要的区分方式是使用原型继承（design/q2.js）<br>*/</p>
<pre><code>var Promise = function () {
};

var isPromise = function (value) {
    return value instanceof Promise;
};

var defer = function () {
    var pending = [], value;
    var promise = new Promise();
    promise.then = function (callback) {
        if (pending) {
            pending.push(callback);
        } else {
            callback(value);
        }
    };
    return {
        resolve: function (_value) {
            if (pending) {
                value = _value;
                for (var i = 0, ii = pending.length; i &lt; ii; i++) {
                    var callback = pending[i];
                    callback(value);
                }
                pending = undefined;
            }
        },
        promise: promise
    };
};
</code></pre><p>/*<br>使用原型继承的缺点在于它使得一个项目中只能使用一种promise库。这会难以实施，使实施依赖变成一种灾难。</p>
<p>另一种实现方式是使用duck-typing，通过是否存在某种约定命名的方法来区分promise以及其他对象。在我们的案例中，CommonJS/Promises/A创立了通过是否使用了”then”的方式来区分promise以及其他值。这个方式的缺点是无法判断那些只是碰巧有一个”then”方法的对象。在实际状况中，这并不是一个问题，并且这种实现”可以then”的微小差异是可以被管理的。<br>*/</p>
<pre><code>var isPromise = function (value) {
    return value &amp;&amp; typeof value.then === &quot;function&quot;;
};

var defer = function () {
    var pending = [], value;
    return {
        resolve: function (_value) {
            if (pending) {
                value = _value;
                for (var i = 0, ii = pending.length; i &lt; ii; i++) {
                    var callback = pending[i];
                    callback(value);
                }
                pending = undefined;
            }
        },
        promise: {
            then: function (callback) {
                if (pending) {
                    pending.push(callback);
                } else {
                    callback(value);
                }
            }
        }
    };
};
</code></pre><p>/<em><br>下一个大的步骤是使它可以简单的生成promise，使用从旧的promise中获取的值来构造新的promise。假设你收到从数个函数调用中得到的两个数字的promise，我们应该可以创建他们的和的promise。考虑一下这用callback是怎样实现的。
</em>/</p>
<pre><code>var twoOneSecondLater = function (callback) {
    var a, b;
    var consider = function () {
        if (a === undefined || b === undefined)
            return;
        callback(a + b);
    };
    oneOneSecondLater(function (_a) {
        a = _a;
        consider();
    });
    oneOneSecondLater(function (_b) {
        b = _b;
        consider();
    });
};

twoOneSecondLater(function (c) {
    // c === 2
});
</code></pre><p>有非常多的原因证明，这种实现是非常脆弱的，特别是它需要明确的编码来进行通知（在本例中是使用一个哨兵值），是否是一个回调函数被调用了。此外，我们必须注意考虑到在事件循环结束前被发出的条件：<code>consider</code>函数需要在它被使用之前出现。</p>
<p>在下面的几个步骤中，我们会能够用promise实现它，使用更少的代码以及隐式地处理错误传递。<br>*/</p>
<pre><code>var a = oneOneSecondLater();
var b = oneOneSecondLater();
var c = a.then(function (a) {
    return b.then(function (b) {
        return a + b;
    });
});
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;/*&lt;br&gt;本文档的目的是通过增量的、回顾其主要设计决策的方式来构建一个promise库，以此解释promises如何工作以及为何采用这样独特的方式实现。旨在让用户可以自由的体验到不同的实现方式以便满足其自身的需求，而不必错过任何重要的细节。&lt;/p&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[译]函数响应式编程</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/07/05/The-introduction-to-Reactive-Programming-you-ve-been-missing/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/07/05/The-introduction-to-Reactive-Programming-you-ve-been-missing/</id>
    <published>2014-07-06T04:32:48.000Z</published>
    <updated>2016-04-29T18:43:51.170Z</updated>
    
    <content type="html"><![CDATA[<p>你所期待已久的函数响应式编程简介</p>
<p>原文地址：<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</a></p>
<p>你一定对学习这个被称为（函数）响应式编程的东西感兴趣。</p>
<p>这东西学起来很难，缺乏好的资料使它变得更难。当我开始学习的时候，我尝试着寻找教程。我只找到少量的实践指南，而它们也仅仅是挠了挠表面，从未挑战去建立整个架构。当你想了解一些函数的时候，库的文档往往对你没什么帮助。我的意思是，老实说，看看这个：</p>
<pre><code>合并元素的索引，然后把一个可观测序列的可观测序列转化为一个可观测序列，仅仅从最近的可观测序列中取值。通过这种方法将每一个可被观测的序列中的对象投射到一个新的可观测序列的序列上。
</code></pre><p>天呐。。</p>
<p>我读了两本书，其中一本只是描绘了蓝图，另一本则一头钻进“如何使用FRP库”的问题中。最后我通过那种困难的方式学习了响应式编程：一边构造响应式编程项目一边学习。在我在Futurice的工作中，我在一个真正的项目上使用了它，当我遇到难题的时候我的一些同事帮助了我。</p>
<p>在学习的旅途中最困难的是用函数响应式编程进行思考。很多时候需要抛弃那些典型的、有状态的编程习惯，并迫使你的大脑在另一种模式下工作。我没有在网上找到任何这方面相关的内容，我任何需要这样一个“如何用函数响应式编程进行思考”的教程，以便你们可以开始迈出第一步。在那之后，库文档会帮你照亮后面的道路。希望这可以帮到你们。</p>
<p>#什么是函数响应式编程（FRP）？</p>
<p>对于函数相应式编程，网上有很多不好的解释以及定义。维基百科和平常一样说得太空泛以及理论化了。Stackoverflow的规范的答案显然不适合新手。Reactive Manifesto看起来像是你要讲给你公司里的项目经理或者商务人士所听的。微软Rx术语“Rx = Observables + LINQ + Schedulers”过于沉重（那么的“微软化”），我们大多数人都会感到困惑。像“reactive”，“”propagation of change”这种术语和我们典型的MV*以及最爱的编程语言已经做到了。我的框架当然是视图（Views）响应模型（Models）的，变化当然是可以传递的，否则的话什么也不会呈现。</p>
<p>所以，我们就不要继续说上面那些了。</p>
<p>####函数响应式编程就是通过异步数据流进行编程</p>
<p>在某种程度上，这并不是什么新的东西。事件总线或者典型的单击事件就已经是异步事件流了，你在它们上面可以进行观察或者做点其他的事情。函数响应式编程就是那些玩意儿再加上些内固醇。你可以对任何东西创造数据流，而不仅仅是click或者hover事件。流非常的廉价并且无处不在，任何东西都可以是流，变量、用户输入、属性、缓存、数据结构，等等。比如，设想一下你的Twitter feed是一个像单击事件一样的数据流。你可以监听这个是流并且做出相应的反应。</p>
<p><b>更重要的是，你拥有了一个神奇的工具箱来连接、创造并且过滤任何这些流。</b>这就是“函数式”的魔力。一个流可以作为另一个流的输入，甚至可以是多个流作为一个流的输入。可以合并两个流。你可以过滤一个流而得到你另一个只包含你所感兴趣的事件的流。你可以把数据从一个流映射到另一个流。</p>
<p>如果流对于函数响应式编程如此重要，让我们仔细的来看看它们，从我们熟悉的“点击一个按钮”的事件流开始。</p>
<p><img src="https://camo.githubusercontent.com/28787087e17e13046655c0f71d6e4080c3508b10/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f343964613639346232343839663965376237323736646633316131646362323036313739613439362f7a636c69636b73747265616d2e706e67" alt="image"></p>
<p>流是正在进行的事件按时间排序得到的序列。它可以广播三种不同的东西：一个值（属于某种类型）、一个错误，或者一个“已完成”的信号。设想一下，比如“已完成”会在当前包含此按钮的窗口或者视图被关闭时发生。</p>
<p>我们只采用<b>异步</b>的方式捕获这些被广播的事件，通过定义一个“当某个值被广播时执行”的函数，一个“当错误被广播时执行”的函数以及一个“当完成被广播时执行”的函数来完成。有时候后两个可以被省略，你可以只专注于定义那个捕获某个值的函数。对这个流进行“监听”被成为订阅。我们所定义的函数是观察者。流是被观测的主体（或被称为“可观测对象”）。这正是<a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="external"><b>观察者设计模式</b></a></p>
<p>另一个画这张图的方式是使用ASCII，我们将在本教程的某些部分使用：</p>
<pre><code>--a---b-c---d---X---|-&gt;

a, b, c, d 是被广播的值
X 是一个错误
| 是“已完成”信号
---&gt; 是时间轴
</code></pre><p>既然这已经感觉如此熟悉了，并且我不想让你们感到厌烦，让我们来做点新的事情：我们接下来要用原有的单击事件流构建出一些新的单击事件流。</p>
<p>首先，让我们创造一个计数事件流用来表明这个按钮被按了多少次。在函数响应式编程的公共库里，每一个流都有很多种函数附在它的上面，例如<code>map</code>, <code>filter</code>, <code>scan</code> 等等。当你调用其中一个函数时，比如<code>clickStream.map(f)</code>，它会基于当前的点击流返回一个新的流。它并不对原先的点击流做任何修改。这就是所谓的不变性，它和FRP流的关系就像煎饼和糖浆一样如此的美好。这允许我们进行链式调用，比如：<code>clickStream.map(f).scan(g)</code>:</p>
<pre><code>点击流: ---c----c--c----c------c--&gt;
       vvvvv map(c 变为 1)    vvvv
       ---1----1--1----1------1--&gt;
       vvvvvvvvv scan(+) vvvvvvvvv
计数流: ---1----2--3----4------5--&gt;
</code></pre><p>函数<code>map(f)</code>根据你所提供的函数<code>f</code>，将每一个被广播的值替换成新的值，并放入新的流中。在我们的例子里，我们把每一次点击映射为数字1.函数<code>scan(f)</code>汇集这个流上前面所有的值，产生<code>x = g(accumulated, current)</code>，而<code>g</code>在本例中只是一个简单的相加函数。这样，每当点击发生的时候，<code>counterStream</code>就会广播一次点击总数。</p>
<p>为了展现FRP的真正威力，我们考虑这样一个场景：你想要一个双击的事件流，为了让它更有趣一点，我们希望这个流把“三击”（更一般的情况，大于两次的点击）也考虑为双击。做一次深呼吸，想象一下在传统的、有状态的方式下你会怎样做？我敢打赌这一定相当麻烦并且涉及到许多用来保持状态和纪录时间间隔的变量。</p>
<p>好吧，在FRP中这非常简单。事实上，它的逻辑只需要<a href="http://jsfiddle.net/staltz/4gGgs/27/" target="_blank" rel="external">4行代码</a>。但首先，让我们忽略代码，用思维图是最好的理解以及构建流的方式。</p>
<p><img src="https://camo.githubusercontent.com/74d215aac2e23ae940cf5d1f4e08cc8878c9fecf/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f623538306164346133336236336163623263656439623865356539306661616238636137656632362f7a6d756c7469636c69636b73747265616d2e706e67" alt="image"></p>
<p>灰色方格里面是讲一个流转化为另一个流的函数。简言之，我们首先把单击聚集到一个列表中，无论何时250毫秒的“事件沉默”发生（这正是<code>buffer(stream.throttle(250ms)</code>所做的）。现在不用担心理解细节，我们现在只是在演示使用FRP。它的结果是一个列表的流，在此基础上我们通过<code>apply()</code>将每一个列表映射为表示它的长度的数字。最后我们通过<code>filter(x &gt;= 2)</code>忽略数字<code>1</code>，这样就完成了用3个步骤创建我们所需要的流。我们接下来就可以订阅（监听）这个流并按我们所希望的进行处理。</p>
<p>我希望你喜欢这种方法的美丽之处。这个例子仅仅是冰山一角：你可以用这种方法处理不同类型的流。例如：在API返回结果的流中，有很多其他可用的函数。</p>
<p>#“为什么我应该考虑采用FRP？”<br>FRP提高了你的代码的抽象层次，这样你就可以专注于业务逻辑所互相依存的事件中，而不必摆弄大量的实现细节。用FRP写出的代码可能会更简洁。</p>
<p>在现代网络以及移动应用程序中，它的好处更明显，这些应用往往与数据事件相关的UI事件有着高度的交互。10年前，与网页进行交互基本上就是向后端提交一个长的表单，并且在前端进行简单的呈现。而现在，应用程序已经进化到更实时：修改一个变淡字段可以自动触发保存到后端，“喜欢”一些内容可以实时反映给其他已连接的用户，等等。</p>
<p>当今的应用程序都有非常多各式各样的实时事件的使得与用户的高度交互体验成为可能。我们需要适当的工具来妥善处理它，而函数响应式编程就是答案。</p>
<p>#Thinking in FRP，例<br>让我们来考虑一个真正的场景，一个现实世界的例子来一步步引导你如何用FRP进行思考。没有集合的示例，没有解释不完全的内容。在本教程的最后我们将能够产生真正的功能代码，同时我们也会知道为什么我们这样做。</p>
<p>我选择了<b>JavaScript</b>和<a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="external">RxJS</a>作为这例子的工具，只有一个原因：JavaScript是最熟悉的语言，同时<a href="https://rx.codeplex.com/" target="_blank" rel="external">Rx*库家族</a>被广泛用于许多语言和平台。(.NET, Java, Scala, Clojure, JavaScript, Ruby, Python, C++, Objective-C/Cocoa, Groovy, etc).因此，无论你使用什么样的工具，你都可以从接下来的教程中获益。</p>
<p>#实现一个“你可能感兴趣的人”推荐框<br>在Twitter上有一个UI元素用来建议你可以关注的账号<br><img src="https://camo.githubusercontent.com/c30617647900cd2f1e03b2455fc31f72c000f0d2/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f323133303335373061316338633539396535396638663866626461326430336162393433616339622f7a74776974746572626f782e706e67" alt="image"></p>
<p>我们要关注模仿其核心功能，它们是：</p>
<ul>
<li>在开启时，从API读取账号数据并展示3个建议</li>
<li>在点击“刷新”时，向3行读取3个其他账号建议</li>
<li>在点击 “X” 按钮时，关闭其当前对应的账号并显示另外一个</li>
<li>每一行显示账号的头像并链接到它们的主页</li>
</ul>
<p>我们可以省去其他功能和按钮因为它们是次要的。并且Twitter最近关闭了未经授权的公共API。让我们来为Github来构建一个类似的UI。Github提供了获取用户的API。</p>
<p>如果你想要快速浏览的话，完整的代码已经放在<a href="http://jsfiddle.net/staltz/8jFJH/48/了。" target="_blank" rel="external">http://jsfiddle.net/staltz/8jFJH/48/了。</a></p>
<p>#请求和响应</p>
<p><b>如何用FRP解决这个问题？</b>让我们开始，（几乎）所有的东西都可以是一个流。那就是FRP的咒语。让我们从最简单的功能开始：“当启动时，从API获取加载3个账户信息”。这没有任何特别之处，仅仅是(1) 发送一个请求， (2)获取响应 (3)呈现响应。所以我们继续，让我们的请求成为一个流。起初这会觉得有点过于简单了，但是我们需要从最基本的开始，不是吗？</p>
<p>在启动时我们只需要执行一个请求，所以如果我们将其建模为一个数据流，它会是一个只广播一个值的流。之后，我们知道我们会发出很多请求，但现在，只有一个。</p>
<pre><code>--a------|-&gt;

这里a是一个字符串 &apos;https://api.github.com/users&apos;
</code></pre><p>这是一个我们想要请求的URL，当请求事件发生时，它告诉我们两件事情：“什么时候”与“什么”。“什么时候”请求应该被执行，也就是什么时候事件应该被广播。以及“什么”应该被响应，也就是被广播的值是什么：一个包含URL的字符串。</p>
<p>创建一个带有单一值这样的流在Rx*是非常简单的。流的官方术语是“可观测对象”，因为它可以被观测，但是我觉得这是个非常愚蠢的名字，所以我把它成为一个流。</p>
<pre><code>var requestStream = Rx.Observable.returnValue(&apos;https://api.github.com/users&apos;);
</code></pre><p>但是现在，这只是一个字符串的流，没法做其他操作，因此，我们要在这个值被广播的时候触发一些事情。这就是通过<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypesubscribeobserver--onnext-onerror-oncompleted" target="_blank" rel="external">描述</a>这个流做到的。</p>
<pre><code>requestStream.subscribe(function(requestUrl) {
  // 执行请求
  jQuery.getJSON(requestUrl, function(responseData) {
    // ...
  });
}
</code></pre><p>注意我们在使用JQuery Ajax回调（我们假设你应该<a href="http://devdocs.io/jquery/jquery.getjson" target="_blank" rel="external">已经知道了</a>）来处理异步请求。但是等一下，FRP是用来处理异步数据流的。那个请求对应的相应不能是一个包含“将来一段时间会到达数据”的流吗？嗯，在概念的层面上，看起来的确是这样，所以让我们来试一下。<br>    requestStream.subscribe(function(requestUrl) {<br>      // 执行请求<br>      var responseStream = Rx.Observable.create(function (observer) {<br>        jQuery.getJSON(requestUrl)<br>        .done(function(response) { observer.onNext(response); })<br>        .fail(function(jqXHR, status, error) { observer.onError(error); })<br>         .always(function() { observer.onCompleted(); });<br>      });</p>
<pre><code>  responseStream.subscribe(function(response) {
    // 处理响应
  });
}
</code></pre><p><code>Rx.Observable.create()</code>所做的就是通过显式通知每一个观察者（或者说是“订阅者”）数据事件(<code>onNext()</code>)或者错误(<code>onError()</code>)来创造你自己的流。我们刚刚所做的只是包装JQuery Ajax Promise。<b>等一下，这是否说明一个Promise就是一个可观测对象呢？</b></p>
<p><img src="https://camo.githubusercontent.com/4df519edd2d527bf5e90b7d00e22cdc3c3be00d4/687474703a2f2f7777772e6d79666163657768656e2e6e65742f75706c6f6164732f333332342d616d617a65642d666163652e676966" alt="image"></p>
<p>是的。</p>
<p>可观测对象是一个Promise++。在Rx中你可以通过<code>var stream = Rx.Observable.fromPromise(promise)</code>很容易的把一个Promise转化为一个可观测对象，所以我们就这样用吧。唯一的区别在于，可观测对象并不与Promise/A+兼容，但是在概念上是没有冲突的。Promise是一个简单的带有单一广播值的可观测对象。FRP流相比起Promise而言允许很多返回值。</p>
<p>这样很棒，说明了FRP至少和Promise一样强大。如果你相信Promise有点大肆炒作了，那么留意一下FRP的能力。</p>
<p>现在回到我们的例子，如果你注意到了的话，我们在<code>subscribe()</code>中调用了另一个，这看起来就像是传说中的回调地狱。而且，创建<code>responseStream</code>是基于<code>requestStream</code>的。就像你之前听到的那样，在FRP中我们有在其他流以外简单的转换以及创建新的流的方式。我们正应该那样做。</p>
<p>你现在应该知道的一个基本的函数是<code>map(f)</code>，它获取流A中的所有值，对其调用<code>f()</code>，然后产生出流B的一个对应的值。如果我们对我们的请求和响应那样做的话，我们就可以把请求URL映射到响应Promise（伪装成流）中。</p>
<pre><code>var responseMetastream = requestStream
  .map(function(requestUrl) {
    return Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));
  });
</code></pre><p>这样我们就创建了一个名为”metaStream”的野兽：一个流的流。不用惊慌，metastream就是一个流，并且它所广播的值是另一个流。你可以把它想象成是指针：每一个被广播的值是一个指向另一个流的指针。在我们的例子中，每一个请求URL被映射到一个指向包含了对应的响应Promise流的指针。</p>
<p><img src="https://camo.githubusercontent.com/96ffbf34242769e3ffa585594312e6da8a5ab099/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f653866643162623662643933353333636638616661653432626466313962646666393266626332632f7a726573706f6e73656d65746173747265616d2e706e67" alt="image"></p>
<p>一个为响应创建的metaStream看起来让人疑惑，似乎并没有帮助到我们。我们只是想要一个简单的响应流，其中每一个广播的值是一个JSON对象，而不是一个JSON对象的Promise。过来和Flatmap先生问声好吧：它是一种将metaStream“平坦化”的<code>map()</code>，它通过把所有广播给“分支”流的东西广播给“主干”流来实现。Flatmap不是一种“修复”，metaStream也不是一个bug，他们都是用来处理FRP中异步响应的真正的工具。</p>
<pre><code>var responseStream = requestStream
  .flatMap(function(requestUrl) {
    return Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));
  });
</code></pre><p><img src="https://camo.githubusercontent.com/56bb9263de95fdecdcb4fa75c7c8da63cd80f6dc/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f373436613565313733323833363862636261356462643339376238346665383037396565663764642f7a726573706f6e736573747265616d2e706e67" alt="image"></p>
<p>好了，因为我们是根据请求流来定义响应流的，因此如果我们之后在请求流上有更多的的事件发生，那么我们会有对应的事件如预期一样在响应流上发生：</p>
<pre><code>requestStream:  --a-----b--c------------|-&gt;
responseStream: -----A--------B-----C---|-&gt;

(小写字母是一个请求, 大写字母是其对应的响应)
</code></pre><p>这样最终我们就得到了一个响应流，我们可以用它来呈现我们所接收到的数据。</p>
<pre><code>responseStream.subscribe(function(response) {
  // render `response` to the DOM however you wish
});
</code></pre><p>把所有的代码连接起来，现在我们有了：</p>
<pre><code>var requestStream = Rx.Observable.returnValue(&apos;https://api.github.com/users&apos;);

var responseStream = requestStream
  .flatMap(function(requestUrl) {
    return Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));
  });

responseStream.subscribe(function(response) {
  // render `response` to the DOM however you wish
});
</code></pre><p>#刷新按钮</p>
<p>我还没有提交，返回的JSON是一个100用户的列表。API只允许我们指定页的偏移量，不允许指定页的大小，因此我们仅仅使用了3个数据而浪费了其他97个。我们现在暂时可以忽略这个问题，因为之后我们会看到我们是如何缓存响应的。</p>
<p>每次刷新按钮被点击，请求流应该广播一个新的URL，以便于我们得到一个新的响应。我们需要两个东西：一个单击事件的流（任何东西都可以成为流），并且我们需要根据刷新点击流来改变请求流。好在RxJS自带了从事件监听器构造可观测对象的工具。</p>
<pre><code>var refreshButton = document.querySelector(&apos;.refresh&apos;);
var refreshClickStream = Rx.Observable.fromEvent(refreshButton, &apos;click&apos;);
</code></pre><p>既然刷新点击事件自身并不包含任何API URL，我们需要把每一个点击映射到一个实际的URL。现在我们将请求流改变为映射到API端和随机偏移量参数的刷新点击流。</p>
<pre><code>var requestStream = refreshClickStream
  .map(function() {
    var randomOffset = Math.floor(Math.random()*500);
    return &apos;https://api.github.com/users?since=&apos; + randomOffset;
  });
</code></pre><p>因为我是如此的愚蠢，我没有任何自动化的测试，我刚刚弄坏了我们之前构造的功能。现在在加载时不会有请求发出了，它仅仅在刷新按钮单击时才会发出。呃！我需要这两个行为：请求会在刷新单击或者加载时被发出。</p>
<p>我们知道如何为我们两个功能构造不同的流：</p>
<pre><code>var requestOnRefreshStream = refreshClickStream
  .map(function() {
    var randomOffset = Math.floor(Math.random()*500);
    return &apos;https://api.github.com/users?since=&apos; + randomOffset;
  });

var startupRequestStream = Rx.Observable.returnValue(&apos;https://api.github.com/users&apos;);
</code></pre><p>但是现在我们如何才能把它们合二为一呢？嗯，有<code>merge()</code>这个函数。用图来解释，它是这样工作的：</p>
<pre><code>stream A: ---a--------e-----o-----&gt;
stream B: -----B---C-----D--------&gt;
          vvvvvvvvv merge vvvvvvvvv
          ---a-B---C--e--D--o-----&gt;
</code></pre><p>现在它应该变得简单了：</p>
<pre><code>var requestOnRefreshStream = refreshClickStream
  .map(function() {
    var randomOffset = Math.floor(Math.random()*500);
    return &apos;https://api.github.com/users?since=&apos; + randomOffset;
  });

var startupRequestStream = Rx.Observable.returnValue(&apos;https://api.github.com/users&apos;);

var requestStream = Rx.Observable.merge(
  requestOnRefreshStream, startupRequestStream
);
</code></pre><p>这里有一个更干净的方式，不需要中间流：</p>
<pre><code>var requestStream = refreshClickStream
  .map(function() {
    var randomOffset = Math.floor(Math.random()*500);
    return &apos;https://api.github.com/users?since=&apos; + randomOffset;
  })
  .merge(Rx.Observable.returnValue(&apos;https://api.github.com/users&apos;));
</code></pre><p>更短一些，可读性更高一些：</p>
<pre><code>var requestStream = refreshClickStream
  .map(function() {
    var randomOffset = Math.floor(Math.random()*500);
    return &apos;https://api.github.com/users?since=&apos; + randomOffset;
  })
  .startWith(&apos;https://api.github.com/users&apos;);
</code></pre><p><code>startWith()</code>方法按你所想象的那样工作。无论你的输入流看起来什么样，<code>startWith(x)</code>的输出流会在开始包含<code>x</code>，但是我并没有足够的DRY（Don’t Repeat Yourself），我重复了API的字符串。一种修复它的方式是将<code>startWith()</code>移动到<code>refreshClickStream</code>的附近，其本质就是在加载时“模拟”一次刷新操作。</p>
<pre><code>var requestStream = refreshClickStream.startWith(&apos;startup click&apos;)
  .map(function() {
    var randomOffset = Math.floor(Math.random()*500);
    return &apos;https://api.github.com/users?since=&apos; + randomOffset;
  });
</code></pre><p>好的，如果你现在返回我们之前“弄坏自动化测试”的地方，你应该看到两者唯一的区别在于我添加了<code>startWith()</code>。</p>
<p>#用流为3个关注推荐建模<br>直到现在，我们仅仅在发生responseStream的<code>subscribe()</code>的呈现这一步触及到推荐UI元素。现在对于刷新按钮，我们有一个问题：只要你点击了“刷新”，当前的3个推荐并没有被清除。新的推荐仅仅在响应到达之后才能被获取，但是为了让UI看起来能好一些，我们需要在刷新按钮单击时清除当前的推荐。</p>
<pre><code>refreshClickStream.subscribe(function() {
  // clear the 3 suggestion DOM elements 
});
</code></pre><p>不，别那么快，伙计。这样是不好的，因为饿哦们现在有两个能影响推荐DOM元素的订阅者（另一个是<code>responseStream.subscribe()</code>），并且听起来这并没有真正做到关注点隔离。还记得FRP的咒语吗？</p>
<p><img src="https://camo.githubusercontent.com/348b1eb60fa6c0d44d7f091240f0ff462b539619/68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f7374616c747a2f38363865376539626332613762386331663735342f7261772f373936626539623636666637636535386239306536356134396533623938333262383632646564642f7a6d616e7472612e6a7067" alt="image"></p>
<p>因此让我们将推荐建模成一个流，其中每一个被广播的值是一个包含推荐数据的JSON对象。我们会分别为3个推荐做这件事情。我们为推荐1所做的流看起来像是这样：</p>
<pre><code>var suggestion1Stream = responseStream
  .map(function(listUsers) {
    // get one random user from the list
    return listUsers[Math.floor(Math.random()*listUsers.length)];
  });
</code></pre><p>其他的<code>suggestion2Stream</code>和<code>suggestion3Stream</code>可以简单的从<code>suggestion1Stream</code>拷贝过来。这违反了DRY原则，但是这能够让我们的教程示例更简单。而且我任何思考如何避免这种情况是一个很好的锻炼。</p>
<p>不像原来那样在responseStream的<code>subscribe()</code>中进行呈现，我们在这里做：</p>
<pre><code>suggestion1Stream.subscribe(function(suggestion) {
  // render the 1st suggestion to the DOM
});
</code></pre><p>回到“刷新时，清空推荐”，我们可以将刷新点击映射到空的推荐数据，并在<code>suggestion1Stream</code>包含它，像这样：</p>
<pre><code>var suggestion1Stream = responseStream
  .map(function(listUsers) {
    // get one random user from the list
    return listUsers[Math.floor(Math.random()*listUsers.length)];
  })
  .merge(
    refreshClickStream.map(function(){ return null; })
  );
</code></pre><p>当我们呈现时，我们将空解释为“没有数据”，这样来隐藏其UI元素。</p>
<pre><code>suggestion1Stream.subscribe(function(suggestion) {
  if (suggestion === null) {
    // hide the first suggestion DOM element
  }
  else {
    // show the first suggestion DOM element
    // and render the data
  }
});
</code></pre><p>现在蓝图是这样：</p>
<pre><code>refreshClickStream: ----------o--------o----&gt;
     requestStream: -r--------r--------r----&gt;
    responseStream: ----R---------R------R--&gt;   
 suggestion1Stream: ----s-----N---s----N-s--&gt;
 suggestion2Stream: ----q-----N---q----N-q--&gt;
 suggestion3Stream: ----t-----N---t----N-t--&gt;
</code></pre><p>其中<code>N</code>是<code>null</code>的意思</p>
<p>为了做得更好，我们也可以在启动时呈现“空”的推荐。这是通过为推荐流添加<code>startWith(null)</code>来做到的：</p>
<pre><code>var suggestion1Stream = responseStream
  .map(function(listUsers) {
    // get one random user from the list
    return listUsers[Math.floor(Math.random()*listUsers.length)];
  })
  .merge(
    refreshClickStream.map(function(){ return null; })
  )
  .startWith(null);
</code></pre><p>其结果是：</p>
<pre><code>refreshClickStream: ----------o---------o----&gt;
     requestStream: -r--------r---------r----&gt;
    responseStream: ----R----------R------R--&gt;   
 suggestion1Stream: -N--s-----N----s----N-s--&gt;
 suggestion2Stream: -N--q-----N----q----N-q--&gt;
 suggestion3Stream: -N--t-----N----t----N-t--&gt;
</code></pre><p>#关闭推荐并使用被缓存的响应<br>我们还有一个功能需要实现：每一个推荐都应该有一个<code>x</code>按钮来关闭它，并在原地加载另一个推荐。乍一想，你可能想说，每个按钮被点击时发送一个新的请求没什么问题：</p>
<pre><code>var close1Button = document.querySelector(&apos;.close1&apos;);
var close1ClickStream = Rx.Observable.fromEvent(close1Button, &apos;click&apos;);
// and the same for close2Button and close3Button

var requestStream = refreshClickStream.startWith(&apos;startup click&apos;)
  .merge(close1ClickStream) // we added this
  .map(function() {
    var randomOffset = Math.floor(Math.random()*500);
    return &apos;https://api.github.com/users?since=&apos; + randomOffset;
  });
</code></pre><p>这没办法工作。它会关闭并重新加载所有的推荐，而不只是我们点击的那一个。我们有非常多的方式解决这个问题，为了保持这件事情很有趣，我们通过重用之前的响应来解决这个问题。API的页大小为100而我们之前仅仅使用了3个，因此我们还有非常多的新鲜数据可以使用，而不需要更多的请求。</p>
<p>再一次的，让我们用流来思考。当一个<code>close1</code>点击事件发生，我们希望使用最近一次被<code>responseStream</code>广播的响应来从响应列表中得到一个随机的用户。像这样：</p>
<pre><code>    requestStream: --r---------------&gt;
   responseStream: ------R-----------&gt;
close1ClickStream: ------------c-----&gt;
suggestion1Stream: ------s-----s-----&gt;
</code></pre><p>在Rx*中有一个连接符函数被称为<code>combineLatest</code>似乎能解决我们的需求。它包含两个流A和B作为输入，当其中任何一个流广播一个值，<code>combineLatest</code>把两个流中最近被广播的值连接起来，并输出一个结果<code>c = f(x,y)</code>，其中f是一个你定义的函数。用图表来看更容易解释：</p>
<pre><code>stream A: --a-----------e--------i--------&gt;
stream B: -----b----c--------d-------q----&gt;
          vvvvvvvv combineLatest(f) vvvvvvv
          ----AB---AC--EC---ED--ID--IQ----&gt;

f是大写函数
</code></pre><p>我们可以在<code>close1ClickStream</code>和<code>responseStream</code>上使用combineLatest()，因此每当第一个关闭按钮被点击时，我们能广播最近一次的响应并为<code>suggestion1Stream</code>创建一个新的值。另一方面，combineLatest()是对称的：每当一个新的响应被广播到<code>responseStream</code>时，它会结合最近一次的“close 1”点击事件来创建一个新的推荐。这非常有趣，因为它允许我们简化之前<code>suggestion1Stream</code>的代码，如下：</p>
<pre><code>var suggestion1Stream = close1ClickStream
  .combineLatest(responseStream,             
    function(click, listUsers) {
      return listUsers[Math.floor(Math.random()*listUsers.length)];
    }
  )
  .merge(
    refreshClickStream.map(function(){ return null; })
  )
  .startWith(null);
</code></pre><p>还有一个未解的难题。combineLatest()使用最近的两个来源，但是如果其中一个源还未广播任何值，那么combineLatest()不能向输出流创建数据事件。如果你看看上面的ASCII表格，你会发现当第一个流广播值a的时候，我们没有任何输出。直到第二个流广播了一个值b之后我们才得到第一个输出值。</p>
<p>解决之道有很多，我们使用最简单的。即，在开始时模拟一次对”close 1”的点击：</p>
<pre><code>var suggestion1Stream = close1ClickStream.startWith(&apos;startup click&apos;) // we added this
  .combineLatest(responseStream,             
    function(click, listUsers) {l
      return listUsers[Math.floor(Math.random()*listUsers.length)];
    }
  )
  .merge(
    refreshClickStream.map(function(){ return null; })
  )
  .startWith(null);
</code></pre><p>#总结</p>
<p>你得到的所有代码如下：</p>
<pre><code>var refreshButton = document.querySelector(&apos;.refresh&apos;);
var refreshClickStream = Rx.Observable.fromEvent(refreshButton, &apos;click&apos;);

var closeButton1 = document.querySelector(&apos;.close1&apos;);
var close1ClickStream = Rx.Observable.fromEvent(closeButton1, &apos;click&apos;);
// and the same logic for close2 and close3

var requestStream = refreshClickStream.startWith(&apos;startup click&apos;)
  .map(function() {
    var randomOffset = Math.floor(Math.random()*500);
    return &apos;https://api.github.com/users?since=&apos; + randomOffset;
  });

var responseStream = requestStream
  .flatMap(function (requestUrl) {
    return Rx.Observable.fromPromise($.ajax({url: requestUrl}));
  });

var suggestion1Stream = close1ClickStream.startWith(&apos;startup click&apos;)
  .combineLatest(responseStream,             
    function(click, listUsers) {
  return listUsers[Math.floor(Math.random()*listUsers.length)];
}
  )
  .merge(
    refreshClickStream.map(function(){ return null; })
  )
  .startWith(null);
// and the same logic for suggestion2Stream and suggestion3Stream

suggestion1Stream.subscribe(function(suggestion) {
  if (suggestion === null) {
    // hide the first suggestion DOM element
  }
  else {
    // show the first suggestion DOM element
    // and render the data    
  }
});
</code></pre><p><b>你可以在这里找到这个工作示例：<a href="http://jsfiddle.net/staltz/8jFJH/48/" target="_blank" rel="external">http://jsfiddle.net/staltz/8jFJH/48/</a></b></p>
<p>这段代码虽短但是很密集：它包括通过适当分析关注点来管理多种事件，甚至还包括了响应的缓存。函数式风格使代码看起来更像陈述而非命令。我们并不是给定一串指令去执行，我们只是通过定义流之间的关系来完成。比如，我们使用FRP告诉程序<code>suggestion1Stream</code>是<code>close 1</code>流与最近一次响应用户的结合，同时，当刷新或者程序开始发生时将其置为<code>null</code>。</p>
<p>同时，还要注意，代码中包含极少量的逻辑控制语句例如<code>if</code>, <code>for</code>, <code>while</code>，同时也没有JavaScript应用中常见的回调风格的控制流，这非常令人印象深刻。如果你想的话，你甚至可以在上述<code>subscribe()</code>中完全移除<code>if</code>和<code>else</code>而使用<code>filter()</code>（我将把实现细节留给你做练习）。在FRP中，我们有与流相关的函数例如<code>map</code>, <code>filter</code>, <code>scan</code>, <code>merge</code>, <code>combineLatest</code>, <code>startWith</code>，以及更多的控制事件驱动程序流程的函数。这个函数工具集允许你完成更多功能而使用更少的代码。</p>
<p>#接下来的事情</p>
<p>如果你认为Rx*会成为你FRP的首选库，你需要花点时间来了解非常长的函数列表函数列表包括：变形、合并以及创建Observable。如果你想要通过流的图表来理解这些函数，<a href="https://github.com/Netflix/RxJava/wiki/Creating-Observables" target="_blank" rel="external">看一看RxJava的非常有用的文档</a>。无论什么时候你陷入困境，试着画出这些图，思考他们，看看这一长串的函数列表，然后更多的思考。以我的经验来看这个工作方法非常有效。</p>
<p>一旦你开始使用Rx*开始编程，你绝对需要理解<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables" target="_blank" rel="external">Cold vs Hot Observables</a>的内容。如果你忽略了它，它早晚会回来痛咬你的。我已经警告过你了。通过学习函数式编程进一步提高你的技巧，并熟悉影响Rx*的副作用。</p>
<p>然而函数响应式编程并不仅仅是Rx*。你可以使用Bacon.js来直观的使用它，而不需要理会那些在使用Rx*时会遇到的奇怪的问题。Elm语言，则是自成一派：它是一个可以编译成JavaScript + HTML + CSS的FRP语言，还有一个时间浏览的调试器。它非常棒。</p>
<p>FRP非常适合重事件的前端程序或应用程序。但是这并不仅仅是客户端的事情。它在后端以及贴近数据库的场景也能有很好的发挥。事实上，RxJava在Netflix的API中是一个允许服务器端进行并发执行的重要组件。FRP不是一个局限于特定类型的应用程序或者语言的框架。它是一个你在编写任何事件驱动软件时都可以使用的范例。</p>
<p>如果这篇文章帮到了你，记得<a href="https://twitter.com/intent/tweet?original_referer=https%3A%2F%2Fgist.github.com%2Fstaltz%2F868e7e9bc2a7b8c1f754%2F&amp;text=The%20introduction%20to%20Reactive%20Programming%20you%27ve%20been%20missing&amp;tw_p=tweetbutton&amp;url=https%3A%2F%2Fgist.github.com%2Fstaltz%2F868e7e9bc2a7b8c1f754&amp;via=andrestaltz" target="_blank" rel="external">来Twitter转发</a>~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你所期待已久的函数响应式编程简介&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://gist.github.com/staltz/868e7e9bc2a7b8c1f754&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://gist.gi
    
    </summary>
    
    
      <category term="translation" scheme="http://nnabuuu.github.io/blog-hexo/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>migrateToHexo</title>
    <link href="http://nnabuuu.github.io/blog-hexo/2014/06/29/migrateToHexo/"/>
    <id>http://nnabuuu.github.io/blog-hexo/2014/06/29/migrateToHexo/</id>
    <published>2014-06-30T05:46:31.000Z</published>
    <updated>2016-04-29T18:43:51.173Z</updated>
    
    <content type="html"><![CDATA[<p>Just come to hexo, YaY~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Just come to hexo, YaY~&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
