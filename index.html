<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://nnabuuu.github.io/blog-hexo/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog-hexo/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog-hexo/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog-hexo/">Home</a>
        
          <a class="main-nav-link" href="/blog-hexo/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Zoeken"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://nnabuuu.github.io/blog-hexo"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-How-many-kinds-of-squares-password" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2016/08/15/How-many-kinds-of-squares-password/" class="article-date">
  <time datetime="2016-08-16T05:45:14.000Z" itemprop="datePublished">2016-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2016/08/15/How-many-kinds-of-squares-password/">How many kinds of squares password</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#</p>
<p>上礼拜和yld吃饭，聊了聊最近的业内优秀开源项目以及算法方面的东西。yld表示自己当年能够用笔一字不改的手撕KMP算法，对现在功力的退步表示遗憾。<br>然后闲聊之际yld掏出手机解锁，由此引申出一道算法题：九宫格密码到底有多少种？</p>
<h1 id="九宫格密码"><a href="#九宫格密码" class="headerlink" title="九宫格密码"></a>九宫格密码</h1><p>经过尝试，安卓系统的九宫格密码有这样一些限制条件，假设九宫格的布局如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure></p>
<p>那么：</p>
<ol>
<li>至少使用4个点</li>
<li>不能重复经过同一个点</li>
<li>路径上的中间点不能跳过（例如 1 -&gt; 3 -&gt; 6 -&gt; 9 是不合法的，因为2被跳过了）</li>
<li>如果中间的点之前已经用过，那么该点就可以被跳过（例如 2 -&gt; 1 -&gt; 3 -&gt; 6是合法的，因为在 1 -&gt; 3之前2已经被使用过）</li>
</ol>
<h1 id="首先考虑最简单的情况"><a href="#首先考虑最简单的情况" class="headerlink" title="首先考虑最简单的情况"></a>首先考虑最简单的情况</h1><p>首先只考虑条件1和条件2，那么这种排列组合的方式一共有<code>A(9, 4) + A(9, 5) + A(9, 6) + A(9, 7) + A(9, 8) + A(9, 9)</code>种。<br>当然，如果你就直接把这个答案写上去的话我们就没办法继续往下写了。所以我们还是用代码一个一个的数出来吧-。-</p>
<p>（最近在学习scala，我用scala练习一下）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">object PasswordPermutation &#123;</span><br><span class="line"></span><br><span class="line">  //长度为m的排列组合</span><br><span class="line">  def password_permutation_with_length(n: Int, m: Int) = &#123;</span><br><span class="line"></span><br><span class="line">      def helper(llist: List[List[Int]], n:Int, m: Int): List[List[Int]] = &#123;</span><br><span class="line">        if(m == 0) llist</span><br><span class="line">        else &#123;</span><br><span class="line">          val pre_list = for(list &lt;- llist ; i &lt;- 1 to n; if(!list.contains(i))) yield</span><br><span class="line">              list ++ List(i)</span><br><span class="line">          helper(pre_list, n, m-1)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      helper(List(Nil), n, m)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //满足条件1 2 的排列组合</span><br><span class="line">  def  password_permutation(n: Int) = (for(i &lt;- (4 to n).toList)</span><br><span class="line">                          yield password_permutation_with_length(n, i)).flatten</span><br><span class="line"></span><br><span class="line">  //测试</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">    val result = password_permutation(9)</span><br><span class="line">    println(&quot;count:&quot; + result.length)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="然后加入限制条件"><a href="#然后加入限制条件" class="headerlink" title="然后加入限制条件"></a>然后加入限制条件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">object PasswordPermutation &#123;</span><br><span class="line"></span><br><span class="line">  //所有规则3禁止的类别</span><br><span class="line">  val forbidden:Map[Int, List[Int]] = Map(</span><br><span class="line">    1 -&gt; List(3, 7, 9),</span><br><span class="line">    2 -&gt; List(8),</span><br><span class="line">    3 -&gt; List(1, 7, 9),</span><br><span class="line">    4 -&gt; List(6),</span><br><span class="line">    5 -&gt; Nil,</span><br><span class="line">    6 -&gt; List(4),</span><br><span class="line">    7 -&gt; List(1, 3, 9),</span><br><span class="line">    8 -&gt; List(2),</span><br><span class="line">    9 -&gt; List(1, 3, 7)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  //规则3与规则4的限制条件</span><br><span class="line">  def is_forbidden(list: List[Int], i: Int) = &#123;</span><br><span class="line">    if(list isEmpty) false</span><br><span class="line">    else forbidden(list.last).contains(i) &amp;&amp; !list.contains((list.last + i)/2)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //长度为m的排列组合（加入限制条件3 4）</span><br><span class="line">  def password_permutation_with_length(n: Int, m: Int) = &#123;</span><br><span class="line"></span><br><span class="line">      def helper(llist: List[List[Int]], n:Int, m: Int): List[List[Int]] = &#123;</span><br><span class="line">        if(m == 0) llist</span><br><span class="line">        else &#123;</span><br><span class="line">          val pre_list = for(list &lt;- llist ; i &lt;- 1 to n; if(!list.contains(i) &amp;&amp; !is_forbidden(list, i))) yield</span><br><span class="line">              list ++ List(i)</span><br><span class="line">          helper(pre_list, n, m-1)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      helper(List(Nil), n, m)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  //满足条件1 2 3 4的排列组合</span><br><span class="line">  def  password_permutation(n: Int) = (for(i &lt;- (4 to n).toList)</span><br><span class="line">                          yield password_permutation_with_length(n, i)).flatten</span><br><span class="line"></span><br><span class="line">  //测试</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">    val result = password_permutation(9)</span><br><span class="line">    println(&quot;count:&quot; + result.length)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行得到结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count:389112</span><br></pre></td></tr></table></figure></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>原来只是这么简单一道题目啊-。- 还以为发现了不得了的东西呢-。-</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2016/08/15/How-many-kinds-of-squares-password/" data-id="cirx40r2j0007scnbdk5g5kp7" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/algorithm/">algorithm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-fix-docker-x509-error" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2016/08/03/fix-docker-x509-error/" class="article-date">
  <time datetime="2016-08-03T09:24:59.000Z" itemprop="datePublished">2016-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2016/08/03/fix-docker-x509-error/">fix-docker-x509-error</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>问题描述</li>
</ol>
<p>由于公司内部证书被IT部门修改，我们在使用docker pull某些镜像的时候会抛出x509错误 x509: certificate signed by unknown authority。<br>例如，我在尝试用docker-compose获取最新版本的spark时会显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">abuuu-VirtualBox# sudo docker-compose up</span><br><span class="line">Pulling master (gettyimages/spark:latest)...</span><br><span class="line">latest: Pulling from gettyimages/spark</span><br><span class="line">357ea8c3d80b: Pulling fs layer</span><br><span class="line">c6cf625461b9: Pulling fs layer</span><br><span class="line">06fd4f43f066: Pulling fs layer</span><br><span class="line">dd98390795f4: Waiting</span><br><span class="line">36769b1579ad: Waiting</span><br><span class="line">b2e57763c10f: Waiting</span><br><span class="line">ERROR: error pulling image configuration: Get https://dseasb33srnrn.cloudfront.net/registry-v2/docker/registry/v2/blobs/sha256/4e/4ef9bff9a39ea255de6945d1480a771b4785b17a0da492fd6427e98ec5d624dd/data?Expires=1470184587&amp;Signature=TpEb2htK0E8yUKVinb03onAc35rMqzC4JPJeWnXQ1DkmFifVORmP9-Vusc8vtZjFG3yCyWgfIL8zRVLhmj3koVtb~QLcx5eHcmHprzj6nxXt~GC-MuUT91t65Q2eOqwQDNQAwlcPxP9moxggWmoGQaHyII0bIwBtvdZ7GiUnE0w_&amp;Key-Pair-Id=APKAJECH5M7VWIS5YZ6Q: x509: certificate signed by unknown authority</span><br></pre></td></tr></table></figure>
<p>我们可以看出，在访问dseasb33srnrn.cloudfront.net时产生了证书验证错误。</p>
<ol>
<li>解决方法</li>
</ol>
<p>参考<a href="http://www.cnblogs.com/sting2me/p/5596222.html上描述的方式，用openssl访问该网站，并将被替换后的证书保存至本地并用update-ca-certificates更新：" target="_blank" rel="external">http://www.cnblogs.com/sting2me/p/5596222.html上描述的方式，用openssl访问该网站，并将被替换后的证书保存至本地并用update-ca-certificates更新：</a></p>
<p>代码如下(在Ubuntu14.04下测试通过)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo -n | openssl s_client -showcerts -connect dseasb33srnrn.cloudfront.net:443 2&gt;/dev/null | sed -ne &apos;/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p&apos; &gt; /usr/local/share/ca-certificates/cloudfront.crt</span><br><span class="line">update-ca-certificates</span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>
<p>然后重新执行就会发现成功了，从此以后就可以在上班的时候轻松摸鱼了（误）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2016/08/03/fix-docker-x509-error/" data-id="cirx40r4i000sscnbk5s36vbq" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/docker/">docker</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Parsing-text-table-with-jison-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2016/04/29/Parsing-text-table-with-jison-3/" class="article-date">
  <time datetime="2016-04-29T18:58:45.000Z" itemprop="datePublished">2016-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2016/04/29/Parsing-text-table-with-jison-3/">Parsing-text-table-with-jison-3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2016/04/29/Parsing-text-table-with-jison-3/" data-id="cirx40r3i000gscnbe8cev9h5" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Parsing-text-table-with-jison-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2016/04/28/Parsing-text-table-with-jison-2/" class="article-date">
  <time datetime="2016-04-28T07:11:16.000Z" itemprop="datePublished">2016-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2016/04/28/Parsing-text-table-with-jison-2/">Parsing-text-table-with-jison-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="用jison解析一个文本表格2"><a href="#用jison解析一个文本表格2" class="headerlink" title="用jison解析一个文本表格2"></a>用jison解析一个文本表格2</h1><p>在上一篇文章中，我们完成了一个最初版本的的Parser，它可以用来解析一个基本的表格文本。接下来，我们将以此为基础逐步完善更多内容。</p>
<h3 id="将表格内容存入对象-Store-cells-in-an-object-instead-of-array"><a href="#将表格内容存入对象-Store-cells-in-an-object-instead-of-array" class="headerlink" title="将表格内容存入对象 Store cells in an object instead of array"></a>将表格内容存入对象 Store cells in an object instead of array</h3><p>我们知道在bison中，使用者可以通过yylval保存全局变量。类似的，在jison中，我们可以通过全局变量yy来储存。<br>见<a href="http://zaa.ch/jison/docs/#sharing-scope" target="_blank" rel="external">官网描述：http://zaa.ch/jison/docs/#sharing-scope</a></p>
<p>那么，首先我们好奇的是，这个变量yy到底包含哪些内容。我们在执行时将它输出到控制台一探究竟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123; lexer:</span><br><span class="line">  &#123;</span><br><span class="line">    yy: [Circular],</span><br><span class="line">    _input: &apos;&apos;,</span><br><span class="line">    done: true,</span><br><span class="line">    _backtrack: false,</span><br><span class="line">    _more: false,</span><br><span class="line">    yyleng: 0,</span><br><span class="line">    yylineno: 16,</span><br><span class="line">    match: &apos;&apos;,</span><br><span class="line">    matched: &apos;+---------------------------------+---------+----------------+---------------+\r\n| VM | State | VM Type | IP |\r\n+---------------------------------+---------+----------------+---------------+\r\n| a/0 | running | a | 192.168.1.159 |\r\n| b/0 | running | b | 192.168.1.161 |\r\n| b/1 | running | b | 192.168.1.162 |\r\n| b/2 | running | b | 192.168.1.163 |\r\n| eeee/0 | running | iiiiiiiiiiiiii | 192.168.1.164 |\r\n| haaaaaaa/0 | running | iiiiiiiiiiiiii | 192.168.1.168 |\r\n| c/0 | running | iiiiiiiiiiiiii | 192.168.1.166 |\r\n| lllllllllloooooooooolllllller/0 | running | iiiiiiiiiiiiii | 192.168.1.167 |\r\n| n1/0 | running | iiiiiiiiiiiiii | 192.168.1.156 |\r\n| n2/0 | running | iiiiiiiiiiiiii | 192.168.1.157 |\r\n| n3/0 | running | iiiiiiiiiiiiii | 192.168.1.158 |\r\n| n4/0 | running | iiiiiiiiiiiiii | 192.168.1.165 |\r\n| u1/0 | running | iiiiiiiiiiiiii | 192.168.1.160 |\r\n+---------------------------------+---------+----------------+---------------+&apos;,</span><br><span class="line">    yytext: &apos;&apos;,</span><br><span class="line">    conditionStack: [ &apos;INITIAL&apos; ],</span><br><span class="line">    yylloc:</span><br><span class="line">    &#123;</span><br><span class="line">      first_line: 17,</span><br><span class="line">      last_line: 17,</span><br><span class="line">      first_column: 78,</span><br><span class="line">      last_column: 78 &#125;,</span><br><span class="line">    offset: 0,</span><br><span class="line">    matches: [ &apos;&apos;, index: 0, input: &apos;&apos; ] &#125;,</span><br><span class="line">    parser: &#123; yy: &#123;&#125;, parseError: [Function: parseError] &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，yy中储存了多个运行时用到的变量。我们很容易在里面找到bison中其他变量的对应，例如yytext和yyleng。<br>这些变量在语法解析的过程中均可以被访问到，因此，我们大胆猜想一下，如果我们想要保存/使用自己的变量，或许可以直接通过yy.myVarible进行访问。<br>我们修改jison文件如下（仅标出修改部分），并保存为table-v2.jison：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">%lex</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">yy.convert = function(obj, header)&#123;</span><br><span class="line">  for(var i=0;i&lt;obj._content.length;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    obj[header[i]]=obj._content[i];</span><br><span class="line">  &#125;</span><br><span class="line">  delete obj._content;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">headerline</span><br><span class="line">  : line</span><br><span class="line">    &#123;</span><br><span class="line">      yy.header = [];</span><br><span class="line">      for(var i=0;i&lt;$1._content.length;i++)&#123;</span><br><span class="line">        yy.header.push($1._content[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      $$ = $1;</span><br><span class="line">    &#125;</span><br><span class="line">  ;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">content</span><br><span class="line">  : line</span><br><span class="line">    &#123;</span><br><span class="line">      $$ = &#123;_content: []&#125;;</span><br><span class="line">      $$._content.push(yy.convert($1,yy.header));</span><br><span class="line">    &#125;</span><br><span class="line">  | content line</span><br><span class="line">    &#123;</span><br><span class="line">      $1._content.push(yy.convert($2,yy.header));</span><br><span class="line">      $$ = $1;</span><br><span class="line">    &#125;</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>再运行下面的代码看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jison table-v2.jison</span><br><span class="line">node table-v2.js sample.txt</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123; _content:</span><br><span class="line">  [ &#123; VM: &apos;a/0&apos;,</span><br><span class="line">  State: &apos;running&apos;,</span><br><span class="line">  &apos;VM Type&apos;: &apos;a&apos;,</span><br><span class="line">  IP: &apos;192.168.1.159&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;b/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;b&apos;,</span><br><span class="line">    IP: &apos;192.168.1.161&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;b/1&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;b&apos;,</span><br><span class="line">    IP: &apos;192.168.1.162&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;b/2&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;b&apos;,</span><br><span class="line">    IP: &apos;192.168.1.163&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;eeee/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;iiiiiiiiiiiiii&apos;,</span><br><span class="line">    IP: &apos;192.168.1.164&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;haaaaaaa/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;iiiiiiiiiiiiii&apos;,</span><br><span class="line">    IP: &apos;192.168.1.168&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;c/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;iiiiiiiiiiiiii&apos;,</span><br><span class="line">    IP: &apos;192.168.1.166&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;lllllllllloooooooooolllllller/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;iiiiiiiiiiiiii&apos;,</span><br><span class="line">    IP: &apos;192.168.1.167&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;n1/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;iiiiiiiiiiiiii&apos;,</span><br><span class="line">    IP: &apos;192.168.1.156&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;n2/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;iiiiiiiiiiiiii&apos;,</span><br><span class="line">    IP: &apos;192.168.1.157&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;n3/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;iiiiiiiiiiiiii&apos;,</span><br><span class="line">    IP: &apos;192.168.1.158&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;n4/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;iiiiiiiiiiiiii&apos;,</span><br><span class="line">    IP: &apos;192.168.1.165&apos; &#125;,</span><br><span class="line">    &#123; VM: &apos;u1/0&apos;,</span><br><span class="line">    State: &apos;running&apos;,</span><br><span class="line">    &apos;VM Type&apos;: &apos;iiiiiiiiiiiiii&apos;,</span><br><span class="line">    IP: &apos;192.168.1.160&apos; &#125; ] &#125;</span><br></pre></td></tr></table></figure>
<p>干的不错，我们成功的将表格内容存入了对应的对象中，收工！</p>
<h3 id="一些jison的坑"><a href="#一些jison的坑" class="headerlink" title="一些jison的坑"></a>一些jison的坑</h3><p>从上面的代码中可以看到，我在预编译阶段声明并定义了yy.convert函数。我们可以在语法分析阶段直接使用该函数。<br>但是，如果我们在预编译阶段声明我们要用到的变量例如<code>yy.header = [];</code>，则会出现严重问题。Jison在每一个语法匹配完成之后将重置yy.header为最初声明的空的Array。导致在匹配<code>content</code>语法时无法拿到正确的yy.header。<br>因此，我将yy.header的初始化放到了headerline的处理逻辑中，以此绕过这个坑。<br>我已经在github题了一个<a href="https://github.com/zaach/jison/issues/327" target="_blank" rel="external">issue</a>，暂时没有人回复。。。</p>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>我想到可以继续扩展的功能点包括：</p>
<ol>
<li>多行Header</li>
<li>表格中有空的Cell</li>
</ol>
<p>这些会在接下来的文章中一一补充。</p>
<p>众人：才刚刚填了一个坑立马又挖了两个，眼看着就要烂尾了。。<br>abuuu：就算烂尾我也要挖-。-！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2016/04/28/Parsing-text-table-with-jison-2/" data-id="cirx40r36000ascnbzmegvz4c" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/NodeJS/">NodeJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/jison/">jison</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Parsing-text-table-with-jison" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2016/04/21/Parsing-text-table-with-jison/" class="article-date">
  <time datetime="2016-04-21T23:02:41.000Z" itemprop="datePublished">2016-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2016/04/21/Parsing-text-table-with-jison/">Parsing-text-table-with-jison</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="用jison解析一个文本表格"><a href="#用jison解析一个文本表格" class="headerlink" title="用jison解析一个文本表格"></a>用jison解析一个文本表格</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文受到文章<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=210542047&amp;idx=1&amp;sn=9c813595c727c0fa028651b9dcdbab12" target="_blank" rel="external">如何愉快地写个小parser</a>的启发，尝试用文中所介绍的Jison来进行文本解析处理。</p>
<h3 id="什么是Jison"><a href="#什么是Jison" class="headerlink" title="什么是Jison"></a>什么是Jison</h3><p>Jison的<a href="http://zaa.ch/jison/about/" target="_blank" rel="external">官网介绍</a>是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parsers help computers derive meaning from arbitrary text. And Jison helps you build parsers!</span><br><span class="line"></span><br><span class="line">Jison is essentially a clone of the parser generator Bison (thus Yacc,) but in JavaScript. It includes its own lexical analyzer modeled after Flex.</span><br></pre></td></tr></table></figure>
<p>Jison是一个”Bison in JavaScript”。也就是说，首先Jison是一个类似Bison的parser生成器。区别在于，Jison使用JavaScript编写，可以同时用于NodeJS和浏览器执行环境中。</p>
<p>Jison的安装请参照<a href="http://zaa.ch/jison/docs/，在NodeJS的开发环境中使用`npm" target="_blank" rel="external">http://zaa.ch/jison/docs/，在NodeJS的开发环境中使用`npm</a> install jison -g`即可完成安装。</p>
<h3 id="使用Jison"><a href="#使用Jison" class="headerlink" title="使用Jison"></a>使用Jison</h3><p>这里我们用一个简单的例子来介绍如何使用Jison。</p>
<p>最近的工作都在使用CloudFoundry，在使用BOSH的时候经常需要通过<code>bosh vms</code>去抓ip地址。这个命令会返回一个类似于下面格式的表格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---------------------------------+---------+----------------+---------------+</span><br><span class="line">| VM                              | State   | VM Type        | IP            |</span><br><span class="line">+---------------------------------+---------+----------------+---------------+</span><br><span class="line">| a/0                             | running | a              | 192.168.1.159 |</span><br><span class="line">| b/0                             | running | b              | 192.168.1.161 |</span><br><span class="line">| b/1                             | running | b              | 192.168.1.162 |</span><br><span class="line">| b/2                             | running | b              | 192.168.1.163 |</span><br><span class="line">| eeee/0                          | running | iiiiiiiiiiiiii | 192.168.1.164 |</span><br><span class="line">| haaaaaaa/0                      | running | iiiiiiiiiiiiii | 192.168.1.168 |</span><br><span class="line">| c/0                             | running | iiiiiiiiiiiiii | 192.168.1.166 |</span><br><span class="line">| lllllllllloooooooooolllllller/0 | running | iiiiiiiiiiiiii | 192.168.1.167 |</span><br><span class="line">| n1/0                            | running | iiiiiiiiiiiiii | 192.168.1.156 |</span><br><span class="line">| n2/0                            | running | iiiiiiiiiiiiii | 192.168.1.157 |</span><br><span class="line">| n3/0                            | running | iiiiiiiiiiiiii | 192.168.1.158 |</span><br><span class="line">| n4/0                            | running | iiiiiiiiiiiiii | 192.168.1.165 |</span><br><span class="line">| u1/0                            | running | iiiiiiiiiiiiii | 192.168.1.160 |</span><br><span class="line">+---------------------------------+---------+----------------+---------------+</span><br></pre></td></tr></table></figure>
<p>对于这样一个格式规整的多行文本，如果用正则表达式去匹配整个表格并提取所有的内容，写出的代码可维护性会比较差。我们下面思考一下如何使用Jison来创建一个parser解析这个表格。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先做词法分析，</p>
<p><img src="https://raw.githubusercontent.com/nnabuuu/blog-hexo/gh-pages/img/Parsing-text-table-with-jison/LexicalAnalysis.png" alt=""></p>
<p>通过如下的正则表达式来描述所有的词法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\s+                                 /* skip whitespace */</span><br><span class="line">&lt;&lt;EOF&gt;&gt;               return &apos;EOF&apos;  /* End of file*/</span><br><span class="line">&quot;+&quot;                   return &apos;HEAD&apos; /* Header of the separate line */</span><br><span class="line">(&quot;-&quot;)+&quot;+&quot;             return &apos;TAIL&apos; /* Tail of the separate line */</span><br><span class="line">[^+|-]*[^\s+|-]		    return &apos;CELL&apos; /* Content in the cell, this is what we want */</span><br><span class="line">&quot;|&quot;                   return &apos;|&apos;    /* Vertical bar of the cell */</span><br></pre></td></tr></table></figure></p>
<p>然后是语法分析，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">%start table</span><br><span class="line"></span><br><span class="line">%% /* language grammar */</span><br><span class="line"></span><br><span class="line">table</span><br><span class="line">    : separateline headerline separateline content separateline EOF</span><br><span class="line">        &#123;</span><br><span class="line">          console.log(&#123;header: $2, body: $4&#125;); // Print out for debug</span><br><span class="line">          return &#123;header: $2, body: $4&#125;;       // Separate lines are ignored</span><br><span class="line">        &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">separateline</span><br><span class="line">    : HEAD</span><br><span class="line">        &#123;$$ = $1;&#125;</span><br><span class="line">    | separateline TAIL</span><br><span class="line">        &#123;$$ = $1 + $2;&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">headerline</span><br><span class="line">    : line</span><br><span class="line">		    &#123;$$ = $1&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">content</span><br><span class="line">    :  line</span><br><span class="line">       &#123;$$ = &#123;content: []&#125;;$$.content.push($1);&#125;</span><br><span class="line">    |  content + line</span><br><span class="line">       &#123;$1.content.push($2); $$ = $1;&#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">line</span><br><span class="line">    : &apos;|&apos;</span><br><span class="line">        &#123;$$ = &#123;content: []&#125;;&#125;</span><br><span class="line">    |  line CELL &apos;|&apos;</span><br><span class="line">        &#123;$1.content.push($2); $$ = $1;&#125;</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>最后我们得到了jison文件<a href="https://gist.github.com/nnabuuu/e35074b7b34b2324aa478de74e097203" target="_blank" rel="external">table-v1.jison</a></p>
<h3 id="生成parser"><a href="#生成parser" class="headerlink" title="生成parser"></a>生成parser</h3><p>我们使用jison命令生成对应的parser：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jison table-v1.jison</span><br></pre></td></tr></table></figure></p>
<p>执行之后，我们会得到名为table-v1.js的parser文件，该文件可以直接使用进行parse。我们首先将表格文本保存为sample.txt。然后执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node table-v1.js sample.txt</span><br></pre></td></tr></table></figure>
<p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123; header: &#123; content: [ &apos;VM&apos;, &apos;State&apos;, &apos;VM Type&apos;, &apos;IP&apos; ] &#125;,</span><br><span class="line">  body:</span><br><span class="line">   &#123; content:</span><br><span class="line">      [ [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object],</span><br><span class="line">        [Object] ] &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，即完成了一个简单的解析。</p>
<h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>当然，仅仅解析成这样是不够的，我们希望最后能够得到一个这样的“开箱即用”的结果格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;     [ &#123;&apos;VM&apos;: &apos;a/0&apos;, &apos;State&apos;: &apos;running&apos;, &apos;VM Type&apos;: &apos;a&apos;, &apos;IP&apos;: &apos;192.168.1.159&apos;&#125;,</span><br><span class="line">        &#123;&apos;VM&apos;: &apos;b/0&apos;, &apos;State&apos;: &apos;running&apos;, &apos;VM Type&apos;: &apos;b&apos;, &apos;IP&apos;: &apos;192.168.1.161&apos;&#125;,</span><br><span class="line">        ...</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们要怎么做呢？</p>
<p>且听下回分解。</p>
<p>另：<br>后面会完成的内容：<br>table-v1.jison重构为table-v2.jison<br>通过NodeJS封装parser调用<br>NodeJS与BOSH的集成<br>将parser服务化，对外提供service</p>
<p>众人：abuuu同学你列了这么多后面烂尾了怎么办<br>abuuu：那就删掉啊，不然要怎样（手动白眼）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2016/04/21/Parsing-text-table-with-jison/" data-id="cirx40r3f000escnbdke6pdb5" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/NodeJS/">NodeJS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/jison/">jison</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Tail-Recursion-in-Haskell" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2015/10/31/Tail-Recursion-in-Haskell/" class="article-date">
  <time datetime="2015-11-01T05:30:36.000Z" itemprop="datePublished">2015-10-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2015/10/31/Tail-Recursion-in-Haskell/">Tail Recursion in Haskell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Today I was solving the problem of “calculate Fibonacci sequence” in Haskell.</p>
<p>The normal fibonacci function is implemented as:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fib</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="title">fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="title">fib</span> n = fib (n - <span class="number">1</span>) + fib (n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>However, this implement runs very slow.</p>
<p>There is one possible way to optimize the code as follow:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fib</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">fib</span> n = aux n (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">where</span> aux n (a, b) | n == <span class="number">0</span> = a</span><br><span class="line">                          | otherwise = aux (n - <span class="number">1</span>) (b, a + b)</span><br></pre></td></tr></table></figure>
<p>This version is a lot faster than the original version. Why?</p>
<p>The trick is tail recursion.</p>
<p>In previous code, when executing <code>fib n = fib (n - 1) + fib (n - 2)</code>, there is context switch by pushing current context into call stack in order to resume after <code>fib (n - 1)</code> and <code>fib (n - 2)</code> are calculated.</p>
<p>However, by using tail recursion, because our function <code>aux n (a, b)</code> directly return the result from <code>aux (n - 1) (b, a + b)</code>, program can re-use current stack space without change.</p>
<p>This video is a very good explanation:</p>
<p><a href="https://www.youtube.com/watch?v=L1jjXGfxozc" target="_blank" rel="external">https://www.youtube.com/watch?v=L1jjXGfxozc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2015/10/31/Tail-Recursion-in-Haskell/" data-id="cirx40r4p000vscnb3v8awkyo" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/Haskell/">Haskell</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Getting-Concurrent-With-ES6-Generators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2015/01/04/Getting-Concurrent-With-ES6-Generators/" class="article-date">
  <time datetime="2015-01-05T05:44:36.000Z" itemprop="datePublished">2015-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2015/01/04/Getting-Concurrent-With-ES6-Generators/">Getting Concurrent With ES6 Generators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#用generator实现并发（译）</p>
<p>原文地址：<a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">http://davidwalsh.name/concurrent-generators</a></p>
<p>ES6 Generators：全系列</p>
<ol>
<li><a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">The Basics Of ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">Diving Deeper With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">Getting Concurrent With ES6 Generators</a></li>
</ol>
<p>如果你已经阅读并消化了本系列的第一、第二和第三章节，你应该对ES6 generator已经相当有把握了。希望你真正的被激发来开始用它们做一些事情。</p>
<p>我们要探索的最后的话题是比较前沿的东西，它可能会让你的大脑有点混乱（老实的说，我的大脑仍然处于混乱状态）。所以慢慢的看完并且思考这些概念以及例子。并且还需要读一读其他关于这个话题的文章。</p>
<p>你在这里所做的投入，会从一个长远的角度给你带来回报。我完全确信JS完美的异步能力的未来会来自于这些概念。</p>
<h2 id="标准CSP（Communicating-Sequential-Processes）"><a href="#标准CSP（Communicating-Sequential-Processes）" class="headerlink" title="标准CSP（Communicating Sequential Processes）"></a>标准CSP（Communicating Sequential Processes）</h2><p>受限，我受到这个话题的激发完全是来自于<a href="http://github.com/swannodette" target="_blank" rel="external">David Nolen</a> <a href="http://twitter.com/swannodette" target="_blank" rel="external">@swannodette</a>。严肃的说，他所写得一切文章都值得一读。这里有一些可以让你起步的链接：</p>
<ul>
<li><a href="http://swannodette.github.io/2013/07/12/communicating-sequential-processes/" target="_blank" rel="external">“Communicating Sequential Processes”</a></li>
<li><a href="http://swannodette.github.io/2013/08/24/es6-generators-and-csp/" target="_blank" rel="external">“ES6 Generators Deliver Go Style Concurrency”</a></li>
<li><a href="http://swannodette.github.io/2013/07/31/extracting-processes/" target="_blank" rel="external">“Extracting Processes”</a></li>
</ul>
<p>好的，下面我就来讲一讲我在这个题目上的探索。我并不是从一个正式的Clojure背景转向JS的，我也没有GO或者ClojureScript相关的经验。我很快发现我迷失在这些文章中，并且我必须要做大量的实验和猜测来收集这些文章中有用的部分。</p>
<p>在探索的过程中，我认为我已经学到了一些目标以及精神都想通的东西，但来自于并不是那么古板的思维方式。</p>
<p>我试图要做的是简历一个简单的Go-风格的CSP（已经ClojureScript core.async）API，同时（我希望）保留大部分潜在的能力。当然，那些比我聪明的人完全有可能迅速地看到我目前为止探索过程中错过的部分。如果这牙膏的话，我希望我的探索能够继续进行下去，并且我会继续和我们分享我的启示！</p>
<h2 id="（部分）分解CSP理论"><a href="#（部分）分解CSP理论" class="headerlink" title="（部分）分解CSP理论"></a>（部分）分解CSP理论</h2><p>CSP是讲些什么的？它提到的“communicating”、“Sequential”是什么？“Processes”又是什么？</p>
<p>首先，CSP来自于<a href="http://www.usingcsp.com/" target="_blank" rel="external">Tony Hoare的书”Communicating Sequential Processes”</a>。这是一些厚重的CS理论的东西，但如果你有兴趣在学术范围有所建树的话，那么这是最好的开始的地方。当然我并不是要用一种深奥的、令人头痛的、CS的方式来讲述它。我会用一种非正式的方式来描述。</p>
<p>所以，我们先从“sequential”这个词开始。这个部分你应该已经非常熟悉了。它所谈论的是另一种单线程行为以及我们用ES6 generators实现的同步风格代码的方式。</p>
<p>回忆一下，generator是的语法是像这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一条语句都是有序的（按照顺序）执行，每次执行一条。<code>yield</code>关键词表明代码中有可能发生堵塞暂停（只堵塞当前generator自己代码，并不堵塞外部程序！）的地方，但是这并不改变<code>*main()</code>内部自上而下的代码处理顺序。很简单，是吧？</p>
<p>下面，让我们谈谈“processes”，这又是关于些什么的呢？</p>
<p>从本质上来说，一个generator就像是一个虚拟“进程”。它是一块自我包含的程序，它可以，如果JS允许这样做的话，完全和程序剩余部分并发执行。</p>
<p>事实上，这样说有一点点问题。如果generator访问共享内存（也就是说，如果它访问它自身内部本地变量中的“free viriables”），这就不是独立的了。但是让我们先假设一下我们的generator函数并不访问外部变量（因此在函数式编程中我们会把它叫做一个“combinator”）。这样它就可以在理论上以自己单独进程的方式运行。</p>
<p>但是上面我们所说的是“processes” – 复数形式 – 因为有一点很重要的是，同时有两个或多个进程在运行。换句话说，两个或更多的generator进行配对，一般来说是进行协作以便完成更大的任务。</p>
<p>为什么要分离generators而不仅仅用一个呢？最重要的原因是：<strong>内容隔离</strong>。如果你可以将任务XYZ分解为各个子任务X、Y和Z，那么它们的实现代码会更加容易看懂和维护。</p>
<p>当你将一个函数<code>function XYZ()</code>分解为<code>X()</code>，<code>Y()</code>和<code>Z()</code>也是同样的道理，这里<code>X()</code>会调用<code>Y()</code>，<code>Y()</code>会调用<code>Z()</code>。我们将函数分解为单独的子函数来进行更好的代码隔离，使我们的代码更容易维护。</p>
<p><strong>我们可以对多个generator做同样的事情。</strong></p>
<p>最后我们来说一说“communicating”。这又是什么呢？这是从上面两个词推论出来的 – 协作 – 如果generator需要一起工作，它们需要一种通信渠道（不仅仅是访问共享词法作用域中的内容，而是实实在在的能够进行排他性访问的共享通信渠道）。</p>
<p>这个通信渠道是用来发送什么的呢？可以发送无论任何你需要发送的东西（数字、字符串、等等）。事实上，你甚至不需要真正的往通道中发送数据以便使用该通道进行通信。“Communication”可以是简单的协调 – 就像将控制权从一个地方转移到另一个地方。</p>
<p>为什么我们要转移控制权？主要的原因是JS是单线程的，并且在任何时刻它们中只有一个可以处于活动状态。其余的都处在暂停执行的状态，也就意味着它们处在任务的中途阶段，而只是暂停了，它们在等待必要时恢复。</p>
<p>任意独立的“进程”可以神奇的合作和交流，这似乎并不现实。松散耦合的目标是相当令人敬佩的，但它其实不切实际。</p>
<p>相反，似乎所有成功的CSP实现都是一种对某个特定领域内现有已知逻辑集合的因式分解，它的每一个部分都是特地为其他部分的协作而设计的。</p>
<p>或许我完全错了，但是我还没有看到任何方式让两个随机的generator函数可以非常容易的粘在一起变成一个CSP配对。他们都需要被设计成为另一方工作，接受同样的通信协议，等等。</p>
<h2 id="JS中的CSP"><a href="#JS中的CSP" class="headerlink" title="JS中的CSP"></a>JS中的CSP</h2><p>这里有几个已经应用在JS中了的CSP理论。</p>
<p>我们之前提到的Dabid Nolen创建了几个有趣的项目，包括<a href="https://github.com/swannodette/om" target="_blank" rel="external">Om</a>以及<a href="http://www.hakkalabs.co/articles/core-async-a-clojure-library/" target="_blank" rel="external">core.async</a>。<a href="http://koajs.com/" target="_blank" rel="external">Koa</a>库(为node.js创建)有一些非常有趣的实现，主要是通过它的<code>use(..)</code>方法。另一个对core.async/Go CSP API非常“忠诚”的库是<a href="https://github.com/ubolonton/js-csp" target="_blank" rel="external">js-csp</a>。</p>
<p>你应该确切的研究一下这些伟大的项目来看看不同的实现方式以及关于如何探索JS中的CSP的例子。</p>
<h2 id="asynquence的runner-设计CSP"><a href="#asynquence的runner-设计CSP" class="headerlink" title="asynquence的runner(..): 设计CSP"></a>asynquence的<code>runner(..)</code>: 设计CSP</h2><p>由于我一直以来都在积极地探索如何将CSP模式的并发性应用到我自己的JS代码中，因此为我的异步流控制库<a href="http://github.com/getify/asynquence" target="_blank" rel="external">asynquence</a>扩展CSP能力是非常自然的。</p>
<p>我已经有了<code>runner(..)</code>功能插件来处理generator的异步运行（见 <a href="http://davidwalsh.name/async-generators/#rungenerator-library-utility" target="_blank" rel="external">“Part 3: Going Async With Generators”</a>），所以在我看来，它可以很容易地扩展为用<a href="https://github.com/getify/asynquence/tree/master/contrib#csp-style-concurrency" target="_blank" rel="external">类-CSP的方式</a>同时处理多个generator。</p>
<p>我所要解决的第一个问题：你怎么知道下面是哪一个generator要获得控制权？</p>
<p>给每个generator赋予一个ID并让其他generator知晓以便它们将消息或者控制权传递给另一个进程的方式未免太繁琐和笨重了。在经过多次试验之后，我选定了一个简单的round-robin的调度方法。因此如果你将三个generator A、B和C匹配起来之后，A会先获得控制权，然后B在A进行yield时接管，然后C在B进行yield时接管，然后再到达A，以此类推。</p>
<p>但是我们要怎样才能真正的传递控制呢？需要一个明确的API来描述它吗？再一次地，经过多次试验之后，我使用了一个更加隐式的实现方式，它和<a href="http://koajs.com/#cascading" target="_blank" rel="external">Koa的实现方式</a>（碰巧）很相似：每个generator获得一个共享“token”的引用 – `yield它以便传递控制权转移的信号。</p>
<p>另一个问题则是消息通道应该是什么样的。一方面，你有一个非常确定了的API就像core.async以及js-csp中的那些（<code>put(..)</code>以及<code>take(..)</code>）。在我自己的经验中，我则倾向于另一个方面：一个不那么正式的方法（它甚至不是一个API，只是一个共享的数据结构就像<code>array</code>这样），这看起来就够了。</p>
<p>我决定使用一个数组(称为<code>messages</code>)这样你便可以大刀阔斧的决定你要如何来使用它。可以将消息<code>push()</code>进入这个数组，也可以从这个数组中<code>pop()</code>消息，指定数组中会话相关的元素组建不同消息，并可以在这些空间内创建更加复杂的数据结构，等等。</p>
<p>我的设想是有些任务只需要非常简单的消息传递，而另外一些会非常的复杂，因此以其将简单的内容变得复杂，不如将消息通道变得正式而使其成为一个<code>array</code>（这样就不需要除了<code>array</code>自身以外的API了）。将消息传递机制转化为其他形式是非常容易的，你会发现它的妙用（见我们接下来会瘫倒的状态机的例子）。</p>
<p>最后，我留意到这些generator“进程”仍然可以从普通generator的异步能力中获益。换句话说，如果你<code>yield</code>出一个Promise（或asynquence sequence）而不是一个控制token，<code>runner(..)</code>机制将会暂停并等待将来的结果值而不会<strong>移交控制权</strong> – 相反，它会将结果返回给当前的进程（generator）并使它继续享有控制权。</p>
<p>因此最后一点备受争议的应该是（如果我的想法都是正确的话），它和空间内的其它库都不一样。看起来真正的CSP对我这样的实现方式嗤之以鼻。但是我认为我的提议最终会变得非常非常有用。</p>
<h2 id="一个简单的FooBar示例"><a href="#一个简单的FooBar示例" class="headerlink" title="一个简单的FooBar示例"></a>一个简单的FooBar示例</h2><p>好的，我们说够了理论，现在让我们来看看代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: omitting fictional `multBy20(..)` and</span></span><br><span class="line"><span class="comment">// `addTo2(..)` asynchronous-math functions, for brevity</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// grab message off the top of the channel</span></span><br><span class="line">    <span class="keyword">var</span> value = token.messages.pop(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// put another message onto the channel</span></span><br><span class="line">    <span class="comment">// `multBy20(..)` is a promise-generating function</span></span><br><span class="line">    <span class="comment">// that multiplies a value by `20` after some delay</span></span><br><span class="line">    token.messages.push( <span class="keyword">yield</span> multBy20( value ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transfer control</span></span><br><span class="line">    <span class="keyword">yield</span> token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a final message from the CSP run</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"meaning of life: "</span> + token.messages[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// grab message off the top of the channel</span></span><br><span class="line">    <span class="keyword">var</span> value = token.messages.pop(); <span class="comment">// 40</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// put another message onto the channel</span></span><br><span class="line">    <span class="comment">// `addTo2(..)` is a promise-generating function</span></span><br><span class="line">    <span class="comment">// that adds value to `2` after some delay</span></span><br><span class="line">    token.messages.push( <span class="keyword">yield</span> addTo2( value ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transfer control</span></span><br><span class="line">    <span class="keyword">yield</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，现在我们有两个generator“进程”， <code>*foo()</code>和<code>*bar()</code>。你能留意到他们都处理了<code>token</code>对象（当然你也可以给它们任意命名）。<code>token</code>的<code>messages</code>熟悉是我们的共享消息通道。在初始时，它们充满了我们在初始化CSP运行时所产生的消息（见下文）。</p>
<p><code>yield token</code>显示地将控制权传递给“下一个”generator（通过round-robin策略）。然而，<code>yield multiBy20(value)</code>以及<code>yield addTo2(value)</code>都在yield promise（从这些虚构的延迟数学函数中），这表明generator在这一点会暂停知道promise结束。在promise结束时，当前处于控制的generator会获取返回值并继续下去。</p>
<p>无论最后的<code>yield</code>返回值是什么，在本例中是<code>yield &quot;meaning of...</code>表达式，它都是我们的CSP运行完成的消息（见下文）。</p>
<p>现在我们有了两个CSP进程generator，我们要如何执行它们呢？使用asynquence吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start out a sequence with the initial message value of `2`</span></span><br><span class="line">ASQ( <span class="number">2</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">// run the two CSP processes paired together</span></span><br><span class="line">.runner(</span><br><span class="line">    foo,</span><br><span class="line">    bar</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// whatever message we get out, pass it onto the next</span></span><br><span class="line"><span class="comment">// step in our sequence</span></span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( msg ); <span class="comment">// "meaning of life: 42"</span></span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>显然，这只是一个简单的示例。但是我认为它准确的解释了这个概念。</p>
<p>现在或许你该<a href="http://jsbin.com/tunec/2/edit?js,console" target="_blank" rel="external">自己试一试</a>了（试着将返回值进行链式处理！）来确保你已经理解了这些概念并且能够编写你自己的代码了！</p>
<h2 id="另一个玩具Demo的例子"><a href="#另一个玩具Demo的例子" class="headerlink" title="另一个玩具Demo的例子"></a>另一个玩具Demo的例子</h2><p>让我们用一个经典的CSP例子来试一试，但是让我们从我所观测到的简单部分开始，而不是像通常人们做的那样从一个学术的角度开始。</p>
<p><strong>Ping-pong</strong>。很有趣的运动是吧？这是我最喜欢的运动。</p>
<p>让我们设想一下你已经实现了进行一次乒乓球比赛的代码。你用一个循环来运行，然后你有两块代码（例如，用一个<code>if</code>或者<code>switch</code>实现的分支）每一块代表者一名选手。</p>
<p>你的代码运行得很好，你的游戏就看起来像是一个真正的乒乓球比赛一样！</p>
<p>但是我们之前看到的是CSP在什么方面非常有用？<strong>逻辑隔离</strong>。我们在乒乓球运动中要隔离的逻辑是？这两名选手！</p>
<p>因此，我们可以，站在一个非常高的角度，来给两个“进程”（generators）建模，每一个代表一名选手。随着我们的深入，我们会发现这些用来在两名选手之间传递控制权的“胶水代码”其自身是一个task，并且它的代码可以被放到第三个generator中，这里我们可以将其建模为一个裁判。</p>
<p>我们会过滤掉所有的领域相关问题，例如得分、赛制、物理学、策略、AI、控制、等等。我们唯一关心的只是模拟来回击球（这也就是我们的CSP控制权转移的描述）。</p>
<p>想看看Demo吗？<a href="http://jsbin.com/qutabu/1/edit?js,output" target="_blank" rel="external">点击这里运行</a>（注：你需要使用最新版本的FF或者Chrome，它们支持ES6 JavaScript，来看到generator是如何运作的）。</p>
<p>好，下面我们逐条讲解我们的代码。</p>
<p>受限，asynquence sequence看起来长什么样呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ASQ(</span><br><span class="line">    [<span class="string">"ping"</span>,<span class="string">"pong"</span>], <span class="comment">// player names</span></span><br><span class="line">    &#123; hits: <span class="number">0</span> &#125; <span class="comment">// the ball</span></span><br><span class="line">)</span><br><span class="line">.runner(</span><br><span class="line">    referee,</span><br><span class="line">    player,</span><br><span class="line">    player</span><br><span class="line">)</span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    message( <span class="string">"referee"</span>, msg );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>我们将序列初始化为两条消息：<code>[&quot;ping&quot;, &quot;pong&quot;]</code>和<code>{hits: 0}</code>。我们马上就会用到它们。</p>
<p>然后，我们设置CSP运行3个进程（通过轮询的方式）：一个<code>*referee()</code>和两个<code>*player()</code>实例。</p>
<p>比赛最后的消息在我们的序列中不停传输，并最后作为裁判的消息被打印出来。</p>
<p>裁判的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">referee</span>(<span class="params">table</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alarm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// referee sets an alarm timer for the game on</span></span><br><span class="line">    <span class="comment">// his stopwatch (10 seconds)</span></span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alarm = <span class="literal">true</span>; &#125;, <span class="number">10000</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep the game going until the stopwatch</span></span><br><span class="line">    <span class="comment">// alarm sounds</span></span><br><span class="line">    <span class="keyword">while</span> (!alarm) &#123;</span><br><span class="line">        <span class="comment">// let the players keep playing</span></span><br><span class="line">        <span class="keyword">yield</span> table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// signal to players that the game is over</span></span><br><span class="line">    table.messages[<span class="number">2</span>] = <span class="string">"CLOSED"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// what does the referee say?</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"Time's up!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我把控制token称为<code>table</code>以便和问题的domain（乒乓球）相匹配。语义上让一个选手击球时”yield the table”给另一个选手相当恰当，不是吗？</p>
<p><code>while</code>循环<code>*referee()</code>只是不停的yield <code>table</code>回给选手只要它的手表还没有计时结束。当结束时，它会宣布<code>&quot;Time&#39;s up!&quot;</code></p>
<p>现在，让我们来看看<code>*player()</code> generator（我们使用了两个实例）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">player</span>(<span class="params">table</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = table.messages[<span class="number">0</span>].shift();</span><br><span class="line">    <span class="keyword">var</span> ball = table.messages[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (table.messages[<span class="number">2</span>] !== <span class="string">"CLOSED"</span>) &#123;</span><br><span class="line">        <span class="comment">// hit the ball</span></span><br><span class="line">        ball.hits++;</span><br><span class="line">        message( name, ball.hits );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// artificial delay as ball goes back to other player</span></span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">500</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// game still going?</span></span><br><span class="line">        <span class="keyword">if</span> (table.messages[<span class="number">2</span>] !== <span class="string">"CLOSED"</span>) &#123;</span><br><span class="line">            <span class="comment">// ball's now back in other player's court</span></span><br><span class="line">            <span class="keyword">yield</span> table;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message( name, <span class="string">"Game over!"</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个选手从数组中获取他自己的名字（<code>&quot;ping&quot;</code>），然后第二个选手获取他的名字（<code>“pong”</code>），因此他们可以同时辨别双方。双方都保留一个对共享<code>ball</code>对象的引用（包含了<code>hits</code>计数器）。</p>
<p>当选手还未听到裁判结束的消息时，他们通过将计数器<code>hits</code>增加1的方式”击打”<code>ball</code>（并且输出一条消息进行公告），然后他们等待500毫秒（只是来模拟一下球速并没有达到光速啦！）</p>
<p>如果比赛仍在继续，他们会”yield table”回到另一名选手中。</p>
<p>就是这样啦！</p>
<p><a href="http://jsbin.com/qutabu/1/edit?js,output" target="_blank" rel="external">看看这里的Demo代码</a>，通过将所有的代码放在一起看看它们是如何共同工作的。</p>
<h2 id="状态机：Generator协作"><a href="#状态机：Generator协作" class="headerlink" title="状态机：Generator协作"></a>状态机：Generator协作</h2><p>我们最后一个例子：定义一个<a href="http://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="external">状态机</a>作为一系列generator的协同程序，它们有一个简单的helper驱动。</p>
<p><a href="http://jsbin.com/luron/1/edit?js,console" target="_blank" rel="external">Demo</a>（用最新的FF或者Chrome打开）</p>
<p>首先，让我们顶一个一个help函数来控制我们的有限状态句柄：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">state</span>(<span class="params">val,handler</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// make a coroutine handler (wrapper) for this state</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>*(<span class="params">token</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// state transition handler</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">transition</span>(<span class="params">to</span>) </span>&#123;</span><br><span class="line">            token.messages[<span class="number">0</span>] = to;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// default initial state (if none set yet)</span></span><br><span class="line">        <span class="keyword">if</span> (token.messages.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            token.messages[<span class="number">0</span>] = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keep going until final state (false) is reached</span></span><br><span class="line">        <span class="keyword">while</span> (token.messages[<span class="number">0</span>] !== <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// current state matches this handler?</span></span><br><span class="line">            <span class="keyword">if</span> (token.messages[<span class="number">0</span>] === val) &#123;</span><br><span class="line">                <span class="comment">// delegate to state handler</span></span><br><span class="line">                <span class="keyword">yield</span> *handler( transition );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// transfer control to another state handler?</span></span><br><span class="line">            <span class="keyword">if</span> (token.messages[<span class="number">0</span>] !== <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">yield</span> token;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该<code>state(..)</code> helper工具方法创建了一个为一个具体的状态值准备的<a href="http://davidwalsh.name/es6-generators-dive#delegating-generators" target="_blank" rel="external">delegating-generator</a>包装器，它会自动的运行状态机，并且将控制权在每个状态间进行传递。</p>
<p>出于惯例，我决定共享<code>token.messages[0]</code>位置来保存当前状态机的状态。这表明你可以从之前的步骤中传递一条消息作为初始状态。但是如果没有这样的初始消息被传递的话，我们会简单的将第一个状态定义为我们的初始状态。同样出于惯例，最终状态被断言为<code>false</code>。这很容易实现：</p>
<p>状态值可以是任何种类的值：<code>number</code>s, <code>string</code>s，等等。只要这个值能被<code>===</code>处理，你就可以使用它来做你的状态。</p>
<p>在下面这个例子中，我展示了一个状态机从4个<code>number</code>形式的状态值之间进行转化，采用这种顺序<code>1 -&gt; 4 -&gt; 3 -&gt; 2</code>。为了demo的目的，它也会进行计数以便进行不止一次的转换。当我们的generator状态机最终到达终止位（<code>false</code>）时，<em>asynquence</em>序列会移动到下一个步骤，如你所期待的那样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter (for demo purposes only)</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ASQ( <span class="comment">/* optional: initial state value */</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">// run our state machine, transitions: 1 -&gt; 4 -&gt; 3 -&gt; 2</span></span><br><span class="line">.runner(</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state `1` handler</span></span><br><span class="line">    state( <span class="number">1</span>, <span class="function"><span class="keyword">function</span>*(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"in state 1"</span> );</span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">1000</span> ); <span class="comment">// pause state for 1s</span></span><br><span class="line">        <span class="keyword">yield</span> transition( <span class="number">4</span> ); <span class="comment">// goto state `4`</span></span><br><span class="line">    &#125; ),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state `2` handler</span></span><br><span class="line">    state( <span class="number">2</span>, <span class="function"><span class="keyword">function</span>*(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"in state 2"</span> );</span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">1000</span> ); <span class="comment">// pause state for 1s</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for demo purposes only, keep going in a</span></span><br><span class="line">        <span class="comment">// state loop?</span></span><br><span class="line">        <span class="keyword">if</span> (++counter &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> transition( <span class="number">1</span> ); <span class="comment">// goto state `1`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// all done!</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">"That's all folks!"</span>;</span><br><span class="line">            <span class="keyword">yield</span> transition( <span class="literal">false</span> ); <span class="comment">// goto terminal state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state `3` handler</span></span><br><span class="line">    state( <span class="number">3</span>, <span class="function"><span class="keyword">function</span>*(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"in state 3"</span> );</span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">1000</span> ); <span class="comment">// pause state for 1s</span></span><br><span class="line">        <span class="keyword">yield</span> transition( <span class="number">2</span> ); <span class="comment">// goto state `2`</span></span><br><span class="line">    &#125; ),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state `4` handler</span></span><br><span class="line">    state( <span class="number">4</span>, <span class="function"><span class="keyword">function</span>*(<span class="params">transition</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"in state 4"</span> );</span><br><span class="line">        <span class="keyword">yield</span> ASQ.after( <span class="number">1000</span> ); <span class="comment">// pause state for 1s</span></span><br><span class="line">        <span class="keyword">yield</span> transition( <span class="number">3</span> ); <span class="comment">// goto state `3`</span></span><br><span class="line">    &#125; )</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// state machine complete, so move on</span></span><br><span class="line">.val(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( msg );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>应该很容易看出这里将发生什么。</p>
<p><code>yield ASQ.after(1000)</code>表明这些generator可以做任何基于异步流的promise/sequence操作，就像我们之前看到的那样。<code>yield transition(..)</code>是我们如何转移到一个新的状态上。</p>
<p>我们前面的<code>state(..)</code> helper实际上做了处理<code>yield*</code><a href="http://davidwalsh.name/es6-generators-dive#delegating-generators" target="_blank" rel="external">代理</a>以及状态转换的复杂工作，是的我们的状态句柄可以以一种非常简单和自然的格式进行编写。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSP的关键在于将两个或多个generator“进程”结合在一起，给予他们一个共享的通信渠道，以及一个它们之前传递控制权的方法。</p>
<p>JS中非常多的库都或多或少的有一些正式的实现，它们基本符合Go/Clojure/ClojureScript的API和语法。所有这些库的背后都有一些非常聪明的开发者，并且他们对于今后的研究都是一笔巨大的财富。</p>
<p><a href="http://github.com/getify/asynquence" target="_blank" rel="external">asynquence</a>尝试了一种非正式的实现方式但仍然希望它能满足这个机制。如果没有别的，asynquence的<code>runner(..)</code>使上手使用CSP风格的generator非常简单，你可以进行尝试并且学习。</p>
<p>然而最好的部分仍然是asynquence CSP可以和其他异步功能（promise、generators、控制流等等）无缝结合，你可以使用你所拥有的任何工具，都在这样一个小小的库里。</p>
<p>在过去的4篇文章中我们已经讨论了相当多的关于generator的细节。我希望你对此感到兴奋并受到启发去探索如何改变你自己的JS代码！你会用generator来做些什么呢？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2015/01/04/Getting-Concurrent-With-ES6-Generators/" data-id="cirx40r200002scnbit5xplhf" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/generator-translation/">generator translation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Going-Async-With-ES6-Generators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2014/12/26/Going-Async-With-ES6-Generators/" class="article-date">
  <time datetime="2014-12-27T05:01:21.000Z" itemprop="datePublished">2014-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2014/12/26/Going-Async-With-ES6-Generators/">Going Async With ES6 Generators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#用Generator进行异步编程（译）</p>
<p>原文地址：<a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">http://davidwalsh.name/async-generators</a></p>
<p>ES6 Generators：全系列</p>
<ol>
<li><a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">The Basics Of ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">Diving Deeper With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">Getting Concurrent With ES6 Generators</a></li>
</ol>
<p>现在你已经<a href="http://davidwalsh.name/es6-generators/" target="_blank" rel="external">见识过了ES6 generator</a>并且已经对它已经<a href="http://davidwalsh.name/es6-generators-dive/" target="_blank" rel="external">有所熟悉</a>了，现在是时候开始使用它们来增强我们真实的代码了。</p>
<p>Generator的主要唱出在于它们提供了一个单线程的，同步样式的代码风格，<strong>同时允许你把异步隐藏为实现细节</strong>。这使得我们用一种非常自然的方式表达，专注于我们程序的步骤/声明的流程，而不必同时不得不遵循异步语法并避免陷阱。</p>
<p>换句话说，我们通过隔离对值的消费（我们的generator逻辑）与异步得到这些值的细节（generator迭代器中的<code>next(..)</code>），实现了<strong>能力与缺点的完美分离</strong>。</p>
<p>结果呢？我们获得了异步代码的强大能力，同时也获得了（看上去是）同步代码的可读性以及可维护性。</p>
<p>那么我们如何实现这个非凡的能力呢？</p>
<h2 id="最简单的异步"><a href="#最简单的异步" class="headerlink" title="最简单的异步"></a>最简单的异步</h2><p>在最简单的场景下，generator不需要任何额外的操作来实现你的程序中并没有的异步操作。</p>
<p>例如，让我们设想你已经有了这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAjaxCall</span>(<span class="params">url,cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do some ajax fun</span></span><br><span class="line">    <span class="comment">// call `cb(result)` when complete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeAjaxCall( <span class="string">"http://some.url.1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">result1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    makeAjaxCall( <span class="string">"http://some.url.2/?id="</span> + data.id, <span class="function"><span class="keyword">function</span>(<span class="params">result2</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>要使用一个generator来表现同样的程序，你需要这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this is where we're hiding the asynchronicity,</span></span><br><span class="line">    <span class="comment">// away from the main code of our generator</span></span><br><span class="line">    <span class="comment">// `it.next(..)` is the generator's iterator-resume</span></span><br><span class="line">    <span class="comment">// call</span></span><br><span class="line">    makeAjaxCall( url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">        it.next( response );</span><br><span class="line">    &#125; );</span><br><span class="line">    <span class="comment">// Note: nothing returned here!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next(); <span class="comment">// get it all started</span></span><br></pre></td></tr></table></figure>
<p>让我们来解释一下它是如何工作的：</p>
<p><code>request(..)</code>功能函数基本上包装我们普通的<code>makeAjaxCall(..)</code>功能类以保证它的回调函数能调用generator iterator的<code>next(..)</code>方法。</p>
<p>对于<code>request(&quot;..&quot;)</code>调用，你会注意到它<em>没有返回值</em>（换句话说，它是<code>undefined</code>）。这不是什么大问题，但是它和我们在本文之后的实现方式有所不同：我们在这里实际上是调用了<code>yield undefined</code>。</p>
<p>因此我们调用<code>yield ..</code>（和这个<code>undefined</code>值），它实际上什么也没做，它只是在这一点上暂停了我们的generator。它将会等待直到<code>it.next(..)</code>被调用来恢复它，这个调用我们已经排列在队列中（作为回调函数），在Ajax调用结束后发生。</p>
<p>但是<code>yield ..</code>表达式的<em>结果</em>又发生了什么？我们将它赋值到变量<code>result1</code>上。它是如何得到第一个Ajax调用的内部的值的呢？</p>
<p>因为当<code>it.next(..)</code>被作为Ajax回调函数调用时，它实际是在给它传递Ajax的响应结果，这表明值在那个当前暂停的时间点被发送回我们的generator内部，也就是<code>result1 = yield ..</code>表达式的中间！</p>
<p>这的确非常的酷并且超级强大。本质上，<code>result1 = yield reequest(..)</code>是在<strong>请求这个值</strong>，但是它（几乎！）完全对我们隐藏了 – 至少我们不需要在这里担心它 – 外表之下的实际实现是异步的。它通过<em>隐藏</em><code>yield</code>中的暂停能力实现了异步，并且分离出generator的<em>恢复</em>能力到另外一个函数中，因此我们的main代码只需要进行一个<strong>（看起来是）同步的值的请求</strong>。</p>
<p>对于第二个<code>result2 = yield result(..)</code>表达式也是一样：它对于暂停和恢复是透明的，并且提供了我们所需求的值，所有这些都没有让任何异步细节打扰到我们我代码。</p>
<p>当然<code>yield</code>出现了，因此那里的确有一个细微的提示“一些神奇的东西（异步）<em>可能发生</em>在那个时间点”。但是<code>yield</code>比起回调地狱（或者甚至是promise链的API冗余！）来已经是一个简单的语法信号/冗余了。</p>
<p>注意到我刚刚说了<em>可能发生</em>。这是一个相当强大的事情。上面的程序总是发出一个Ajax请求，但是<strong>如果它不这样呢</strong>？如果我们之后将我们的程序改为读取内存中之前得到的Ajax响应呢？或者一些程序中的复杂URL rouer可能在某些条件下立即响应一个Ajax请求而不需要真的从一个外部服务器获取呢？</p>
<p>我们可以改变<code>request(..)</code>的实现使它变成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache[url]) &#123;</span><br><span class="line">        <span class="comment">// "defer" cached response long enough for current</span></span><br><span class="line">        <span class="comment">// execution thread to complete</span></span><br><span class="line">        setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            it.next( cache[url] );</span><br><span class="line">        &#125;, <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">            cache[url] = resp;</span><br><span class="line">            it.next( resp );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里有一个小技巧是需要使用<code>setTimeout(..0)</code>进行延迟以防cache已经在结果里面了。如果我们刚刚立即调用<code>it.next(..)</code>，它会产生一个错误，因为（这就是那个技巧）generator<em>尚未</em>处于暂停状态。我们的函数调用<code>request(..)</code><em>首先</em>被评估，然后<code>yield</code>暂停。因此我们不能再次在<code>request(..)</code>内部调用<code>it.next(..)</code>，因为在那个时刻generator扔在执行（<code>yield</code>还没有被进行）。但是我们可以”之后“调用<code>it.next(..)</code>，在当前线程执行完的一瞬间，也就是我们的<code>setTimeout(..0)</code>”伪造“的一个实现。<strong>我们会在下面有一个更好的实现</strong>。</p>
<p>现在我们的main generator代码仍然看起来像：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<p>看到了吧？！我们的generator逻辑（也就是控制流）和不加cache的版本比起来<strong>完全</strong>不需要变化。</p>
<p><code>*main()</code>中的代码仍然请求一个值，然后暂停直到它得到值。在我们当前的情境下，”暂停“可以非常长（发送一个真实的请求到服务器，一般为300-800ms）或者可能几乎立即结束（<code>setTimeout(..0)</code>进行延迟处理）。而我们的控制流并不关心。</p>
<p>这就是<strong>将异步行为抽象为实现细节</strong>真正的强大之处。</p>
<h2 id="更好的异步"><a href="#更好的异步" class="headerlink" title="更好的异步"></a>更好的异步</h2><p>对于一个单独的异步generator工作，上面的实现已经相当不错了。但是它马上会到达局限，所以我们需要一个更强大的异步机制来和我们的generator做搭配，它能够承担更多的负担。这个机制是什么呢？就是<strong>Promise</strong>。</p>
<p>如果你对于ES6的Promise还有点模糊不清，我写了一个<a href="http://blog.getify.com/promises-part-1/" target="_blank" rel="external">5篇文章的系列</a>，去读一读吧。我会在这里wait直到你回来的（偷笑，哈哈）。这只是个老掉牙的异步的笑话啦！</p>
<p>本文早先的Ajax代码都有同样的<a href="http://blog.getify.com/promises-part-2/" target="_blank" rel="external">控制反转</a>的问题（也就是”回调地狱“），就下你给我们最初的那个充满了回调的例子一样。到目前为止，我们缺乏这样一些东西：</p>
<ol>
<li><p>没有明确的异常处理的方式。我们已经<a href="http://davidwalsh.name/es6-generators-dive/#error-handling" target="_blank" rel="external">从上篇文章中学到</a>，我们可以探测到一个Ajax调用时的异常（通过某种方式），通过<code>it.throw(..)</code>传递回我们的generator，然后使用<code>try..catch</code>在我们的generator逻辑中处理它。但是那只是更多的手动任务来接通“后端”（我们处理generator iterator的代码），并且如果我们需要非常多的generator是，它可能无法重复使用。</p>
</li>
<li><p>如果<code>makeAjaxCall(..)</code>工具类不受控制，并且它调用了多次的callback，或者信号同时成功与失败，等等。那么我们的generator会出故障（未捕获的异常，不期待的值，等等）。处理并且阻止这些问题很多都是手动工作，并且同样无法重用。</p>
</li>
<li><p>经常的，我们并不仅仅”并发“执行任务（例如两个并行的Ajax调用那样）。由于generator<code>yield</code>表达式是一个单一暂停点，两个或两个以上的generator不可以在同时运行 – 它们不得不一次一个的执行，按顺序。因此，对于如何在单独的generator <code>yield</code>点发送多个任务，而不在表面之下进行大量的人工编码，是尚不可知的。</p>
</li>
</ol>
<p>如你所见，所有这些问题都是<em>可以被解决的</em>，但是谁又希望每次都重新发明这些解决方法呢？我们需要一个更强大的模式，设计为专为基于generator的异步编码的<a href="http://blog.getify.com/promises-part-3/" target="_blank" rel="external">可信的，可重用的解决方案</a>。</p>
<p>那个模式是？<strong><code>yield</code> out promises</strong>，并且当他们被fulfill时让它们恢复generator。</p>
<p>回想一下上面我们所做的<code>yield request(..)</code>，以及<code>request(..)</code>功能方法没有任何返回值，仅仅<code>yield undefined</code>是有效的吗？</p>
<p>让我们小小的对他进行调整。让我们改变我们的<code>request(..)</code>功能方法使其成为一个基于promise的方法，这样它会返回一个promise，并且这样的话我们<code>yield</code> out的东西<strong>实际上是一个promise</strong>（而不是<code>undefined</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Note: returning a promise now!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        makeAjaxCall( url, resolve );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，<code>request(..)</code>会构造一个Ajax调用结束后被处理的promise，并返回这个promise，所以它可以被<code>yield</code>出去，下一步呢？</p>
<p>我们会需要一个功能方法来控制我们的generator iterator，它接收这些被<code>yield</code>的promise然后将他们与恢复generator联通(通过<code>next(..)</code>)。我现在会调用下面这个<code>runGenerator(..)</code>功能类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run (async) a generator to completion</span></span><br><span class="line"><span class="comment">// Note: simplified approach: no error handling here</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runGenerator</span>(<span class="params">g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> it = g(), ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// asynchronously iterate over generator</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        ret = it.next( val );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ret.done) &#123;</span><br><span class="line">            <span class="comment">// poor man's "is it a promise?" test</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"then"</span> <span class="keyword">in</span> ret.value) &#123;</span><br><span class="line">                <span class="comment">// wait on the promise</span></span><br><span class="line">                ret.value.then( iterate );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// immediate value: just send right back in</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// avoid synchronous recursion</span></span><br><span class="line">                setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    iterate( ret.value );</span><br><span class="line">                &#125;, <span class="number">0</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的关键点：</p>
<ol>
<li><p>我们自动的对generator进行初始化（创建它的<code>it</code>迭代器），然后我们异步地运行<code>it</code>直到结束（<code>done: ture</code>）。</p>
</li>
<li><p>我们寻找要被<code>yield</code>出去（即在每个<code>it.next(..)</code>调用时的返回值<code>value</code>）的promise。如果有的话，我们通过在promise之上注册<code>then(..)</code>等待直到它结束。</p>
</li>
<li><p>如果任何立即的（即非promise）值被返回，我们简单地发送这个值到generator中以便它继续立即执行。</p>
</li>
</ol>
<p>现在，我们怎么使用它呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Bam！等一等…这不<strong>和我们之前的generator代码一样</strong>吗？是的。再一次地，generator的强大之处显示出来了。实际上是，我们现在在创建promise，将他们<code>yield</code>出去，然后在generator结束时恢复他们 – <strong>所有这些都隐藏了实现细节！</strong> 当然并不是完全隐藏，只是从消费代码（我们generator内部的控制流）中分离出来了。</p>
<p>通过等待被<code>yield</code>出去的promise，并且发送完成结果回<code>it.next(..)</code>，代码<code>result1 = yield request()..</code>得到了和之前完全相同的值。</p>
<p>但是现在我们在使用promise来管理generator代码中的异步部分，我们解决所有的来自于回调风格解决方案的倒转/信任问题。我们通过使用generator + promise得到所有上面的解决方案。</p>
<ol>
<li><p>我们现在有了便于使用的内嵌的异常处理。我们在上面的<code>runGenerator(..)</code>中并没有显示它，但是从promise中监听一个异常并发送至<code>it.throw(..)</code>并不困难 – ranh9ou我们可以在我们的generator代码中使用<code>try..catch</code>来捕获并处理这些异常。</p>
</li>
<li><p>我们拥有了所有由promise提供的<a href="http://blog.getify.com/promises-part-2/#uninversion" target="_blank" rel="external">控制/可信性解决方案</a>。不需要更多的关心。</p>
</li>
<li><p>Promise拥有非常多位于上层的强大的抽象，它可以自动地处理复杂的多“并发”任务，等等。</p>
</li>
</ol>
<p>例如<code>yield Promise.all([ .. ])</code>可以接受一个prmose的数组来“并发执行”任务，然后<code>yield</code>出一个单一的promise（给generator来处理），它在处理前等待所有的子promise结束（无论以何种顺序）。你从<code>yield</code>表达式返回的（当promise结束时）是一个所有子promise的响应数组，按照它们请求的顺序（无论它们的结束顺序是如何）。</p>
<p>首先让我们来看看异常处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assume: `makeAjaxCall(..)` now expects an "error-first style" callback (omitted for brevity)</span></span><br><span class="line"><span class="comment">// assume: `runGenerator(..)` now also handles error handling (omitted for brevity)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// pass an error-first style callback</span></span><br><span class="line">        makeAjaxCall( url, <span class="function"><span class="keyword">function</span>(<span class="params">err,text</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) reject( err );</span><br><span class="line">            <span class="keyword">else</span> resolve( text );</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result1 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result2 = <span class="keyword">yield</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>当获取URL时promise被拒绝（或者任何形式的错误/异常），promise rejection会被映射为一个generator错误（使用我们之前没有描述的<code>runGenerator(..)</code>中的<code>it.throw(..)</code>），它会被<code>try..catch</code>语句捕获住。</p>
<p>现在，让我们来看一个更下复杂的例子，它使用了promise来管理更多异步的复杂问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        makeAjaxCall( url, resolve );</span><br><span class="line">    &#125; )</span><br><span class="line">    <span class="comment">// do some post-processing on the returned text</span></span><br><span class="line">    .then( <span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// did we just get a (redirect) URL back?</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^https?:\/\/.+/</span>.test( text )) &#123;</span><br><span class="line">            <span class="comment">// make another sub-request to the new URL</span></span><br><span class="line">            <span class="keyword">return</span> request( text );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// otherwise, assume text is what we expected to get back</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runGenerator( <span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> search_terms = <span class="keyword">yield</span> <span class="built_in">Promise</span>.all( [</span><br><span class="line">        request( <span class="string">"http://some.url.1"</span> ),</span><br><span class="line">        request( <span class="string">"http://some.url.2"</span> ),</span><br><span class="line">        request( <span class="string">"http://some.url.3"</span> )</span><br><span class="line">    ] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> search_results = <span class="keyword">yield</span> request(</span><br><span class="line">        <span class="string">"http://some.url.4?search="</span> + search_terms.join( <span class="string">"+"</span> )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( search_results );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Search results: "</span> + resp.value );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p><code>Promise.all([ .. ])</code>构造一个promise，它等待3个子promise。并且，被<code>yield</code>出提供给<code>runGenerator(..)</code>功能函数的主promise会被监听作为generator的恢复。子promise可以接收一个响应，它看起来像另一个URL，并且以链式连接另一个子promise到达新的地点。如果要学习更多promise链式表达，<a href="http://blog.getify.com/promises-part-5/#the-chains-that-bind-us" target="_blank" rel="external">阅读这篇文章</a>。</p>
<p>任何异步的功能性/复杂性问题都可以由promise解决，而同步风格代码则可以通过使用generator <code>yield</code>出promise（的promise的promise…）来实现。<strong>这真是两全其美</strong></p>
<h2 id="runGenerator-功能库"><a href="#runGenerator-功能库" class="headerlink" title="runGenerator(..): 功能库"></a>runGenerator(..): 功能库</h2><p>我们已经定义了我们自己的<code>runGenerator(..)</code>来启用这个强大的generator+promise组合。我们省略了这个功能函数的完全实现（为了简单起见），因为还有很多细节上和异常处理相关的内容需要完成。</p>
<p>但是，你并不想编写你自己的<code>runGenerator(..)</code>是吧？</p>
<p>我认为是的。</p>
<p>有非常多的promise/异步库提供了这样的功能。我在这里不会讲述，但你可以看一看<code>Q.spawn(..)</code>，<code>co(..)</code>库，等等。</p>
<p>我会简单的介绍一下我自己的功能库：<a href="http://github.com/getify/asynquence" target="_blank" rel="external">asynquence</a>的<a href="https://github.com/getify/asynquence/tree/master/contrib#runner-plugin" target="_blank" rel="external"><code>runner(..)</code>插件</a>，我认为它比上面的那些库提供了一些特殊的适配性。我写了深入的<a href="http://davidwalsh.name/asynquence-part-1/" target="_blank" rel="external">两部分的blog关于asynquence的系列文章</a>如果你感兴趣学到更多的话你可以去看一看。</p>
<p>首先，<em>asynquence</em>提供了功能类自动处理“首参数为错误风格”的回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ASQ( <span class="function"><span class="keyword">function</span>(<span class="params">done</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// pass an error-first style callback</span></span><br><span class="line">        makeAjaxCall( url, done.errfcb );</span><br><span class="line">    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这<strong>更加的友好</strong>了，不是吗！？</p>
<p>下一步，asynquence的<code>runner(..)</code>插件在<em>aynquence</em>序列（异步序列步骤）的中途消耗一个generator，所以你可以从之前的步骤向内传递消息，而你的generator可以向外或向下一步传递消息，而所有的错误会自动地如你期望的那样传播。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first call `getSomeValues()` which produces a sequence/promise,</span></span><br><span class="line"><span class="comment">// then chain off that sequence for more async steps</span></span><br><span class="line">getSomeValues()</span><br><span class="line"></span><br><span class="line"><span class="comment">// now use a generator to process the retrieved values</span></span><br><span class="line">.runner( <span class="function"><span class="keyword">function</span>*(<span class="params">token</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// token.messages will be prefilled with any messages</span></span><br><span class="line">    <span class="comment">// from the previous step</span></span><br><span class="line">    <span class="keyword">var</span> value1 = token.messages[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> value2 = token.messages[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> value3 = token.messages[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make all 3 Ajax requests in parallel, wait for</span></span><br><span class="line">    <span class="comment">// all of them to finish (in whatever order)</span></span><br><span class="line">    <span class="comment">// Note: `ASQ().all(..)` is like `Promise.all(..)`</span></span><br><span class="line">    <span class="keyword">var</span> msgs = <span class="keyword">yield</span> ASQ().all(</span><br><span class="line">        request( <span class="string">"http://some.url.1?v="</span> + value1 ),</span><br><span class="line">        request( <span class="string">"http://some.url.2?v="</span> + value2 ),</span><br><span class="line">        request( <span class="string">"http://some.url.3?v="</span> + value3 )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send this message onto the next step</span></span><br><span class="line">    <span class="keyword">yield</span> (msgs[<span class="number">0</span>] + msgs[<span class="number">1</span>] + msgs[<span class="number">2</span>]);</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// now, send the final result of previous generator</span></span><br><span class="line"><span class="comment">// off to another request</span></span><br><span class="line">.seq( <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request( <span class="string">"http://some.url.4?msg="</span> + msg );</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// now we're finally all done!</span></span><br><span class="line">.val( <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( result ); <span class="comment">// success, all done!</span></span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// or, we had some error!</span></span><br><span class="line">.or( <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>asynquence <code>runner(..)</code>功能类接受一个可选的消息来开始generator，这个消息往往是由之前的步骤而来，并且在generator的<code>token.messages</code>数组中是可见的。</p>
<p>然后，和我们之前示范使用<code>runGenerator(..)</code>功能类一样，<code>runner(..)</code>监听一个被<code>yield</code>的poromise或<em>asynquence</em>序列（在这种情况下使用<code>ASQ().all(..)</code>序列来并发执行），并且等待它的结束然后恢复generator。</p>
<p>当generator结束时，最后<code>yield</code>出的值会传递给序列的下一个步骤。</p>
<p>并且，如果有任何错误在这个序列的任何地方发生，甚至是在generator内部发生，它会被传播给单独的<code>or(..)</code>被注册的错误处理者。</p>
<p><em>asynquence</em>尝试将promise和generator尽可能简单的结合。你可以随心所欲的构造任何generator流和基于promise的序列步骤流。</p>
<h2 id="ES7-async"><a href="#ES7-async" class="headerlink" title="ES7 async"></a>ES7 <code>async</code></h2><p>ES7的时间轴上有一个提案，它看起来会被接受，来创建另一种函数：<code>async function</code>，它看起来是使用generator自动地包装一个像<code>runGenerator(..)</code>（或<em>asynquence</em>的<code>runner(..)</code>）功能类。那样的话你可以发送promise并且<code>async function</code>会自动地将其包装并且在结束时恢复promise（甚至不需要使用iterator！）</p>
<p>所以它看起来可能会像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = <span class="keyword">await</span> request( <span class="string">"http://some.url.1"</span> );</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse( result1 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result2 = <span class="keyword">await</span> request( <span class="string">"http://some.url.2?id="</span> + data.id );</span><br><span class="line">    <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse( result2 );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"The value you asked for: "</span> + resp.value );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<p>如你所见，一个<code>async function</code>可以被直接调用（就像<code>main()</code>一样），而不需要像<code>runGenerator(..)</code>或<code>ASQ().runner(..)</code>的包装功能类来包装它。在内部，有别于使用<code>yield</code>，你将会使用<code>await</code>（另一个新的关键词）来告知<code>async function</code>在继续执行前等待promise的结束。</p>
<p>基本上，我们会拥有大多数包装库包装后的generator的能力，但是<strong>直接由原生语法支持</strong></p>
<p>酷！是吧！</p>
<p>在同时，像<em>asynquence</em>这样的库给予我们这些执行功能函数来让我们使用异步generator更容易！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单的说：generator + <code>yield</code>ed promise组合了双方最好的部分让我们得到了强大而优雅的同步语法+异步流程控制的能力。使用简单的包装功能函数（有非常多的功能库已经提供了这一点），我们可以自动的运行我们的generator到结束，包括正常结果以及出错的处理。</p>
<p>在ES7的大陆上，我们很可能会见到<code>async function</code>让我们可以不依靠功能库来达到（至少对基本的case可以这样实现）。</p>
<p><strong>JavaScript中异步的未来是光明的</strong>，并且只会变得更光明！我应该戴上太阳镜。</p>
<p>但是我们还没有结束，我们还有最后一个部分想要发掘一下：</p>
<p>如果你可以将两个或多个generator连接在一起会怎么样呢？让他们单独但“并发”的执行，并且让他们在执行的过程中互相发送消息？那会是一种更强大的能力，不是吗？这个模式被称为”CSP”（communicating sequential processes）。我们会在下一篇文章中解锁CSP的强大能力。请继续关注！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2014/12/26/Going-Async-With-ES6-Generators/" data-id="cirx40r1v0001scnbzj31ovfo" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/generator-async-translation/">generator async translation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Diving-Deeper-With-ES6-Generators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2014/12/24/Diving-Deeper-With-ES6-Generators/" class="article-date">
  <time datetime="2014-12-25T06:29:28.000Z" itemprop="datePublished">2014-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2014/12/24/Diving-Deeper-With-ES6-Generators/">Diving Deeper With ES6 Generators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#深入ES6Generators（译）</p>
<p>原文地址：<a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">http://davidwalsh.name/es6-generators-dive</a></p>
<p>ES6 Generators：全系列</p>
<ol>
<li><a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">The Basics Of ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">Diving Deeper With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">Getting Concurrent With ES6 Generators</a></li>
</ol>
<p>如果你仍然不熟悉ES6 generator，首先去读一读并理解“<a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">第一部分：ES6Generator基础</a>”。一旦你认为你已经了解了这些基础，现在我们就可以深入到一些细节之中了。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>ES6 generator设计时一个最为强大的部分就是它内部的代码语义是同步的，即使外部迭代控制是异步执行的。</p>
<p>这是个很棒而且复杂的方式，意味着你可以使用简单的错误处理技术，这个技术你可能已经非常熟悉了 – 也就是<code>try..catch</code>机制</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"x: "</span> + x ); <span class="comment">// may never get here!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管函数会在<code>yield 3</code>表达式处停止，并且可能随意暂停一段时间，如果一个错误没回传到generator，那个<code>try..catch</code>会捕获它！尝试用普通的异步能力（例如callback）来做做看？：）</p>
<p>但是，怎样才能使一个错误返回到generator中呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res = it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// instead of resuming normally with another `next(..)` call,</span></span><br><span class="line"><span class="comment">// let's throw a wrench (an error) into the gears:</span></span><br><span class="line">it.throw( <span class="string">"Oops!"</span> ); <span class="comment">// Error: Oops!</span></span><br></pre></td></tr></table></figure>
<p>这里，你可以看到我们使用了iterator上的另一个方法 – <code>throw(..)</code> – 它会“抛”一个异常到generator中，就像它正好在generator当前<code>yield</code>暂停处发生一样。<code>try..catch</code>捕获如你所期望的那样这个错误！</p>
<p>注：如果你<code>throw(..)</code>一个错误进入generator，而没有<code>try..catch</code>住它，那么这个错误会（和普通错误一样）传播会来（如果最终没有被捕获，则会成为一个未被捕获的异常）。因此：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    it.throw( <span class="string">"Oops!"</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"Error: "</span> + err ); <span class="comment">// Error: Oops!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，反方向的错误处理方式同样可行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> y = x.toUpperCase(); <span class="comment">// could be a TypeError error!</span></span><br><span class="line">    <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    it.next( <span class="number">42</span> ); <span class="comment">// `42` won't have `toUpperCase()`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( err ); <span class="comment">// TypeError (from `toUpperCase()` call)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="generator代理"><a href="#generator代理" class="headerlink" title="generator代理"></a>generator代理</h2><p>你可能想做的另一件事情是从你的generator函数内部调用另一个generator。我指的并不仅仅是普通方式实例化一个generator，而是代理你自己的的迭代控制到那一个另外的generator上。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> *foo(); <span class="comment">// `yield *` delegates iteration control to `foo()`</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> bar()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<p>如在第一部分解释的那样（我使用<code>function *foo(){ }</code>而不是<code>function* foo(){ }</code>），我这里同样使用<code>yield *foo()</code>来代替很多其他文章/文档使用的<code>yield* foo()</code>。我认为这样可以更加准确/清晰地说明代码正在做些什么。</p>
<p>让我们分解一下看看它是如何工作的。<code>yield 1</code>和<code>yield 2</code>直接发送他们的值到<code>for..of</code>循环外的<code>next()</code>的（隐式）调用中，就像我们已经理解/期望的那样。</p>
<p>但是接着程序就走到了<code>yield*</code>，然后你会注意到，我们正在通过实例化它（foo()）yield到另一个generator。因此我们基本上是在yield或代理到另一个generator的iterator上 – 这可能是最准确的想象它的方式。</p>
<p>一旦<code>yield*</code>被（临时）从<code>*bar()</code>代理到<code>*foo()</code>，那么现在<code>for..of</code>循环的<code>next()</code>调用实际上是在控制<code>foo()</code>，因此<code>yield 3</code>和<code>yield 4</code>发送他们的值到外面的<code>for..of</code>循环中。</p>
<p>一旦<code>*foo()</code>结束，控制权会返回到最初的generator上，它最终调用到<code>yield 5</code></p>
<p>为了简化起见，这个例子仅仅<code>yield</code>值出去，但是当然如果你不适用一个<code>for..of</code>循环，而是就手动调用iterator的<code>next(..)</code>并且通过消息传递，这些消息会通过同样的行为穿过<code>yield*</code>代理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> w = <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"z: "</span> + z + <span class="string">", w: "</span> + w );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> *foo(); <span class="comment">// `yield*` delegates iteration control to `foo()`</span></span><br><span class="line">    <span class="keyword">var</span> v = <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"x: "</span> + x + <span class="string">", y: "</span> + y + <span class="string">", v: "</span> + v );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next();      <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line">it.next( <span class="string">"X"</span> ); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line">it.next( <span class="string">"Y"</span> ); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line">it.next( <span class="string">"Z"</span> ); <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line">it.next( <span class="string">"W"</span> ); <span class="comment">// &#123; value:5, done:false &#125;</span></span><br><span class="line"><span class="comment">// z: Z, w: W</span></span><br><span class="line"></span><br><span class="line">it.next( <span class="string">"V"</span> ); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br><span class="line"><span class="comment">// x: X, y: Y, v: V</span></span><br></pre></td></tr></table></figure>
<p>尽管我们在这里只显示了一层代理，而<code>*foo()</code>去<code>yield*</code>代理到另一个、另一个、另一个generator也是可以的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"foo"</span>; <span class="comment">// return value back to `yield*` expression</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> v = <span class="keyword">yield</span> *foo();</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"v: "</span> + v );</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// "v: foo"   &#123; value:4, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>如你所见，<code>yield *foo()</code>代理迭代循环（这些<code>next()</code>调用）知道结束，然后一旦它这样做，任何从<code>foo()</code>中<code>return</code>的值（在本例里：字符串<code>&quot;foo&quot;</code>）会被设置为<code>yield*</code>表达式的结果值，然后被赋值给本地变量<code>v</code>。</p>
<p><code>yield</code>和<code>yield*</code>之间有一个有趣的区别：对于<code>yiled</code>表达式，其结果是任何同事子序列<code>next(..)</code>传入的值，但是对于<code>yield*</code>表达式，它仅仅接收被代理的generator的<code>return</code>值（因为<code>next(..)</code>发送的值是对代理透明的）。</p>
<p>你也可以通过<code>yield*</code>代理从两个方向进行错误处理（如前所示）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"foo caught: "</span> + err );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// pause</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// now, throw another error</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"Oops!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> *foo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"bar caught: "</span> + err );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line"></span><br><span class="line">it.throw( <span class="string">"Uh oh!"</span> ); <span class="comment">// will be caught inside `foo()`</span></span><br><span class="line"><span class="comment">// foo caught: Uh oh!</span></span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:undefined, done:true &#125;  --&gt; No error here!</span></span><br><span class="line"><span class="comment">// bar caught: Oops!</span></span><br></pre></td></tr></table></figure>
<p>如你所见，<code>throw(&quot;Uh oh!&quot;)</code>通过<code>yield*</code>代理抛出错误到<code>*foo()</code>内部的<code>try..catch</code>中。同样的，<code>*foo()</code>内部的<code>throw &quot;Oops!&quot;</code>抛回到<code>*bar()</code>中，然后它在另一个<code>try..catch</code>中捕获这个错误，如果我们没有捕获其中的某一个，那么这些错误会继续向外传播像你平常期望的那样。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Generator具有同步的语法，这表示你可以穿过<code>yield</code>表达式使用<code>try..catch</code>错误处理机制。generator同时也有一个<code>throw(..)</code>方法将一个错误抛入generator的暂停位置，这当然也可以被generator内部的<code>try..catch</code>捕获。</p>
<p><code>yield*</code>允许你从当前的generator代理迭代控制到另一个generator。其结果是<code>yield*</code>表现得像一个连接两个方向的通道，同时可供传递消息以及错误。</p>
<p>但是，到现在位置，我们还有一个基本的问题没有解决：generator是如何帮助我们处理异步模式的呢？我们现在在这两篇文章中所见的一切都是generator函数的同步迭代。</p>
<p>其中的关键就是建立一种机制，generator暂停以开始一个异步任务，然后在异步任务结束时恢复（通过他的iterator的<code>next()</code>调用）。我们将在下一篇文章中探索各种关于使用generator创造这样的异步控制机制的方式。请继续关注！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2014/12/24/Diving-Deeper-With-ES6-Generators/" data-id="cirx40r2b0004scnba134klxt" class="article-share-link">Delen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-The-Basics-Of-ES6-Generators" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog-hexo/2014/12/21/The-Basics-Of-ES6-Generators/" class="article-date">
  <time datetime="2014-12-21T19:33:48.000Z" itemprop="datePublished">2014-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog-hexo/2014/12/21/The-Basics-Of-ES6-Generators/">The Basics Of ES6 Generators</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#ES6Generator基础（译）</p>
<p>原文地址：<a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">http://davidwalsh.name/es6-generators</a></p>
<p>ES6 Generators：全系列</p>
<ol>
<li><a href="http://davidwalsh.name/es6-generators" target="_blank" rel="external">The Basics Of ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/es6-generators-dive" target="_blank" rel="external">Diving Deeper With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/async-generators" target="_blank" rel="external">Going Async With ES6 Generators</a></li>
<li><a href="http://davidwalsh.name/concurrent-generators" target="_blank" rel="external">Getting Concurrent With ES6 Generators</a></li>
</ol>
<p>Javascript ES6 带来的一种最激动人心的新特性是一种新的函数，称为<strong>generator</strong>。它的名字可能有一点奇怪，但是它的行为在第一次看来却<em>更让人陌生</em>。这篇文章旨在解释它的是如何工作的基础概念，并且使你明白为什么它们对于JS的未来如此的强大。</p>
<p>##运行至完成</p>
<p>当我们讨论generator时我们所要见到的第一件事情就是：它们与普通函数对于“运行至完成”的概念是多么的不同。</p>
<p>无论你是否意识到，你对于函数的基础已经常常可以断言一些事情：一旦函数开始执行，在其他JS代码可以执行之前，它总会执行到结束。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> don't ever do crazy long-running loops like this</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;=<span class="number">1E10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 0..1E10</span></span><br><span class="line"><span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure>
<p>在这里，<code>for</code>循环会花费非常长的时间直到结束，至少比一毫秒要长，但是我们的计时器回调<code>console.log(...)</code>语句无法在<code>foo()</code>函数执行时打断它，因此它被堵塞语句之后（在event-loop中）并耐心地等到自己的回合。</p>
<p>如果<code>foo()</code>可以被打断，会怎么样呢？那样不会对我们的程序造成极大的破坏吗？</p>
<p>那就是多线程编程的<del>噩梦</del>挑战。但我们非常幸运地处在JavaScript的世界里而不必担心这些事情，因为JS总是单线程的（只有一个命令/函数可以在一个时刻执行）。</p>
<p>注：Web Worker是一种机制，它允许你开启一个完全单独的线程让一部分JS程序在其中执行，该线程完全与你的主JS程序线程并行。此机制并未向我们的程序中引入多线程并发，是因为两个线程只能通过普通的异步事件进行通信，而它总是遵循event-loop的<em>一次执行一个</em>的行为，该行为是由“运行至完成”所要求的。</p>
<p>##运行..停止..运行</p>
<p>对于ES6 generator，我们有另一种类型的函数，它可能在中间<em>暂停</em>，一次或多次，并在<em>之后</em>恢复，允许其他代码在暂停的间隙执行。</p>
<p>如果你曾经阅读过任何有关并发或基于线程的编程的内容，你可能见过“协作”这个词，它基本上意味着一个进程（在我们的例子中，是一个函数）自身选择何时它允许一个中断，这样它可以与其他代码进行<strong>“协作”</strong>。与这个概念相对应的是“抢占”，它表明一个进程/函数可以不依照其意愿被打断。</p>
<p>ES6 generator函数在其并发行为上是“协作”式的。在generator函数体内，你可以使用新的<code>yield</code>关键词来从函数自身中暂停。没有任何东西可以从一个generator的外部暂停它，仅当generator（在内部）遇到一个yield时，它才会暂停自己。</p>
<p>但是，一旦generator使用<code>yield</code>暂停了自身，它自己无法进行恢复。必须使用一个外部的控制方式重启generator。我们会在下面解释这是如何发生的。</p>
<p>因此，基本上，一个generator函数可以停止以及被重启任意次数。事实上，你可以在一个无限循环（例如臭名昭著的<code>while (true) { .. }</code>）中指定一个generator函数，尽管这基本上是非常疯狂的并且在普通的JS程序中是错误的，而使用generator函数这是完全正常的并且有时候正事你所希望做的那样。</p>
<p>甚至更为重要的是，停止和重启并不仅仅是控制generator函数的执行，它也使得执行时的双向的信息传递（出入generator）变为可能。使用普通函数时，你会在开始获取参数并在结束时<code>return</code>一个值。使用generator函数，你可以使用每一个<code>yield</code>发出消息，并且你可以在每次重启时回传消息。</p>
<h2 id="请告诉我语法，谢谢！"><a href="#请告诉我语法，谢谢！" class="headerlink" title="请告诉我语法，谢谢！"></a>请告诉我语法，谢谢！</h2><p>让我们看看这些新的激动人心的generator函数的语法。</p>
<p>首先，它有新的声明语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这里的<code>*</code>了吗？这是一种新的语法并且看起来有一点奇怪。对于那些来自于其他语言的开发者来说，这可能看起来非常像函数返回值的指针。但是请不要被它迷惑！这仅仅是一个来标志特殊的generator函数类型的方式。</p>
<p>你可能见过其它文章/文档使用<code>function* foo(){ }</code> 而不是<code>function *foo(){ }</code> （<code>*</code>的位置不同）。它们都是有效的，但是我最近决定使用<code>function *foo() {}</code>因为这样更加准确，因此我会在这里这样写。</p>
<p>现在，让我们来谈谈我们的generator函数的内容。generator函数在很多方面都只是普通的JS函数。在generator函数内部，新的语法非常少。</p>
<p>我们主要使用的语法，入上面所述，是<code>yield</code>关键词。<code>yield ___</code>被称为“yield表达式”（不是一个语句），因为当我们重启generator时，我们会回传一个值到内部，并且无论我们返回的是什么它都会被作为<code>yield ___</code>表达式的计算结果。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span> + (<span class="keyword">yield</span> <span class="string">"foo"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，当generator函数在<code>yield &quot;foo&quot;</code>暂停时，表达式会发送<code>&quot;foo&quot;</code>字符串出去，并且无论何时，只要generator被重启，无论什么值被发送，它会被作为这个表达式的结果，这个值然后会加上<code>1</code>并且赋值给<code>x</code>变量。</p>
<p>看见这里的双向交流了吗？你发送<code>&quot;foo&quot;</code>出去，暂停你自己，然后在某一个<em>之后</em>的时间点（可能是立即，也可能是距离现在非常长的时间！），generator会被重启并且提供你一个返回值。差不多<code>yield</code>关键词是某种创造向外请求一个值的方式。</p>
<p>在任何表达式的地方，你可以仅仅使用<code>yield</code>自身，这表明你向外<code>yield</code>一个<code>undefined</code>。像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: `foo(..)` here is NOT a generator!!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"x: "</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>; <span class="comment">// just pause</span></span><br><span class="line">    foo( <span class="keyword">yield</span> ); <span class="comment">// pause waiting for a parameter to pass into `foo(..)`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##Generator迭代器</p>
<p>“Generator Iterator”。的确又长又难念，是吧？</p>
<p>迭代器是一种特殊的行为类型，事实上，它是一种设计模式，我们按某种顺序遍历一组值，每次通过调用<code>next()</code>获取一个值。例如设想一下对这样一个数组<code>[1, 2, 3, 4, 5]</code>使用一个迭代器。第一个<code>next()</code>调用会返回<code>1</code>，第二个<code>next()</code>会返回<code>2</code>，并一次类推。当所有的值都被返回之后，最后的<code>next()</code>会返回<code>null</code>或者<code>false</code>，或者其他的信号标志你已经迭代完容器内的所有值。</p>
<p>我们从外部控制generator函数的方式，是使用一个<em>generator iterator</em>构造并且交互。这听起来比实际上做起来要复杂。想想一下这个很蠢的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了从<code>*foo()</code>这个generator函数中遍历值，我们需要构造一个迭代器，如何做呢？非常简单！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = foo();</span><br></pre></td></tr></table></figure>
<p>噢！所以，用普通方式调用generator函数实际上并没有执行它的任何内容。</p>
<p>把这些塞进你的大脑有一点奇怪。你可能尝试疑问：为什么不是<code>var it = new foo()</code>？好吧，这个语法背后的原因很复杂并且不在我们所要讨论的范围内。</p>
<p>那么现在，开始迭代我们自己的generator函数，我们只需：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = it.next();</span><br></pre></td></tr></table></figure>
<p>这会给我们从<code>yield 1</code>语句中提供<code>1</code>，但这并不是唯一我们得到的东西。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>我们事实上从每个<code>next()</code>调用中获取了一个对象，它包含一个<code>value</code>属性用来描述<code>yield</code>出的值，而<code>done</code>是一个布尔值它用来标志是否generator函数是否已经完全结束。</p>
<p>让我们继续我们的迭代：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:2, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:5, done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>有趣的是，当我们取出<code>`5</code>时，done<code>仍然是</code>false<code>。这是因为*严格来说*，generator函数并没有完成。我们仍然需要调用最后一个</code>next()<code>，并且我们传入一个值时，它会被设置为</code>yield 5`表达式的结果。只有<strong>那时</strong>，generator函数才算是结束了。</p>
<p>那么，现在：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:undefined, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>因此，最后我们generator函数的结果是我们完成了这个函数，并且没有提供任何结果（因为我们已经耗尽了所有的<code>yield ___</code>表达式）。</p>
<p>你可能在这一点上想：我能不能在generator函数中使用<code>return</code>呢，如果我这样做，最后的结果会被设置在<code>value</code>属性上吗？</p>
<p>###是…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:1, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() ); <span class="comment">// &#123; value:2, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>###…又不是</p>
<p>依赖来自于generator的<code>return</code>值不是一个好主意，因为当使用<code>for..of</code>来迭代generator函数（见下）时，最后的<code>return</code>值会被扔掉。</p>
<p>为了完整性考虑，我们也来看看早我们遍历一个generator函数时同时向内和向外发送消息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo( <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// note: not sending anything into `next()` here</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next() );       <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next( <span class="number">12</span> ) );   <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log( it.next( <span class="number">13</span> ) );   <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>你可以看到我们仍然可以通过最初的实例化调用<code>foo(5)</code>传递初始值，就像普通的函数那样。</p>
<p>第一个<code>next(..)</code>调用，我们不传递任何值，为什么？因为没有<code>yield</code>表达式接受我们传入的值。</p>
<p>但是如果我们的确向第一个<code>next(..)</code>调用传递了值，也不会有任何坏的事情发生，它只会被抛弃掉。对于这种情况，ES6描述了generator函数忽略未使用的值。（<strong>注：</strong>在写作这篇文章时，最新版本的Chrome和FF都表现如此，但是其他浏览器可能不完全兼容并可能不正确地对这种情况抛出一个异常）。</p>
<p>第二个<code>next(12)</code>调用将<code>12</code>传递给第一个<code>yield (x + 1)</code>表达式。第三个<code>next(13)</code>调用将<code>13</code>传递给第二个<code>yield (y / 3)</code>表达式。<strong>反复地重新阅读这段代码</strong>。对于很多人来说，在他们刚开始看这些代码的时候感觉奇怪。</p>
<p>##<code>for...of</code></p>
<p>ES6同样在语法级别拥抱这种迭代器模式，通过直接提供对执行迭代器到结束的支持：<code>for..of</code>循环。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( v );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( v ); <span class="comment">// still `5`, not `6` :(</span></span><br></pre></td></tr></table></figure>
<p>如你所见，由<code>foo()</code>创建的迭代器被<code>for..of</code>循环自动地捕获，并且会为你自动地进行迭代，每轮迭代获取一个值直到得到一个<code>done:true</code>。只要<code>done</code>是<code>false</code>，它就会自动的提取<code>value</code>属性并分配给你的迭代变量中（在我们这里是<code>v</code>）。一旦<code>done</code>已经变为<code>true</code>，迭代循环停止（并且不对最后返回的<code>value</code>做任何处理，如果有的话）。</p>
<p>如之前所述，你可以看到<code>for..of</code>循环忽略并抛弃了<code>return 6</code>的值。同事由于没有暴露<code>next()</code>调用，<code>for..of</code>循环无法用于像我们之前那样向generator传入值的场合。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好的，这就是generator的基础。如果你还有一些不明白的话，不必担心。我们每个人开始时都感觉像那样！</p>
<p>想一想这种新的玩具会如何改变你的代码是很自然的。尽管还有<strong>很多</strong>内容，我们刚刚触及了表面。所以在我们了解它们是多么强大之前我们必须要更深入地了解。</p>
<p>在你运行过上面的代码片段之后（试试最新的Chrome,FF或者node0.11+带上<code>--harmony</code>标志），你可能会产生以下的疑问：</p>
<ol>
<li>如何进行错误处理？</li>
<li>一个generator可以调用另一个generator吗？</li>
<li>异步代码如何与generator交互？</li>
</ol>
<p>这些，或更多的问题，会在接下来的几篇文章中阐述，请继续关注！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://nnabuuu.github.io/blog-hexo/blog-hexo/2014/12/21/The-Basics-Of-ES6-Generators/" data-id="cirx40r3n000iscnbwrttr8wg" class="article-share-link">Delen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog-hexo/tags/js-generator-tanslation/">js, generator, tanslation</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/blog-hexo/page/2/">2</a><a class="extend next" rel="next" href="/blog-hexo/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Labels</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/Haskell/">Haskell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/NodeJS/">NodeJS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/Translation/">Translation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/generator-async-translation/">generator async translation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/generator-translation/">generator translation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/jison/">jison</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/js-generator-tanslation/">js, generator, tanslation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog-hexo/tags/translation/">translation</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog-hexo/tags/Haskell/" style="font-size: 10px;">Haskell</a> <a href="/blog-hexo/tags/NodeJS/" style="font-size: 15px;">NodeJS</a> <a href="/blog-hexo/tags/Translation/" style="font-size: 10px;">Translation</a> <a href="/blog-hexo/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/blog-hexo/tags/docker/" style="font-size: 10px;">docker</a> <a href="/blog-hexo/tags/generator-async-translation/" style="font-size: 10px;">generator async translation</a> <a href="/blog-hexo/tags/generator-translation/" style="font-size: 10px;">generator translation</a> <a href="/blog-hexo/tags/jison/" style="font-size: 15px;">jison</a> <a href="/blog-hexo/tags/js-generator-tanslation/" style="font-size: 10px;">js, generator, tanslation</a> <a href="/blog-hexo/tags/translation/" style="font-size: 20px;">translation</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archieven</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/11/">November 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/10/">October 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/08/">August 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog-hexo/archives/2014/06/">June 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recente berichten</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog-hexo/2016/08/15/How-many-kinds-of-squares-password/">How many kinds of squares password</a>
          </li>
        
          <li>
            <a href="/blog-hexo/2016/08/03/fix-docker-x509-error/">fix-docker-x509-error</a>
          </li>
        
          <li>
            <a href="/blog-hexo/2016/04/29/Parsing-text-table-with-jison-3/">Parsing-text-table-with-jison-3</a>
          </li>
        
          <li>
            <a href="/blog-hexo/2016/04/28/Parsing-text-table-with-jison-2/">Parsing-text-table-with-jison-2</a>
          </li>
        
          <li>
            <a href="/blog-hexo/2016/04/21/Parsing-text-table-with-jison/">Parsing-text-table-with-jison</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Xiaochen Nie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog-hexo/" class="mobile-nav-link">Home</a>
  
    <a href="/blog-hexo/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog-hexo/fancybox/jquery.fancybox.css">
  <script src="/blog-hexo/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog-hexo/js/script.js"></script>

  </div>
</body>
</html>